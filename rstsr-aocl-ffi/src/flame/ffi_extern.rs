
//! FFI function declarations for non-dynamic-loading.
//!
//! This file is generated automatically.

use super::*;

unsafe extern "C" {
    pub fn AOCL_FAL_Close(fpFilePointer: *mut FILE) -> int32;
    pub fn AOCL_FAL_Error(fpFilePointer: *mut FILE) -> int32;
    pub fn AOCL_FAL_Open(pchFileName: *const int8, pchMode: *const int8) -> *mut FILE;
    pub fn AOCL_FAL_Read(
        pvBuffer: *mut c_void,
        i32Size: int32,
        i32Count: int32,
        fpFilePointer: *mut FILE,
    ) -> int32;
    pub fn AOCL_FAL_Write(
        pvBuffer: *const c_void,
        i32Size: int32,
        iCount: int32,
        fpFilePointer: *mut FILE,
    ) -> int32;
    pub fn AOCL_FLIST_IsEmpty(plist: *mut AOCL_FLIST_Node) -> Bool;
    pub fn AOCL_FLIST_GetFile(plist: *mut AOCL_FLIST_Node, tid: AOCL_TID) -> *mut FILE;
    pub fn AOCL_FLIST_AddFile(
        pchFilePrefix: *const int8,
        plist: *mut *mut AOCL_FLIST_Node,
        tid: AOCL_TID,
    ) -> *mut FILE;
    pub fn AOCL_FLIST_CloseFile(plist: *mut AOCL_FLIST_Node, tid: AOCL_TID);
    pub fn AOCL_FLIST_CloseAll(plist: *mut AOCL_FLIST_Node);
    pub fn aocl_fla_set_progress(func: aocl_fla_progress_callback);
    pub static mut aocl_fla_progress_glb_ptr: aocl_fla_progress_callback;
    pub fn aocl_fla_progress(
        api: *const c_char,
        lenapi: integer,
        progress: *const integer,
        current_thread: *const integer,
        total_threads: *const integer,
    ) -> c_int;
    pub fn fla_pthread_mutex_lock(mutex: *mut fla_pthread_mutex_t) -> c_int;
    pub fn fla_pthread_mutex_unlock(mutex: *mut fla_pthread_mutex_t) -> c_int;
    pub fn fla_pthread_once(
        once: *mut fla_pthread_once_t,
        init: Option<extern "C" fn()>,
    );
    pub static mut fla_global_context: fla_context;
    pub static mut fla_tl_context: fla_tl_context_t;
    pub fn aocl_fla_init();
    pub fn aocl_fla_finalize();
    pub fn FLA_Thread_get_subrange(
        thread_ID: c_int,
        num_threads: c_int,
        range: integer,
        sub_range: *mut integer,
        index: *mut integer,
    );
    pub fn FLA_Thread_optimum(family: API_ID, actual_num_threads: *mut c_int);
    pub fn bl1_s2() -> f32;
    pub fn bl1_d2() -> f64;
    pub fn bl1_c2() -> scomplex;
    pub fn bl1_z2() -> dcomplex;
    pub fn bl1_s1() -> f32;
    pub fn bl1_d1() -> f64;
    pub fn bl1_c1() -> scomplex;
    pub fn bl1_z1() -> dcomplex;
    pub fn bl1_s1h() -> f32;
    pub fn bl1_d1h() -> f64;
    pub fn bl1_c1h() -> scomplex;
    pub fn bl1_z1h() -> dcomplex;
    pub fn bl1_s0() -> f32;
    pub fn bl1_d0() -> f64;
    pub fn bl1_c0() -> scomplex;
    pub fn bl1_z0() -> dcomplex;
    pub fn bl1_sm1h() -> f32;
    pub fn bl1_dm1h() -> f64;
    pub fn bl1_cm1h() -> scomplex;
    pub fn bl1_zm1h() -> dcomplex;
    pub fn bl1_sm1() -> f32;
    pub fn bl1_dm1() -> f64;
    pub fn bl1_cm1() -> scomplex;
    pub fn bl1_zm1() -> dcomplex;
    pub fn bl1_sm2() -> f32;
    pub fn bl1_dm2() -> f64;
    pub fn bl1_cm2() -> scomplex;
    pub fn bl1_zm2() -> dcomplex;
    pub fn bl1_vallocv(n_elem: uinteger, elem_size: uinteger) -> *mut c_void;
    pub fn bl1_iallocv(n_elem: uinteger) -> *mut integer;
    pub fn bl1_sallocv(n_elem: uinteger) -> *mut f32;
    pub fn bl1_dallocv(n_elem: uinteger) -> *mut f64;
    pub fn bl1_callocv(n_elem: uinteger) -> *mut scomplex;
    pub fn bl1_zallocv(n_elem: uinteger) -> *mut dcomplex;
    pub fn bl1_vallocm(m: uinteger, n: uinteger, elem_size: uinteger) -> *mut c_void;
    pub fn bl1_iallocm(m: uinteger, n: uinteger) -> *mut integer;
    pub fn bl1_sallocm(m: uinteger, n: uinteger) -> *mut f32;
    pub fn bl1_dallocm(m: uinteger, n: uinteger) -> *mut f64;
    pub fn bl1_callocm(m: uinteger, n: uinteger) -> *mut scomplex;
    pub fn bl1_zallocm(m: uinteger, n: uinteger) -> *mut dcomplex;
    pub fn bl1_sapdiagmv(
        side: side1_t,
        conj: conj1_t,
        m: integer,
        n: integer,
        x: *mut f32,
        incx: integer,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_dapdiagmv(
        side: side1_t,
        conj: conj1_t,
        m: integer,
        n: integer,
        x: *mut f64,
        incx: integer,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_csapdiagmv(
        side: side1_t,
        conj: conj1_t,
        m: integer,
        n: integer,
        x: *mut f32,
        incx: integer,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_capdiagmv(
        side: side1_t,
        conj: conj1_t,
        m: integer,
        n: integer,
        x: *mut scomplex,
        incx: integer,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_zdapdiagmv(
        side: side1_t,
        conj: conj1_t,
        m: integer,
        n: integer,
        x: *mut f64,
        incx: integer,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_zapdiagmv(
        side: side1_t,
        conj: conj1_t,
        m: integer,
        n: integer,
        x: *mut dcomplex,
        incx: integer,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_screate_contigm(
        m: integer,
        n: integer,
        a_save: *mut f32,
        a_rs_save: integer,
        a_cs_save: integer,
        a: *mut *mut f32,
        a_rs: *mut integer,
        a_cs: *mut integer,
    );
    pub fn bl1_dcreate_contigm(
        m: integer,
        n: integer,
        a_save: *mut f64,
        a_rs_save: integer,
        a_cs_save: integer,
        a: *mut *mut f64,
        a_rs: *mut integer,
        a_cs: *mut integer,
    );
    pub fn bl1_ccreate_contigm(
        m: integer,
        n: integer,
        a_save: *mut scomplex,
        a_rs_save: integer,
        a_cs_save: integer,
        a: *mut *mut scomplex,
        a_rs: *mut integer,
        a_cs: *mut integer,
    );
    pub fn bl1_zcreate_contigm(
        m: integer,
        n: integer,
        a_save: *mut dcomplex,
        a_rs_save: integer,
        a_cs_save: integer,
        a: *mut *mut dcomplex,
        a_rs: *mut integer,
        a_cs: *mut integer,
    );
    pub fn bl1_screate_contigmt(
        trans_dims: trans1_t,
        m: integer,
        n: integer,
        a_save: *mut f32,
        a_rs_save: integer,
        a_cs_save: integer,
        a: *mut *mut f32,
        a_rs: *mut integer,
        a_cs: *mut integer,
    );
    pub fn bl1_dcreate_contigmt(
        trans_dims: trans1_t,
        m: integer,
        n: integer,
        a_save: *mut f64,
        a_rs_save: integer,
        a_cs_save: integer,
        a: *mut *mut f64,
        a_rs: *mut integer,
        a_cs: *mut integer,
    );
    pub fn bl1_ccreate_contigmt(
        trans_dims: trans1_t,
        m: integer,
        n: integer,
        a_save: *mut scomplex,
        a_rs_save: integer,
        a_cs_save: integer,
        a: *mut *mut scomplex,
        a_rs: *mut integer,
        a_cs: *mut integer,
    );
    pub fn bl1_zcreate_contigmt(
        trans_dims: trans1_t,
        m: integer,
        n: integer,
        a_save: *mut dcomplex,
        a_rs_save: integer,
        a_cs_save: integer,
        a: *mut *mut dcomplex,
        a_rs: *mut integer,
        a_cs: *mut integer,
    );
    pub fn bl1_screate_contigmr(
        uplo: uplo1_t,
        m: integer,
        n: integer,
        a_save: *mut f32,
        a_rs_save: integer,
        a_cs_save: integer,
        a: *mut *mut f32,
        a_rs: *mut integer,
        a_cs: *mut integer,
    );
    pub fn bl1_dcreate_contigmr(
        uplo: uplo1_t,
        m: integer,
        n: integer,
        a_save: *mut f64,
        a_rs_save: integer,
        a_cs_save: integer,
        a: *mut *mut f64,
        a_rs: *mut integer,
        a_cs: *mut integer,
    );
    pub fn bl1_ccreate_contigmr(
        uplo: uplo1_t,
        m: integer,
        n: integer,
        a_save: *mut scomplex,
        a_rs_save: integer,
        a_cs_save: integer,
        a: *mut *mut scomplex,
        a_rs: *mut integer,
        a_cs: *mut integer,
    );
    pub fn bl1_zcreate_contigmr(
        uplo: uplo1_t,
        m: integer,
        n: integer,
        a_save: *mut dcomplex,
        a_rs_save: integer,
        a_cs_save: integer,
        a: *mut *mut dcomplex,
        a_rs: *mut integer,
        a_cs: *mut integer,
    );
    pub fn bl1_screate_contigmsr(
        side: side1_t,
        uplo: uplo1_t,
        m: integer,
        n: integer,
        a_save: *mut f32,
        a_rs_save: integer,
        a_cs_save: integer,
        a: *mut *mut f32,
        a_rs: *mut integer,
        a_cs: *mut integer,
    );
    pub fn bl1_dcreate_contigmsr(
        side: side1_t,
        uplo: uplo1_t,
        m: integer,
        n: integer,
        a_save: *mut f64,
        a_rs_save: integer,
        a_cs_save: integer,
        a: *mut *mut f64,
        a_rs: *mut integer,
        a_cs: *mut integer,
    );
    pub fn bl1_ccreate_contigmsr(
        side: side1_t,
        uplo: uplo1_t,
        m: integer,
        n: integer,
        a_save: *mut scomplex,
        a_rs_save: integer,
        a_cs_save: integer,
        a: *mut *mut scomplex,
        a_rs: *mut integer,
        a_cs: *mut integer,
    );
    pub fn bl1_zcreate_contigmsr(
        side: side1_t,
        uplo: uplo1_t,
        m: integer,
        n: integer,
        a_save: *mut dcomplex,
        a_rs_save: integer,
        a_cs_save: integer,
        a: *mut *mut dcomplex,
        a_rs: *mut integer,
        a_cs: *mut integer,
    );
    pub fn bl1_sfree_contigm(
        a_save: *mut f32,
        a_rs_save: integer,
        a_cs_save: integer,
        a: *mut *mut f32,
        a_rs: *mut integer,
        a_cs: *mut integer,
    );
    pub fn bl1_dfree_contigm(
        a_save: *mut f64,
        a_rs_save: integer,
        a_cs_save: integer,
        a: *mut *mut f64,
        a_rs: *mut integer,
        a_cs: *mut integer,
    );
    pub fn bl1_cfree_contigm(
        a_save: *mut scomplex,
        a_rs_save: integer,
        a_cs_save: integer,
        a: *mut *mut scomplex,
        a_rs: *mut integer,
        a_cs: *mut integer,
    );
    pub fn bl1_zfree_contigm(
        a_save: *mut dcomplex,
        a_rs_save: integer,
        a_cs_save: integer,
        a: *mut *mut dcomplex,
        a_rs: *mut integer,
        a_cs: *mut integer,
    );
    pub fn bl1_sfree_saved_contigm(
        m: integer,
        n: integer,
        a_save: *mut f32,
        a_rs_save: integer,
        a_cs_save: integer,
        a: *mut *mut f32,
        a_rs: *mut integer,
        a_cs: *mut integer,
    );
    pub fn bl1_dfree_saved_contigm(
        m: integer,
        n: integer,
        a_save: *mut f64,
        a_rs_save: integer,
        a_cs_save: integer,
        a: *mut *mut f64,
        a_rs: *mut integer,
        a_cs: *mut integer,
    );
    pub fn bl1_cfree_saved_contigm(
        m: integer,
        n: integer,
        a_save: *mut scomplex,
        a_rs_save: integer,
        a_cs_save: integer,
        a: *mut *mut scomplex,
        a_rs: *mut integer,
        a_cs: *mut integer,
    );
    pub fn bl1_zfree_saved_contigm(
        m: integer,
        n: integer,
        a_save: *mut dcomplex,
        a_rs_save: integer,
        a_cs_save: integer,
        a: *mut *mut dcomplex,
        a_rs: *mut integer,
        a_cs: *mut integer,
    );
    pub fn bl1_sfree_saved_contigmr(
        uplo: uplo1_t,
        m: integer,
        n: integer,
        a_save: *mut f32,
        a_rs_save: integer,
        a_cs_save: integer,
        a: *mut *mut f32,
        a_rs: *mut integer,
        a_cs: *mut integer,
    );
    pub fn bl1_dfree_saved_contigmr(
        uplo: uplo1_t,
        m: integer,
        n: integer,
        a_save: *mut f64,
        a_rs_save: integer,
        a_cs_save: integer,
        a: *mut *mut f64,
        a_rs: *mut integer,
        a_cs: *mut integer,
    );
    pub fn bl1_cfree_saved_contigmr(
        uplo: uplo1_t,
        m: integer,
        n: integer,
        a_save: *mut scomplex,
        a_rs_save: integer,
        a_cs_save: integer,
        a: *mut *mut scomplex,
        a_rs: *mut integer,
        a_cs: *mut integer,
    );
    pub fn bl1_zfree_saved_contigmr(
        uplo: uplo1_t,
        m: integer,
        n: integer,
        a_save: *mut dcomplex,
        a_rs_save: integer,
        a_cs_save: integer,
        a: *mut *mut dcomplex,
        a_rs: *mut integer,
        a_cs: *mut integer,
    );
    pub fn bl1_sfree_saved_contigmsr(
        side: side1_t,
        uplo: uplo1_t,
        m: integer,
        n: integer,
        a_save: *mut f32,
        a_rs_save: integer,
        a_cs_save: integer,
        a: *mut *mut f32,
        a_rs: *mut integer,
        a_cs: *mut integer,
    );
    pub fn bl1_dfree_saved_contigmsr(
        side: side1_t,
        uplo: uplo1_t,
        m: integer,
        n: integer,
        a_save: *mut f64,
        a_rs_save: integer,
        a_cs_save: integer,
        a: *mut *mut f64,
        a_rs: *mut integer,
        a_cs: *mut integer,
    );
    pub fn bl1_cfree_saved_contigmsr(
        side: side1_t,
        uplo: uplo1_t,
        m: integer,
        n: integer,
        a_save: *mut scomplex,
        a_rs_save: integer,
        a_cs_save: integer,
        a: *mut *mut scomplex,
        a_rs: *mut integer,
        a_cs: *mut integer,
    );
    pub fn bl1_zfree_saved_contigmsr(
        side: side1_t,
        uplo: uplo1_t,
        m: integer,
        n: integer,
        a_save: *mut dcomplex,
        a_rs_save: integer,
        a_cs_save: integer,
        a: *mut *mut dcomplex,
        a_rs: *mut integer,
        a_cs: *mut integer,
    );
    pub fn bl1_sewinvscalv(
        conj: conj1_t,
        n: integer,
        x: *mut f32,
        incx: integer,
        y: *mut f32,
        incy: integer,
    );
    pub fn bl1_dewinvscalv(
        conj: conj1_t,
        n: integer,
        x: *mut f64,
        incx: integer,
        y: *mut f64,
        incy: integer,
    );
    pub fn bl1_csewinvscalv(
        conj: conj1_t,
        n: integer,
        x: *mut f32,
        incx: integer,
        y: *mut scomplex,
        incy: integer,
    );
    pub fn bl1_cewinvscalv(
        conj: conj1_t,
        n: integer,
        x: *mut scomplex,
        incx: integer,
        y: *mut scomplex,
        incy: integer,
    );
    pub fn bl1_zdewinvscalv(
        conj: conj1_t,
        n: integer,
        x: *mut f64,
        incx: integer,
        y: *mut dcomplex,
        incy: integer,
    );
    pub fn bl1_zewinvscalv(
        conj: conj1_t,
        n: integer,
        x: *mut dcomplex,
        incx: integer,
        y: *mut dcomplex,
        incy: integer,
    );
    pub fn bl1_sewinvscalmt(
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
        b: *mut f32,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_dewinvscalmt(
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
        b: *mut f64,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_csewinvscalmt(
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
        b: *mut scomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_cewinvscalmt(
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut scomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_zdewinvscalmt(
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
        b: *mut dcomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_zewinvscalmt(
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut dcomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_sewscalv(
        conj: conj1_t,
        n: integer,
        x: *mut f32,
        incx: integer,
        y: *mut f32,
        incy: integer,
    );
    pub fn bl1_dewscalv(
        conj: conj1_t,
        n: integer,
        x: *mut f64,
        incx: integer,
        y: *mut f64,
        incy: integer,
    );
    pub fn bl1_csewscalv(
        conj: conj1_t,
        n: integer,
        x: *mut f32,
        incx: integer,
        y: *mut scomplex,
        incy: integer,
    );
    pub fn bl1_cewscalv(
        conj: conj1_t,
        n: integer,
        x: *mut scomplex,
        incx: integer,
        y: *mut scomplex,
        incy: integer,
    );
    pub fn bl1_zdewscalv(
        conj: conj1_t,
        n: integer,
        x: *mut f64,
        incx: integer,
        y: *mut dcomplex,
        incy: integer,
    );
    pub fn bl1_zewscalv(
        conj: conj1_t,
        n: integer,
        x: *mut dcomplex,
        incx: integer,
        y: *mut dcomplex,
        incy: integer,
    );
    pub fn bl1_sewscalmt(
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
        b: *mut f32,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_dewscalmt(
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
        b: *mut f64,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_csewscalmt(
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
        b: *mut scomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_cewscalmt(
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut scomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_zdewscalmt(
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
        b: *mut dcomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_zewscalmt(
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut dcomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_vfree(p: *mut c_void);
    pub fn bl1_ifree(p: *mut integer);
    pub fn bl1_sfree(p: *mut f32);
    pub fn bl1_dfree(p: *mut f64);
    pub fn bl1_cfree(p: *mut scomplex);
    pub fn bl1_zfree(p: *mut dcomplex);
    pub fn bl1_sinverts(conj: conj1_t, alpha: *mut f32);
    pub fn bl1_dinverts(conj: conj1_t, alpha: *mut f64);
    pub fn bl1_cinverts(conj: conj1_t, alpha: *mut scomplex);
    pub fn bl1_zinverts(conj: conj1_t, alpha: *mut dcomplex);
    pub fn bl1_sinvert2s(conj: conj1_t, alpha: *mut f32, beta: *mut f32);
    pub fn bl1_dinvert2s(conj: conj1_t, alpha: *mut f64, beta: *mut f64);
    pub fn bl1_cinvert2s(conj: conj1_t, alpha: *mut scomplex, beta: *mut scomplex);
    pub fn bl1_zinvert2s(conj: conj1_t, alpha: *mut dcomplex, beta: *mut dcomplex);
    pub fn bl1_sinvertv(conj: conj1_t, n: integer, x: *mut f32, incx: integer);
    pub fn bl1_dinvertv(conj: conj1_t, n: integer, x: *mut f64, incx: integer);
    pub fn bl1_cinvertv(conj: conj1_t, n: integer, x: *mut scomplex, incx: integer);
    pub fn bl1_zinvertv(conj: conj1_t, n: integer, x: *mut dcomplex, incx: integer);
    pub fn bl1_sident(m: integer, a: *mut f32, a_rs: integer, a_cs: integer);
    pub fn bl1_dident(m: integer, a: *mut f64, a_rs: integer, a_cs: integer);
    pub fn bl1_cident(m: integer, a: *mut scomplex, a_rs: integer, a_cs: integer);
    pub fn bl1_zident(m: integer, a: *mut dcomplex, a_rs: integer, a_cs: integer);
    pub fn bl1_smaxabsv(n: integer, x: *mut f32, incx: integer, maxabs: *mut f32);
    pub fn bl1_dmaxabsv(n: integer, x: *mut f64, incx: integer, maxabs: *mut f64);
    pub fn bl1_cmaxabsv(n: integer, x: *mut scomplex, incx: integer, maxabs: *mut f32);
    pub fn bl1_zmaxabsv(n: integer, x: *mut dcomplex, incx: integer, maxabs: *mut f64);
    pub fn bl1_smaxabsm(
        m: integer,
        n: integer,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
        maxabs: *mut f32,
    );
    pub fn bl1_dmaxabsm(
        m: integer,
        n: integer,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
        maxabs: *mut f64,
    );
    pub fn bl1_cmaxabsm(
        m: integer,
        n: integer,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
        maxabs: *mut f32,
    );
    pub fn bl1_zmaxabsm(
        m: integer,
        n: integer,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
        maxabs: *mut f64,
    );
    pub fn bl1_smaxabsmr(
        uplo: uplo1_t,
        m: integer,
        n: integer,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
        maxabs: *mut f32,
    );
    pub fn bl1_dmaxabsmr(
        uplo: uplo1_t,
        m: integer,
        n: integer,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
        maxabs: *mut f64,
    );
    pub fn bl1_cmaxabsmr(
        uplo: uplo1_t,
        m: integer,
        n: integer,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
        maxabs: *mut f32,
    );
    pub fn bl1_zmaxabsmr(
        uplo: uplo1_t,
        m: integer,
        n: integer,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
        maxabs: *mut f64,
    );
    pub fn bl1_srands(alpha: *mut f32);
    pub fn bl1_drands(alpha: *mut f64);
    pub fn bl1_crands(alpha: *mut scomplex);
    pub fn bl1_zrands(alpha: *mut dcomplex);
    pub fn bl1_srandv(n: integer, x: *mut f32, incx: integer);
    pub fn bl1_drandv(n: integer, x: *mut f64, incx: integer);
    pub fn bl1_crandv(n: integer, x: *mut scomplex, incx: integer);
    pub fn bl1_zrandv(n: integer, x: *mut dcomplex, incx: integer);
    pub fn bl1_srandm(m: integer, n: integer, a: *mut f32, a_rs: integer, a_cs: integer);
    pub fn bl1_drandm(m: integer, n: integer, a: *mut f64, a_rs: integer, a_cs: integer);
    pub fn bl1_crandm(m: integer, n: integer, a: *mut scomplex, a_rs: integer, a_cs: integer);
    pub fn bl1_zrandm(m: integer, n: integer, a: *mut dcomplex, a_rs: integer, a_cs: integer);
    pub fn bl1_srandmr(
        uplo: uplo1_t,
        diag: diag1_t,
        m: integer,
        n: integer,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_drandmr(
        uplo: uplo1_t,
        diag: diag1_t,
        m: integer,
        n: integer,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_crandmr(
        uplo: uplo1_t,
        diag: diag1_t,
        m: integer,
        n: integer,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_zrandmr(
        uplo: uplo1_t,
        diag: diag1_t,
        m: integer,
        n: integer,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_set_contig_strides(m: integer, n: integer, rs: *mut integer, cs: *mut integer);
    pub fn bl1_set_dim_with_side(side: side1_t, m: integer, n: integer, dim_new: *mut integer);
    pub fn bl1_set_dims_with_trans(
        trans: trans1_t,
        m: integer,
        n: integer,
        m_new: *mut integer,
        n_new: *mut integer,
    );
    pub fn bl1_isetv(m: integer, sigma: *mut integer, x: *mut integer, incx: integer);
    pub fn bl1_ssetv(m: integer, sigma: *mut f32, x: *mut f32, incx: integer);
    pub fn bl1_dsetv(m: integer, sigma: *mut f64, x: *mut f64, incx: integer);
    pub fn bl1_csetv(m: integer, sigma: *mut scomplex, x: *mut scomplex, incx: integer);
    pub fn bl1_zsetv(m: integer, sigma: *mut dcomplex, x: *mut dcomplex, incx: integer);
    pub fn bl1_isetm(
        m: integer,
        n: integer,
        sigma: *mut integer,
        a: *mut integer,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_ssetm(
        m: integer,
        n: integer,
        sigma: *mut f32,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_dsetm(
        m: integer,
        n: integer,
        sigma: *mut f64,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_csetm(
        m: integer,
        n: integer,
        sigma: *mut scomplex,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_zsetm(
        m: integer,
        n: integer,
        sigma: *mut dcomplex,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_ssetmr(
        uplo: uplo1_t,
        m: integer,
        n: integer,
        sigma: *mut f32,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_dsetmr(
        uplo: uplo1_t,
        m: integer,
        n: integer,
        sigma: *mut f64,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_csetmr(
        uplo: uplo1_t,
        m: integer,
        n: integer,
        sigma: *mut scomplex,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_zsetmr(
        uplo: uplo1_t,
        m: integer,
        n: integer,
        sigma: *mut dcomplex,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_isetdiag(
        offset: integer,
        m: integer,
        n: integer,
        sigma: *mut integer,
        a: *mut integer,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_ssetdiag(
        offset: integer,
        m: integer,
        n: integer,
        sigma: *mut f32,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_dsetdiag(
        offset: integer,
        m: integer,
        n: integer,
        sigma: *mut f64,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_csetdiag(
        offset: integer,
        m: integer,
        n: integer,
        sigma: *mut scomplex,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_zsetdiag(
        offset: integer,
        m: integer,
        n: integer,
        sigma: *mut dcomplex,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_sscalediag(
        conj: conj1_t,
        offset: integer,
        m: integer,
        n: integer,
        sigma: *mut f32,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_dscalediag(
        conj: conj1_t,
        offset: integer,
        m: integer,
        n: integer,
        sigma: *mut f64,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_cscalediag(
        conj: conj1_t,
        offset: integer,
        m: integer,
        n: integer,
        sigma: *mut scomplex,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_zscalediag(
        conj: conj1_t,
        offset: integer,
        m: integer,
        n: integer,
        sigma: *mut dcomplex,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_csscalediag(
        conj: conj1_t,
        offset: integer,
        m: integer,
        n: integer,
        sigma: *mut f32,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_zdscalediag(
        conj: conj1_t,
        offset: integer,
        m: integer,
        n: integer,
        sigma: *mut f64,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_sshiftdiag(
        conj: conj1_t,
        offset: integer,
        m: integer,
        n: integer,
        sigma: *mut f32,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_dshiftdiag(
        conj: conj1_t,
        offset: integer,
        m: integer,
        n: integer,
        sigma: *mut f64,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_cshiftdiag(
        conj: conj1_t,
        offset: integer,
        m: integer,
        n: integer,
        sigma: *mut scomplex,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_zshiftdiag(
        conj: conj1_t,
        offset: integer,
        m: integer,
        n: integer,
        sigma: *mut dcomplex,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_csshiftdiag(
        conj: conj1_t,
        offset: integer,
        m: integer,
        n: integer,
        sigma: *mut f32,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_zdshiftdiag(
        conj: conj1_t,
        offset: integer,
        m: integer,
        n: integer,
        sigma: *mut f64,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_ssymmize(
        conj: conj1_t,
        uplo: uplo1_t,
        m: integer,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_dsymmize(
        conj: conj1_t,
        uplo: uplo1_t,
        m: integer,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_csymmize(
        conj: conj1_t,
        uplo: uplo1_t,
        m: integer,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_zsymmize(
        conj: conj1_t,
        uplo: uplo1_t,
        m: integer,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_does_trans(trans: trans1_t) -> c_int;
    pub fn bl1_does_notrans(trans: trans1_t) -> c_int;
    pub fn bl1_does_conj(trans: trans1_t) -> c_int;
    pub fn bl1_is_notrans(trans: trans1_t) -> c_int;
    pub fn bl1_is_trans(trans: trans1_t) -> c_int;
    pub fn bl1_is_conjnotrans(trans: trans1_t) -> c_int;
    pub fn bl1_is_conjtrans(trans: trans1_t) -> c_int;
    pub fn bl1_is_noconj(conj: conj1_t) -> c_int;
    pub fn bl1_is_conj(conj: conj1_t) -> c_int;
    pub fn bl1_is_lower(uplo: uplo1_t) -> c_int;
    pub fn bl1_is_upper(uplo: uplo1_t) -> c_int;
    pub fn bl1_is_left(side: side1_t) -> c_int;
    pub fn bl1_is_right(side: side1_t) -> c_int;
    pub fn bl1_is_nonunit_diag(diag: diag1_t) -> c_int;
    pub fn bl1_is_unit_diag(diag: diag1_t) -> c_int;
    pub fn bl1_is_zero_diag(diag: diag1_t) -> c_int;
    pub fn bl1_proj_trans1_to_conj(trans: trans1_t) -> conj1_t;
    pub fn bl1_check_storage_3m(
        a_rs: integer,
        a_cs: integer,
        b_rs: integer,
        b_cs: integer,
        c_rs: integer,
        c_cs: integer,
    );
    pub fn bl1_check_storage_2m(a_rs: integer, a_cs: integer, b_rs: integer, b_cs: integer);
    pub fn bl1_is_row_or_col_storage(rs: integer, cs: integer) -> c_int;
    pub fn bl1_is_row_storage(rs: integer, cs: integer) -> c_int;
    pub fn bl1_is_col_storage(rs: integer, cs: integer) -> c_int;
    pub fn bl1_is_gen_storage(rs: integer, cs: integer) -> c_int;
    pub fn bl1_is_vector(m: integer, n: integer) -> c_int;
    pub fn bl1_vector_dim(m: integer, n: integer) -> c_int;
    pub fn bl1_vector_inc(
        trans: trans1_t,
        m: integer,
        n: integer,
        rs: integer,
        cs: integer,
    ) -> c_int;
    pub fn bl1_zero_dim1(m: integer) -> c_int;
    pub fn bl1_zero_dim2(m: integer, n: integer) -> c_int;
    pub fn bl1_zero_dim3(m: integer, k: integer, n: integer) -> c_int;
    pub fn bl1_abort();
    pub fn bl1_abort_msg(message: *mut c_char);
    pub fn bl1_param_map_to_netlib_trans(
        blis_trans: trans1_t,
        blas_trans: *mut c_void,
    );
    pub fn bl1_param_map_to_netlib_uplo(blis_uplo: uplo1_t, blas_uplo: *mut c_void);
    pub fn bl1_param_map_to_netlib_side(blis_side: side1_t, blas_side: *mut c_void);
    pub fn bl1_param_map_to_netlib_diag(blis_diag: diag1_t, blas_diag: *mut c_void);
    pub fn bl1_samax(n: integer, x: *mut f32, incx: integer, index: *mut integer);
    pub fn bl1_damax(n: integer, x: *mut f64, incx: integer, index: *mut integer);
    pub fn bl1_camax(n: integer, x: *mut scomplex, incx: integer, index: *mut integer);
    pub fn bl1_zamax(n: integer, x: *mut dcomplex, incx: integer, index: *mut integer);
    pub fn bl1_sasum(n: integer, x: *mut f32, incx: integer, norm: *mut f32);
    pub fn bl1_dasum(n: integer, x: *mut f64, incx: integer, norm: *mut f64);
    pub fn bl1_casum(n: integer, x: *mut scomplex, incx: integer, norm: *mut f32);
    pub fn bl1_zasum(n: integer, x: *mut dcomplex, incx: integer, norm: *mut f64);
    pub fn bl1_saxpy(
        n: integer,
        alpha: *mut f32,
        x: *mut f32,
        incx: integer,
        y: *mut f32,
        incy: integer,
    );
    pub fn bl1_daxpy(
        n: integer,
        alpha: *mut f64,
        x: *mut f64,
        incx: integer,
        y: *mut f64,
        incy: integer,
    );
    pub fn bl1_caxpy(
        n: integer,
        alpha: *mut scomplex,
        x: *mut scomplex,
        incx: integer,
        y: *mut scomplex,
        incy: integer,
    );
    pub fn bl1_zaxpy(
        n: integer,
        alpha: *mut dcomplex,
        x: *mut dcomplex,
        incx: integer,
        y: *mut dcomplex,
        incy: integer,
    );
    pub fn bl1_saxpyv(
        conj: conj1_t,
        n: integer,
        alpha: *mut f32,
        x: *mut f32,
        incx: integer,
        y: *mut f32,
        incy: integer,
    );
    pub fn bl1_daxpyv(
        conj: conj1_t,
        n: integer,
        alpha: *mut f64,
        x: *mut f64,
        incx: integer,
        y: *mut f64,
        incy: integer,
    );
    pub fn bl1_caxpyv(
        conj: conj1_t,
        n: integer,
        alpha: *mut scomplex,
        x: *mut scomplex,
        incx: integer,
        y: *mut scomplex,
        incy: integer,
    );
    pub fn bl1_zaxpyv(
        conj: conj1_t,
        n: integer,
        alpha: *mut dcomplex,
        x: *mut dcomplex,
        incx: integer,
        y: *mut dcomplex,
        incy: integer,
    );
    pub fn bl1_saxpymt(
        trans: trans1_t,
        m: integer,
        n: integer,
        alpha: *mut f32,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
        b: *mut f32,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_daxpymt(
        trans: trans1_t,
        m: integer,
        n: integer,
        alpha: *mut f64,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
        b: *mut f64,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_caxpymt(
        trans: trans1_t,
        m: integer,
        n: integer,
        alpha: *mut scomplex,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut scomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_zaxpymt(
        trans: trans1_t,
        m: integer,
        n: integer,
        alpha: *mut dcomplex,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut dcomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_saxpymrt(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        n: integer,
        alpha: *mut f32,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
        b: *mut f32,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_daxpymrt(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        n: integer,
        alpha: *mut f64,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
        b: *mut f64,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_caxpymrt(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        n: integer,
        alpha: *mut scomplex,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut scomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_zaxpymrt(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        n: integer,
        alpha: *mut dcomplex,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut dcomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_saxpysv(
        n: integer,
        alpha0: *mut f32,
        alpha1: *mut f32,
        x: *mut f32,
        incx: integer,
        beta: *mut f32,
        y: *mut f32,
        incy: integer,
    );
    pub fn bl1_daxpysv(
        n: integer,
        alpha0: *mut f64,
        alpha1: *mut f64,
        x: *mut f64,
        incx: integer,
        beta: *mut f64,
        y: *mut f64,
        incy: integer,
    );
    pub fn bl1_caxpysv(
        n: integer,
        alpha0: *mut scomplex,
        alpha1: *mut scomplex,
        x: *mut scomplex,
        incx: integer,
        beta: *mut scomplex,
        y: *mut scomplex,
        incy: integer,
    );
    pub fn bl1_zaxpysv(
        n: integer,
        alpha0: *mut dcomplex,
        alpha1: *mut dcomplex,
        x: *mut dcomplex,
        incx: integer,
        beta: *mut dcomplex,
        y: *mut dcomplex,
        incy: integer,
    );
    pub fn bl1_saxpysmt(
        trans: trans1_t,
        m: integer,
        n: integer,
        alpha0: *mut f32,
        alpha1: *mut f32,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
        beta: *mut f32,
        b: *mut f32,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_daxpysmt(
        trans: trans1_t,
        m: integer,
        n: integer,
        alpha0: *mut f64,
        alpha1: *mut f64,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
        beta: *mut f64,
        b: *mut f64,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_caxpysmt(
        trans: trans1_t,
        m: integer,
        n: integer,
        alpha0: *mut scomplex,
        alpha1: *mut scomplex,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
        beta: *mut scomplex,
        b: *mut scomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_zaxpysmt(
        trans: trans1_t,
        m: integer,
        n: integer,
        alpha0: *mut dcomplex,
        alpha1: *mut dcomplex,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
        beta: *mut dcomplex,
        b: *mut dcomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_sconjv(m: integer, x: *mut f32, incx: integer);
    pub fn bl1_dconjv(m: integer, x: *mut f64, incx: integer);
    pub fn bl1_cconjv(m: integer, x: *mut scomplex, incx: integer);
    pub fn bl1_zconjv(m: integer, x: *mut dcomplex, incx: integer);
    pub fn bl1_sconjm(m: integer, n: integer, a: *mut f32, a_rs: integer, a_cs: integer);
    pub fn bl1_dconjm(m: integer, n: integer, a: *mut f64, a_rs: integer, a_cs: integer);
    pub fn bl1_cconjm(m: integer, n: integer, a: *mut scomplex, a_rs: integer, a_cs: integer);
    pub fn bl1_zconjm(m: integer, n: integer, a: *mut dcomplex, a_rs: integer, a_cs: integer);
    pub fn bl1_sconjmr(
        uplo: uplo1_t,
        m: integer,
        n: integer,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_dconjmr(
        uplo: uplo1_t,
        m: integer,
        n: integer,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_cconjmr(
        uplo: uplo1_t,
        m: integer,
        n: integer,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_zconjmr(
        uplo: uplo1_t,
        m: integer,
        n: integer,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_scopy(m: integer, x: *mut f32, incx: integer, y: *mut f32, incy: integer);
    pub fn bl1_dcopy(m: integer, x: *mut f64, incx: integer, y: *mut f64, incy: integer);
    pub fn bl1_ccopy(m: integer, x: *mut scomplex, incx: integer, y: *mut scomplex, incy: integer);
    pub fn bl1_zcopy(m: integer, x: *mut dcomplex, incx: integer, y: *mut dcomplex, incy: integer);
    pub fn bl1_icopyv(
        conj: conj1_t,
        m: integer,
        x: *mut integer,
        incx: integer,
        y: *mut integer,
        incy: integer,
    );
    pub fn bl1_scopyv(
        conj: conj1_t,
        m: integer,
        x: *mut f32,
        incx: integer,
        y: *mut f32,
        incy: integer,
    );
    pub fn bl1_dcopyv(
        conj: conj1_t,
        m: integer,
        x: *mut f64,
        incx: integer,
        y: *mut f64,
        incy: integer,
    );
    pub fn bl1_ccopyv(
        conj: conj1_t,
        m: integer,
        x: *mut scomplex,
        incx: integer,
        y: *mut scomplex,
        incy: integer,
    );
    pub fn bl1_zcopyv(
        conj: conj1_t,
        m: integer,
        x: *mut dcomplex,
        incx: integer,
        y: *mut dcomplex,
        incy: integer,
    );
    pub fn bl1_sdcopyv(
        conj: conj1_t,
        m: integer,
        x: *mut f32,
        incx: integer,
        y: *mut f64,
        incy: integer,
    );
    pub fn bl1_dscopyv(
        conj: conj1_t,
        m: integer,
        x: *mut f64,
        incx: integer,
        y: *mut f32,
        incy: integer,
    );
    pub fn bl1_sccopyv(
        conj: conj1_t,
        m: integer,
        x: *mut f32,
        incx: integer,
        y: *mut scomplex,
        incy: integer,
    );
    pub fn bl1_cscopyv(
        conj: conj1_t,
        m: integer,
        x: *mut scomplex,
        incx: integer,
        y: *mut f32,
        incy: integer,
    );
    pub fn bl1_szcopyv(
        conj: conj1_t,
        m: integer,
        x: *mut f32,
        incx: integer,
        y: *mut dcomplex,
        incy: integer,
    );
    pub fn bl1_zscopyv(
        conj: conj1_t,
        m: integer,
        x: *mut dcomplex,
        incx: integer,
        y: *mut f32,
        incy: integer,
    );
    pub fn bl1_dccopyv(
        conj: conj1_t,
        m: integer,
        x: *mut f64,
        incx: integer,
        y: *mut scomplex,
        incy: integer,
    );
    pub fn bl1_cdcopyv(
        conj: conj1_t,
        m: integer,
        x: *mut scomplex,
        incx: integer,
        y: *mut f64,
        incy: integer,
    );
    pub fn bl1_dzcopyv(
        conj: conj1_t,
        m: integer,
        x: *mut f64,
        incx: integer,
        y: *mut dcomplex,
        incy: integer,
    );
    pub fn bl1_zdcopyv(
        conj: conj1_t,
        m: integer,
        x: *mut dcomplex,
        incx: integer,
        y: *mut f64,
        incy: integer,
    );
    pub fn bl1_czcopyv(
        conj: conj1_t,
        m: integer,
        x: *mut scomplex,
        incx: integer,
        y: *mut dcomplex,
        incy: integer,
    );
    pub fn bl1_zccopyv(
        conj: conj1_t,
        m: integer,
        x: *mut dcomplex,
        incx: integer,
        y: *mut scomplex,
        incy: integer,
    );
    pub fn bl1_scopymr(
        uplo: uplo1_t,
        m: integer,
        n: integer,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
        b: *mut f32,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_dcopymr(
        uplo: uplo1_t,
        m: integer,
        n: integer,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
        b: *mut f64,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_ccopymr(
        uplo: uplo1_t,
        m: integer,
        n: integer,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut scomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_zcopymr(
        uplo: uplo1_t,
        m: integer,
        n: integer,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut dcomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_sscopymr(
        uplo: uplo1_t,
        m: integer,
        n: integer,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
        b: *mut f32,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_sdcopymr(
        uplo: uplo1_t,
        m: integer,
        n: integer,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
        b: *mut f64,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_dscopymr(
        uplo: uplo1_t,
        m: integer,
        n: integer,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
        b: *mut f32,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_sccopymr(
        uplo: uplo1_t,
        m: integer,
        n: integer,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
        b: *mut scomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_cscopymr(
        uplo: uplo1_t,
        m: integer,
        n: integer,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut f32,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_szcopymr(
        uplo: uplo1_t,
        m: integer,
        n: integer,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
        b: *mut dcomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_zscopymr(
        uplo: uplo1_t,
        m: integer,
        n: integer,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut f32,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_ddcopymr(
        uplo: uplo1_t,
        m: integer,
        n: integer,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
        b: *mut f64,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_dccopymr(
        uplo: uplo1_t,
        m: integer,
        n: integer,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
        b: *mut scomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_cdcopymr(
        uplo: uplo1_t,
        m: integer,
        n: integer,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut f64,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_dzcopymr(
        uplo: uplo1_t,
        m: integer,
        n: integer,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
        b: *mut dcomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_zdcopymr(
        uplo: uplo1_t,
        m: integer,
        n: integer,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut f64,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_cccopymr(
        uplo: uplo1_t,
        m: integer,
        n: integer,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut scomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_czcopymr(
        uplo: uplo1_t,
        m: integer,
        n: integer,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut dcomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_zccopymr(
        uplo: uplo1_t,
        m: integer,
        n: integer,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut scomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_zzcopymr(
        uplo: uplo1_t,
        m: integer,
        n: integer,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut dcomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_scopymrt(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
        b: *mut f32,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_dcopymrt(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
        b: *mut f64,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_ccopymrt(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut scomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_zcopymrt(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut dcomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_sscopymrt(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
        b: *mut f32,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_sdcopymrt(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
        b: *mut f64,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_sccopymrt(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
        b: *mut scomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_szcopymrt(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
        b: *mut dcomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_dscopymrt(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
        b: *mut f32,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_ddcopymrt(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
        b: *mut f64,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_dccopymrt(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
        b: *mut scomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_dzcopymrt(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
        b: *mut dcomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_cscopymrt(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut f32,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_cdcopymrt(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut f64,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_cccopymrt(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut scomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_czcopymrt(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut dcomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_zscopymrt(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut f32,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_zdcopymrt(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut f64,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_zccopymrt(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut scomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_zzcopymrt(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut dcomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_icopymt(
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut integer,
        a_rs: integer,
        a_cs: integer,
        b: *mut integer,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_scopymt(
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
        b: *mut f32,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_dcopymt(
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
        b: *mut f64,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_ccopymt(
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut scomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_zcopymt(
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut dcomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_sscopymt(
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
        b: *mut f32,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_sdcopymt(
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
        b: *mut f64,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_dscopymt(
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
        b: *mut f32,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_sccopymt(
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
        b: *mut scomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_cscopymt(
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut f32,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_szcopymt(
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
        b: *mut dcomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_zscopymt(
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut f32,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_ddcopymt(
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
        b: *mut f64,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_dccopymt(
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
        b: *mut scomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_cdcopymt(
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut f64,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_dzcopymt(
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
        b: *mut dcomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_zdcopymt(
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut f64,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_cccopymt(
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut scomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_czcopymt(
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut dcomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_zccopymt(
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut scomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_zzcopymt(
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut dcomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_cdot_in(
        conj: conj1_t,
        n: integer,
        x: *mut scomplex,
        incx: integer,
        y: *mut scomplex,
        incy: integer,
        rho: *mut scomplex,
    );
    pub fn bl1_zdot_in(
        conj: conj1_t,
        n: integer,
        x: *mut dcomplex,
        incx: integer,
        y: *mut dcomplex,
        incy: integer,
        rho: *mut dcomplex,
    );
    pub fn bl1_sdot(
        conj: conj1_t,
        n: integer,
        x: *mut f32,
        incx: integer,
        y: *mut f32,
        incy: integer,
        rho: *mut f32,
    );
    pub fn bl1_ddot(
        conj: conj1_t,
        n: integer,
        x: *mut f64,
        incx: integer,
        y: *mut f64,
        incy: integer,
        rho: *mut f64,
    );
    pub fn bl1_cdot(
        conj: conj1_t,
        n: integer,
        x: *mut scomplex,
        incx: integer,
        y: *mut scomplex,
        incy: integer,
        rho: *mut scomplex,
    );
    pub fn bl1_zdot(
        conj: conj1_t,
        n: integer,
        x: *mut dcomplex,
        incx: integer,
        y: *mut dcomplex,
        incy: integer,
        rho: *mut dcomplex,
    );
    pub fn bl1_sdots(
        conj: conj1_t,
        n: integer,
        alpha: *mut f32,
        x: *mut f32,
        incx: integer,
        y: *mut f32,
        incy: integer,
        beta: *mut f32,
        rho: *mut f32,
    );
    pub fn bl1_ddots(
        conj: conj1_t,
        n: integer,
        alpha: *mut f64,
        x: *mut f64,
        incx: integer,
        y: *mut f64,
        incy: integer,
        beta: *mut f64,
        rho: *mut f64,
    );
    pub fn bl1_cdots(
        conj: conj1_t,
        n: integer,
        alpha: *mut scomplex,
        x: *mut scomplex,
        incx: integer,
        y: *mut scomplex,
        incy: integer,
        beta: *mut scomplex,
        rho: *mut scomplex,
    );
    pub fn bl1_zdots(
        conj: conj1_t,
        n: integer,
        alpha: *mut dcomplex,
        x: *mut dcomplex,
        incx: integer,
        y: *mut dcomplex,
        incy: integer,
        beta: *mut dcomplex,
        rho: *mut dcomplex,
    );
    pub fn bl1_sdot2s(
        conj: conj1_t,
        n: integer,
        alpha: *mut f32,
        x: *mut f32,
        incx: integer,
        y: *mut f32,
        incy: integer,
        beta: *mut f32,
        rho: *mut f32,
    );
    pub fn bl1_ddot2s(
        conj: conj1_t,
        n: integer,
        alpha: *mut f64,
        x: *mut f64,
        incx: integer,
        y: *mut f64,
        incy: integer,
        beta: *mut f64,
        rho: *mut f64,
    );
    pub fn bl1_cdot2s(
        conj: conj1_t,
        n: integer,
        alpha: *mut scomplex,
        x: *mut scomplex,
        incx: integer,
        y: *mut scomplex,
        incy: integer,
        beta: *mut scomplex,
        rho: *mut scomplex,
    );
    pub fn bl1_zdot2s(
        conj: conj1_t,
        n: integer,
        alpha: *mut dcomplex,
        x: *mut dcomplex,
        incx: integer,
        y: *mut dcomplex,
        incy: integer,
        beta: *mut dcomplex,
        rho: *mut dcomplex,
    );
    pub fn bl1_sfnorm(
        m: integer,
        n: integer,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
        norm: *mut f32,
    );
    pub fn bl1_dfnorm(
        m: integer,
        n: integer,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
        norm: *mut f64,
    );
    pub fn bl1_cfnorm(
        m: integer,
        n: integer,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
        norm: *mut f32,
    );
    pub fn bl1_zfnorm(
        m: integer,
        n: integer,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
        norm: *mut f64,
    );
    pub fn bl1_sinvscalv(conj: conj1_t, n: integer, alpha: *mut f32, x: *mut f32, incx: integer);
    pub fn bl1_dinvscalv(conj: conj1_t, n: integer, alpha: *mut f64, x: *mut f64, incx: integer);
    pub fn bl1_csinvscalv(
        conj: conj1_t,
        n: integer,
        alpha: *mut f32,
        x: *mut scomplex,
        incx: integer,
    );
    pub fn bl1_cinvscalv(
        conj: conj1_t,
        n: integer,
        alpha: *mut scomplex,
        x: *mut scomplex,
        incx: integer,
    );
    pub fn bl1_zdinvscalv(
        conj: conj1_t,
        n: integer,
        alpha: *mut f64,
        x: *mut dcomplex,
        incx: integer,
    );
    pub fn bl1_zinvscalv(
        conj: conj1_t,
        n: integer,
        alpha: *mut dcomplex,
        x: *mut dcomplex,
        incx: integer,
    );
    pub fn bl1_sinvscalm(
        conj: conj1_t,
        m: integer,
        n: integer,
        alpha: *mut f32,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_dinvscalm(
        conj: conj1_t,
        m: integer,
        n: integer,
        alpha: *mut f64,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_csinvscalm(
        conj: conj1_t,
        m: integer,
        n: integer,
        alpha: *mut f32,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_cinvscalm(
        conj: conj1_t,
        m: integer,
        n: integer,
        alpha: *mut scomplex,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_zdinvscalm(
        conj: conj1_t,
        m: integer,
        n: integer,
        alpha: *mut f64,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_zinvscalm(
        conj: conj1_t,
        m: integer,
        n: integer,
        alpha: *mut dcomplex,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_snrm2(n: integer, x: *mut f32, incx: integer, norm: *mut f32);
    pub fn bl1_dnrm2(n: integer, x: *mut f64, incx: integer, norm: *mut f64);
    pub fn bl1_cnrm2(n: integer, x: *mut scomplex, incx: integer, norm: *mut f32);
    pub fn bl1_znrm2(n: integer, x: *mut dcomplex, incx: integer, norm: *mut f64);
    pub fn bl1_sscal(n: integer, alpha: *mut f32, x: *mut f32, incx: integer);
    pub fn bl1_dscal(n: integer, alpha: *mut f64, x: *mut f64, incx: integer);
    pub fn bl1_csscal(n: integer, alpha: *mut f32, x: *mut scomplex, incx: integer);
    pub fn bl1_cscal(n: integer, alpha: *mut scomplex, x: *mut scomplex, incx: integer);
    pub fn bl1_zdscal(n: integer, alpha: *mut f64, x: *mut dcomplex, incx: integer);
    pub fn bl1_zscal(n: integer, alpha: *mut dcomplex, x: *mut dcomplex, incx: integer);
    pub fn bl1_sscalv(conj: conj1_t, n: integer, alpha: *mut f32, x: *mut f32, incx: integer);
    pub fn bl1_dscalv(conj: conj1_t, n: integer, alpha: *mut f64, x: *mut f64, incx: integer);
    pub fn bl1_csscalv(conj: conj1_t, n: integer, alpha: *mut f32, x: *mut scomplex, incx: integer);
    pub fn bl1_cscalv(
        conj: conj1_t,
        n: integer,
        alpha: *mut scomplex,
        x: *mut scomplex,
        incx: integer,
    );
    pub fn bl1_zdscalv(conj: conj1_t, n: integer, alpha: *mut f64, x: *mut dcomplex, incx: integer);
    pub fn bl1_zscalv(
        conj: conj1_t,
        n: integer,
        alpha: *mut dcomplex,
        x: *mut dcomplex,
        incx: integer,
    );
    pub fn bl1_sscalm(
        conj: conj1_t,
        m: integer,
        n: integer,
        alpha: *mut f32,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_dscalm(
        conj: conj1_t,
        m: integer,
        n: integer,
        alpha: *mut f64,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_csscalm(
        conj: conj1_t,
        m: integer,
        n: integer,
        alpha: *mut f32,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_cscalm(
        conj: conj1_t,
        m: integer,
        n: integer,
        alpha: *mut scomplex,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_zdscalm(
        conj: conj1_t,
        m: integer,
        n: integer,
        alpha: *mut f64,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_zscalm(
        conj: conj1_t,
        m: integer,
        n: integer,
        alpha: *mut dcomplex,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_sscalmr(
        uplo: uplo1_t,
        m: integer,
        n: integer,
        alpha: *mut f32,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_dscalmr(
        uplo: uplo1_t,
        m: integer,
        n: integer,
        alpha: *mut f64,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_csscalmr(
        uplo: uplo1_t,
        m: integer,
        n: integer,
        alpha: *mut f32,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_cscalmr(
        uplo: uplo1_t,
        m: integer,
        n: integer,
        alpha: *mut scomplex,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_zdscalmr(
        uplo: uplo1_t,
        m: integer,
        n: integer,
        alpha: *mut f64,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_zscalmr(
        uplo: uplo1_t,
        m: integer,
        n: integer,
        alpha: *mut dcomplex,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_sswap(n: integer, x: *mut f32, incx: integer, y: *mut f32, incy: integer);
    pub fn bl1_dswap(n: integer, x: *mut f64, incx: integer, y: *mut f64, incy: integer);
    pub fn bl1_cswap(n: integer, x: *mut scomplex, incx: integer, y: *mut scomplex, incy: integer);
    pub fn bl1_zswap(n: integer, x: *mut dcomplex, incx: integer, y: *mut dcomplex, incy: integer);
    pub fn bl1_sswapv(n: integer, x: *mut f32, incx: integer, y: *mut f32, incy: integer);
    pub fn bl1_dswapv(n: integer, x: *mut f64, incx: integer, y: *mut f64, incy: integer);
    pub fn bl1_cswapv(n: integer, x: *mut scomplex, incx: integer, y: *mut scomplex, incy: integer);
    pub fn bl1_zswapv(n: integer, x: *mut dcomplex, incx: integer, y: *mut dcomplex, incy: integer);
    pub fn bl1_sswapmt(
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
        b: *mut f32,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_dswapmt(
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
        b: *mut f64,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_cswapmt(
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut scomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_zswapmt(
        trans: trans1_t,
        m: integer,
        n: integer,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut dcomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_sgemv(
        transa: trans1_t,
        conjx: conj1_t,
        m: integer,
        n: integer,
        alpha: *mut f32,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
        x: *mut f32,
        incx: integer,
        beta: *mut f32,
        y: *mut f32,
        incy: integer,
    );
    pub fn bl1_dgemv(
        transa: trans1_t,
        conjx: conj1_t,
        m: integer,
        n: integer,
        alpha: *mut f64,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
        x: *mut f64,
        incx: integer,
        beta: *mut f64,
        y: *mut f64,
        incy: integer,
    );
    pub fn bl1_cgemv(
        transa: trans1_t,
        conjx: conj1_t,
        m: integer,
        n: integer,
        alpha: *mut scomplex,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
        x: *mut scomplex,
        incx: integer,
        beta: *mut scomplex,
        y: *mut scomplex,
        incy: integer,
    );
    pub fn bl1_zgemv(
        transa: trans1_t,
        conjx: conj1_t,
        m: integer,
        n: integer,
        alpha: *mut dcomplex,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
        x: *mut dcomplex,
        incx: integer,
        beta: *mut dcomplex,
        y: *mut dcomplex,
        incy: integer,
    );
    pub fn bl1_sgemv_blas(
        transa: trans1_t,
        m: integer,
        n: integer,
        alpha: *mut f32,
        a: *mut f32,
        lda: integer,
        x: *mut f32,
        incx: integer,
        beta: *mut f32,
        y: *mut f32,
        incy: integer,
    );
    pub fn bl1_dgemv_blas(
        transa: trans1_t,
        m: integer,
        n: integer,
        alpha: *mut f64,
        a: *mut f64,
        lda: integer,
        x: *mut f64,
        incx: integer,
        beta: *mut f64,
        y: *mut f64,
        incy: integer,
    );
    pub fn bl1_cgemv_blas(
        transa: trans1_t,
        m: integer,
        n: integer,
        alpha: *mut scomplex,
        a: *mut scomplex,
        lda: integer,
        x: *mut scomplex,
        incx: integer,
        beta: *mut scomplex,
        y: *mut scomplex,
        incy: integer,
    );
    pub fn bl1_zgemv_blas(
        transa: trans1_t,
        m: integer,
        n: integer,
        alpha: *mut dcomplex,
        a: *mut dcomplex,
        lda: integer,
        x: *mut dcomplex,
        incx: integer,
        beta: *mut dcomplex,
        y: *mut dcomplex,
        incy: integer,
    );
    pub fn bl1_sger(
        conjx: conj1_t,
        conjy: conj1_t,
        m: integer,
        n: integer,
        alpha: *mut f32,
        x: *mut f32,
        incx: integer,
        y: *mut f32,
        incy: integer,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_dger(
        conjx: conj1_t,
        conjy: conj1_t,
        m: integer,
        n: integer,
        alpha: *mut f64,
        x: *mut f64,
        incx: integer,
        y: *mut f64,
        incy: integer,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_cger(
        conjx: conj1_t,
        conjy: conj1_t,
        m: integer,
        n: integer,
        alpha: *mut scomplex,
        x: *mut scomplex,
        incx: integer,
        y: *mut scomplex,
        incy: integer,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_zger(
        conjx: conj1_t,
        conjy: conj1_t,
        m: integer,
        n: integer,
        alpha: *mut dcomplex,
        x: *mut dcomplex,
        incx: integer,
        y: *mut dcomplex,
        incy: integer,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_sger_blas(
        m: integer,
        n: integer,
        alpha: *mut f32,
        x: *mut f32,
        incx: integer,
        y: *mut f32,
        incy: integer,
        a: *mut f32,
        lda: integer,
    );
    pub fn bl1_dger_blas(
        m: integer,
        n: integer,
        alpha: *mut f64,
        x: *mut f64,
        incx: integer,
        y: *mut f64,
        incy: integer,
        a: *mut f64,
        lda: integer,
    );
    pub fn bl1_cgerc_blas(
        m: integer,
        n: integer,
        alpha: *mut scomplex,
        x: *mut scomplex,
        incx: integer,
        y: *mut scomplex,
        incy: integer,
        a: *mut scomplex,
        lda: integer,
    );
    pub fn bl1_cgeru_blas(
        m: integer,
        n: integer,
        alpha: *mut scomplex,
        x: *mut scomplex,
        incx: integer,
        y: *mut scomplex,
        incy: integer,
        a: *mut scomplex,
        lda: integer,
    );
    pub fn bl1_zgerc_blas(
        m: integer,
        n: integer,
        alpha: *mut dcomplex,
        x: *mut dcomplex,
        incx: integer,
        y: *mut dcomplex,
        incy: integer,
        a: *mut dcomplex,
        lda: integer,
    );
    pub fn bl1_zgeru_blas(
        m: integer,
        n: integer,
        alpha: *mut dcomplex,
        x: *mut dcomplex,
        incx: integer,
        y: *mut dcomplex,
        incy: integer,
        a: *mut dcomplex,
        lda: integer,
    );
    pub fn bl1_shemv(
        uplo: uplo1_t,
        conj: conj1_t,
        m: integer,
        alpha: *mut f32,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
        x: *mut f32,
        incx: integer,
        beta: *mut f32,
        y: *mut f32,
        incy: integer,
    );
    pub fn bl1_dhemv(
        uplo: uplo1_t,
        conj: conj1_t,
        m: integer,
        alpha: *mut f64,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
        x: *mut f64,
        incx: integer,
        beta: *mut f64,
        y: *mut f64,
        incy: integer,
    );
    pub fn bl1_chemv(
        uplo: uplo1_t,
        conj: conj1_t,
        m: integer,
        alpha: *mut scomplex,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
        x: *mut scomplex,
        incx: integer,
        beta: *mut scomplex,
        y: *mut scomplex,
        incy: integer,
    );
    pub fn bl1_zhemv(
        uplo: uplo1_t,
        conj: conj1_t,
        m: integer,
        alpha: *mut dcomplex,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
        x: *mut dcomplex,
        incx: integer,
        beta: *mut dcomplex,
        y: *mut dcomplex,
        incy: integer,
    );
    pub fn bl1_chemv_blas(
        uplo: uplo1_t,
        m: integer,
        alpha: *mut scomplex,
        a: *mut scomplex,
        lda: integer,
        x: *mut scomplex,
        incx: integer,
        beta: *mut scomplex,
        y: *mut scomplex,
        incy: integer,
    );
    pub fn bl1_zhemv_blas(
        uplo: uplo1_t,
        m: integer,
        alpha: *mut dcomplex,
        a: *mut dcomplex,
        lda: integer,
        x: *mut dcomplex,
        incx: integer,
        beta: *mut dcomplex,
        y: *mut dcomplex,
        incy: integer,
    );
    pub fn bl1_sher(
        uplo: uplo1_t,
        conj: conj1_t,
        m: integer,
        alpha: *mut f32,
        x: *mut f32,
        incx: integer,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_dher(
        uplo: uplo1_t,
        conj: conj1_t,
        m: integer,
        alpha: *mut f64,
        x: *mut f64,
        incx: integer,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_cher(
        uplo: uplo1_t,
        conj: conj1_t,
        m: integer,
        alpha: *mut f32,
        x: *mut scomplex,
        incx: integer,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_zher(
        uplo: uplo1_t,
        conj: conj1_t,
        m: integer,
        alpha: *mut f64,
        x: *mut dcomplex,
        incx: integer,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_cher_blas(
        uplo: uplo1_t,
        m: integer,
        alpha: *mut f32,
        x: *mut scomplex,
        incx: integer,
        a: *mut scomplex,
        lda: integer,
    );
    pub fn bl1_zher_blas(
        uplo: uplo1_t,
        m: integer,
        alpha: *mut f64,
        x: *mut dcomplex,
        incx: integer,
        a: *mut dcomplex,
        lda: integer,
    );
    pub fn bl1_sher2(
        uplo: uplo1_t,
        conj: conj1_t,
        m: integer,
        alpha: *mut f32,
        x: *mut f32,
        incx: integer,
        y: *mut f32,
        incy: integer,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_dher2(
        uplo: uplo1_t,
        conj: conj1_t,
        m: integer,
        alpha: *mut f64,
        x: *mut f64,
        incx: integer,
        y: *mut f64,
        incy: integer,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_cher2(
        uplo: uplo1_t,
        conj: conj1_t,
        m: integer,
        alpha: *mut scomplex,
        x: *mut scomplex,
        incx: integer,
        y: *mut scomplex,
        incy: integer,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_zher2(
        uplo: uplo1_t,
        conj: conj1_t,
        m: integer,
        alpha: *mut dcomplex,
        x: *mut dcomplex,
        incx: integer,
        y: *mut dcomplex,
        incy: integer,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_cher2_blas(
        uplo: uplo1_t,
        m: integer,
        alpha: *mut scomplex,
        x: *mut scomplex,
        incx: integer,
        y: *mut scomplex,
        incy: integer,
        a: *mut scomplex,
        lda: integer,
    );
    pub fn bl1_zher2_blas(
        uplo: uplo1_t,
        m: integer,
        alpha: *mut dcomplex,
        x: *mut dcomplex,
        incx: integer,
        y: *mut dcomplex,
        incy: integer,
        a: *mut dcomplex,
        lda: integer,
    );
    pub fn bl1_ssymv(
        uplo: uplo1_t,
        m: integer,
        alpha: *mut f32,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
        x: *mut f32,
        incx: integer,
        beta: *mut f32,
        y: *mut f32,
        incy: integer,
    );
    pub fn bl1_dsymv(
        uplo: uplo1_t,
        m: integer,
        alpha: *mut f64,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
        x: *mut f64,
        incx: integer,
        beta: *mut f64,
        y: *mut f64,
        incy: integer,
    );
    pub fn bl1_csymv(
        uplo: uplo1_t,
        m: integer,
        alpha: *mut scomplex,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
        x: *mut scomplex,
        incx: integer,
        beta: *mut scomplex,
        y: *mut scomplex,
        incy: integer,
    );
    pub fn bl1_zsymv(
        uplo: uplo1_t,
        m: integer,
        alpha: *mut dcomplex,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
        x: *mut dcomplex,
        incx: integer,
        beta: *mut dcomplex,
        y: *mut dcomplex,
        incy: integer,
    );
    pub fn bl1_ssymv_blas(
        uplo: uplo1_t,
        m: integer,
        alpha: *mut f32,
        a: *mut f32,
        lda: integer,
        x: *mut f32,
        incx: integer,
        beta: *mut f32,
        y: *mut f32,
        incy: integer,
    );
    pub fn bl1_dsymv_blas(
        uplo: uplo1_t,
        m: integer,
        alpha: *mut f64,
        a: *mut f64,
        lda: integer,
        x: *mut f64,
        incx: integer,
        beta: *mut f64,
        y: *mut f64,
        incy: integer,
    );
    pub fn bl1_csymv_blas(
        uplo: uplo1_t,
        m: integer,
        alpha: *mut scomplex,
        a: *mut scomplex,
        lda: integer,
        x: *mut scomplex,
        incx: integer,
        beta: *mut scomplex,
        y: *mut scomplex,
        incy: integer,
    );
    pub fn bl1_zsymv_blas(
        uplo: uplo1_t,
        m: integer,
        alpha: *mut dcomplex,
        a: *mut dcomplex,
        lda: integer,
        x: *mut dcomplex,
        incx: integer,
        beta: *mut dcomplex,
        y: *mut dcomplex,
        incy: integer,
    );
    pub fn bl1_ssyr(
        uplo: uplo1_t,
        m: integer,
        alpha: *mut f32,
        x: *mut f32,
        incx: integer,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_dsyr(
        uplo: uplo1_t,
        m: integer,
        alpha: *mut f64,
        x: *mut f64,
        incx: integer,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_csyr(
        uplo: uplo1_t,
        m: integer,
        alpha: *mut scomplex,
        x: *mut scomplex,
        incx: integer,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_zsyr(
        uplo: uplo1_t,
        m: integer,
        alpha: *mut dcomplex,
        x: *mut dcomplex,
        incx: integer,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_ssyr_blas(
        uplo: uplo1_t,
        m: integer,
        alpha: *mut f32,
        x: *mut f32,
        incx: integer,
        a: *mut f32,
        lda: integer,
    );
    pub fn bl1_dsyr_blas(
        uplo: uplo1_t,
        m: integer,
        alpha: *mut f64,
        x: *mut f64,
        incx: integer,
        a: *mut f64,
        lda: integer,
    );
    pub fn bl1_csyr_blas(
        uplo: uplo1_t,
        m: integer,
        alpha: *mut scomplex,
        x: *mut scomplex,
        incx: integer,
        a: *mut scomplex,
        lda: integer,
    );
    pub fn bl1_zsyr_blas(
        uplo: uplo1_t,
        m: integer,
        alpha: *mut dcomplex,
        x: *mut dcomplex,
        incx: integer,
        a: *mut dcomplex,
        lda: integer,
    );
    pub fn bl1_ssyr2(
        uplo: uplo1_t,
        m: integer,
        alpha: *mut f32,
        x: *mut f32,
        incx: integer,
        y: *mut f32,
        incy: integer,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_dsyr2(
        uplo: uplo1_t,
        m: integer,
        alpha: *mut f64,
        x: *mut f64,
        incx: integer,
        y: *mut f64,
        incy: integer,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_csyr2(
        uplo: uplo1_t,
        m: integer,
        alpha: *mut scomplex,
        x: *mut scomplex,
        incx: integer,
        y: *mut scomplex,
        incy: integer,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_zsyr2(
        uplo: uplo1_t,
        m: integer,
        alpha: *mut dcomplex,
        x: *mut dcomplex,
        incx: integer,
        y: *mut dcomplex,
        incy: integer,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
    );
    pub fn bl1_ssyr2_blas(
        uplo: uplo1_t,
        m: integer,
        alpha: *mut f32,
        x: *mut f32,
        incx: integer,
        y: *mut f32,
        incy: integer,
        a: *mut f32,
        lda: integer,
    );
    pub fn bl1_dsyr2_blas(
        uplo: uplo1_t,
        m: integer,
        alpha: *mut f64,
        x: *mut f64,
        incx: integer,
        y: *mut f64,
        incy: integer,
        a: *mut f64,
        lda: integer,
    );
    pub fn bl1_csyr2_blas(
        uplo: uplo1_t,
        m: integer,
        alpha: *mut scomplex,
        x: *mut scomplex,
        incx: integer,
        y: *mut scomplex,
        incy: integer,
        a: *mut scomplex,
        lda: integer,
    );
    pub fn bl1_zsyr2_blas(
        uplo: uplo1_t,
        m: integer,
        alpha: *mut dcomplex,
        x: *mut dcomplex,
        incx: integer,
        y: *mut dcomplex,
        incy: integer,
        a: *mut dcomplex,
        lda: integer,
    );
    pub fn bl1_strmv(
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
        x: *mut f32,
        incx: integer,
    );
    pub fn bl1_dtrmv(
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
        x: *mut f64,
        incx: integer,
    );
    pub fn bl1_ctrmv(
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
        x: *mut scomplex,
        incx: integer,
    );
    pub fn bl1_ztrmv(
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
        x: *mut dcomplex,
        incx: integer,
    );
    pub fn bl1_strmv_blas(
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        a: *mut f32,
        lda: integer,
        x: *mut f32,
        incx: integer,
    );
    pub fn bl1_dtrmv_blas(
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        a: *mut f64,
        lda: integer,
        x: *mut f64,
        incx: integer,
    );
    pub fn bl1_ctrmv_blas(
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        a: *mut scomplex,
        lda: integer,
        x: *mut scomplex,
        incx: integer,
    );
    pub fn bl1_ztrmv_blas(
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        a: *mut dcomplex,
        lda: integer,
        x: *mut dcomplex,
        incx: integer,
    );
    pub fn bl1_strsv(
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
        x: *mut f32,
        incx: integer,
    );
    pub fn bl1_dtrsv(
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
        x: *mut f64,
        incx: integer,
    );
    pub fn bl1_ctrsv(
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
        x: *mut scomplex,
        incx: integer,
    );
    pub fn bl1_ztrsv(
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
        x: *mut dcomplex,
        incx: integer,
    );
    pub fn bl1_strsv_blas(
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        a: *mut f32,
        lda: integer,
        x: *mut f32,
        incx: integer,
    );
    pub fn bl1_dtrsv_blas(
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        a: *mut f64,
        lda: integer,
        x: *mut f64,
        incx: integer,
    );
    pub fn bl1_ctrsv_blas(
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        a: *mut scomplex,
        lda: integer,
        x: *mut scomplex,
        incx: integer,
    );
    pub fn bl1_ztrsv_blas(
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        a: *mut dcomplex,
        lda: integer,
        x: *mut dcomplex,
        incx: integer,
    );
    pub fn bl1_strmvsx(
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        alpha: *mut f32,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
        x: *mut f32,
        incx: integer,
        beta: *mut f32,
        y: *mut f32,
        incy: integer,
    );
    pub fn bl1_dtrmvsx(
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        alpha: *mut f64,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
        x: *mut f64,
        incx: integer,
        beta: *mut f64,
        y: *mut f64,
        incy: integer,
    );
    pub fn bl1_ctrmvsx(
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        alpha: *mut scomplex,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
        x: *mut scomplex,
        incx: integer,
        beta: *mut scomplex,
        y: *mut scomplex,
        incy: integer,
    );
    pub fn bl1_ztrmvsx(
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        alpha: *mut dcomplex,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
        x: *mut dcomplex,
        incx: integer,
        beta: *mut dcomplex,
        y: *mut dcomplex,
        incy: integer,
    );
    pub fn bl1_strsvsx(
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        alpha: *mut f32,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
        x: *mut f32,
        incx: integer,
        beta: *mut f32,
        y: *mut f32,
        incy: integer,
    );
    pub fn bl1_dtrsvsx(
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        alpha: *mut f64,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
        x: *mut f64,
        incx: integer,
        beta: *mut f64,
        y: *mut f64,
        incy: integer,
    );
    pub fn bl1_ctrsvsx(
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        alpha: *mut scomplex,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
        x: *mut scomplex,
        incx: integer,
        beta: *mut scomplex,
        y: *mut scomplex,
        incy: integer,
    );
    pub fn bl1_ztrsvsx(
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        alpha: *mut dcomplex,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
        x: *mut dcomplex,
        incx: integer,
        beta: *mut dcomplex,
        y: *mut dcomplex,
        incy: integer,
    );
    pub fn bl1_sgemm(
        transa: trans1_t,
        transb: trans1_t,
        m: integer,
        k: integer,
        n: integer,
        alpha: *mut f32,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
        b: *mut f32,
        b_rs: integer,
        b_cs: integer,
        beta: *mut f32,
        c: *mut f32,
        c_rs: integer,
        c_cs: integer,
    );
    pub fn bl1_dgemm(
        transa: trans1_t,
        transb: trans1_t,
        m: integer,
        k: integer,
        n: integer,
        alpha: *mut f64,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
        b: *mut f64,
        b_rs: integer,
        b_cs: integer,
        beta: *mut f64,
        c: *mut f64,
        c_rs: integer,
        c_cs: integer,
    );
    pub fn bl1_cgemm(
        transa: trans1_t,
        transb: trans1_t,
        m: integer,
        k: integer,
        n: integer,
        alpha: *mut scomplex,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut scomplex,
        b_rs: integer,
        b_cs: integer,
        beta: *mut scomplex,
        c: *mut scomplex,
        c_rs: integer,
        c_cs: integer,
    );
    pub fn bl1_zgemm(
        transa: trans1_t,
        transb: trans1_t,
        m: integer,
        k: integer,
        n: integer,
        alpha: *mut dcomplex,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut dcomplex,
        b_rs: integer,
        b_cs: integer,
        beta: *mut dcomplex,
        c: *mut dcomplex,
        c_rs: integer,
        c_cs: integer,
    );
    pub fn bl1_sgemm_blas(
        transa: trans1_t,
        transb: trans1_t,
        m: integer,
        n: integer,
        k: integer,
        alpha: *mut f32,
        a: *mut f32,
        lda: integer,
        b: *mut f32,
        ldb: integer,
        beta: *mut f32,
        c: *mut f32,
        ldc: integer,
    );
    pub fn bl1_dgemm_blas(
        transa: trans1_t,
        transb: trans1_t,
        m: integer,
        n: integer,
        k: integer,
        alpha: *mut f64,
        a: *mut f64,
        lda: integer,
        b: *mut f64,
        ldb: integer,
        beta: *mut f64,
        c: *mut f64,
        ldc: integer,
    );
    pub fn bl1_cgemm_blas(
        transa: trans1_t,
        transb: trans1_t,
        m: integer,
        n: integer,
        k: integer,
        alpha: *mut scomplex,
        a: *mut scomplex,
        lda: integer,
        b: *mut scomplex,
        ldb: integer,
        beta: *mut scomplex,
        c: *mut scomplex,
        ldc: integer,
    );
    pub fn bl1_zgemm_blas(
        transa: trans1_t,
        transb: trans1_t,
        m: integer,
        n: integer,
        k: integer,
        alpha: *mut dcomplex,
        a: *mut dcomplex,
        lda: integer,
        b: *mut dcomplex,
        ldb: integer,
        beta: *mut dcomplex,
        c: *mut dcomplex,
        ldc: integer,
    );
    pub fn bl1_shemm(
        side: side1_t,
        uplo: uplo1_t,
        m: integer,
        n: integer,
        alpha: *mut f32,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
        b: *mut f32,
        b_rs: integer,
        b_cs: integer,
        beta: *mut f32,
        c: *mut f32,
        c_rs: integer,
        c_cs: integer,
    );
    pub fn bl1_dhemm(
        side: side1_t,
        uplo: uplo1_t,
        m: integer,
        n: integer,
        alpha: *mut f64,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
        b: *mut f64,
        b_rs: integer,
        b_cs: integer,
        beta: *mut f64,
        c: *mut f64,
        c_rs: integer,
        c_cs: integer,
    );
    pub fn bl1_chemm(
        side: side1_t,
        uplo: uplo1_t,
        m: integer,
        n: integer,
        alpha: *mut scomplex,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut scomplex,
        b_rs: integer,
        b_cs: integer,
        beta: *mut scomplex,
        c: *mut scomplex,
        c_rs: integer,
        c_cs: integer,
    );
    pub fn bl1_zhemm(
        side: side1_t,
        uplo: uplo1_t,
        m: integer,
        n: integer,
        alpha: *mut dcomplex,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut dcomplex,
        b_rs: integer,
        b_cs: integer,
        beta: *mut dcomplex,
        c: *mut dcomplex,
        c_rs: integer,
        c_cs: integer,
    );
    pub fn bl1_chemm_blas(
        side: side1_t,
        uplo: uplo1_t,
        m: integer,
        n: integer,
        alpha: *mut scomplex,
        a: *mut scomplex,
        lda: integer,
        b: *mut scomplex,
        ldb: integer,
        beta: *mut scomplex,
        c: *mut scomplex,
        ldc: integer,
    );
    pub fn bl1_zhemm_blas(
        side: side1_t,
        uplo: uplo1_t,
        m: integer,
        n: integer,
        alpha: *mut dcomplex,
        a: *mut dcomplex,
        lda: integer,
        b: *mut dcomplex,
        ldb: integer,
        beta: *mut dcomplex,
        c: *mut dcomplex,
        ldc: integer,
    );
    pub fn bl1_sherk(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        k: integer,
        alpha: *mut f32,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
        beta: *mut f32,
        c: *mut f32,
        c_rs: integer,
        c_cs: integer,
    );
    pub fn bl1_dherk(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        k: integer,
        alpha: *mut f64,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
        beta: *mut f64,
        c: *mut f64,
        c_rs: integer,
        c_cs: integer,
    );
    pub fn bl1_cherk(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        k: integer,
        alpha: *mut f32,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
        beta: *mut f32,
        c: *mut scomplex,
        c_rs: integer,
        c_cs: integer,
    );
    pub fn bl1_zherk(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        k: integer,
        alpha: *mut f64,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
        beta: *mut f64,
        c: *mut dcomplex,
        c_rs: integer,
        c_cs: integer,
    );
    pub fn bl1_cherk_blas(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        k: integer,
        alpha: *mut f32,
        a: *mut scomplex,
        lda: integer,
        beta: *mut f32,
        c: *mut scomplex,
        ldc: integer,
    );
    pub fn bl1_zherk_blas(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        k: integer,
        alpha: *mut f64,
        a: *mut dcomplex,
        lda: integer,
        beta: *mut f64,
        c: *mut dcomplex,
        ldc: integer,
    );
    pub fn bl1_sher2k(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        k: integer,
        alpha: *mut f32,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
        b: *mut f32,
        b_rs: integer,
        b_cs: integer,
        beta: *mut f32,
        c: *mut f32,
        c_rs: integer,
        c_cs: integer,
    );
    pub fn bl1_dher2k(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        k: integer,
        alpha: *mut f64,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
        b: *mut f64,
        b_rs: integer,
        b_cs: integer,
        beta: *mut f64,
        c: *mut f64,
        c_rs: integer,
        c_cs: integer,
    );
    pub fn bl1_cher2k(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        k: integer,
        alpha: *mut scomplex,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut scomplex,
        b_rs: integer,
        b_cs: integer,
        beta: *mut f32,
        c: *mut scomplex,
        c_rs: integer,
        c_cs: integer,
    );
    pub fn bl1_zher2k(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        k: integer,
        alpha: *mut dcomplex,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut dcomplex,
        b_rs: integer,
        b_cs: integer,
        beta: *mut f64,
        c: *mut dcomplex,
        c_rs: integer,
        c_cs: integer,
    );
    pub fn bl1_cher2k_blas(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        k: integer,
        alpha: *mut scomplex,
        a: *mut scomplex,
        lda: integer,
        b: *mut scomplex,
        ldb: integer,
        beta: *mut f32,
        c: *mut scomplex,
        ldc: integer,
    );
    pub fn bl1_zher2k_blas(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        k: integer,
        alpha: *mut dcomplex,
        a: *mut dcomplex,
        lda: integer,
        b: *mut dcomplex,
        ldb: integer,
        beta: *mut f64,
        c: *mut dcomplex,
        ldc: integer,
    );
    pub fn bl1_ssymm(
        side: side1_t,
        uplo: uplo1_t,
        m: integer,
        n: integer,
        alpha: *mut f32,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
        b: *mut f32,
        b_rs: integer,
        b_cs: integer,
        beta: *mut f32,
        c: *mut f32,
        c_rs: integer,
        c_cs: integer,
    );
    pub fn bl1_dsymm(
        side: side1_t,
        uplo: uplo1_t,
        m: integer,
        n: integer,
        alpha: *mut f64,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
        b: *mut f64,
        b_rs: integer,
        b_cs: integer,
        beta: *mut f64,
        c: *mut f64,
        c_rs: integer,
        c_cs: integer,
    );
    pub fn bl1_csymm(
        side: side1_t,
        uplo: uplo1_t,
        m: integer,
        n: integer,
        alpha: *mut scomplex,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut scomplex,
        b_rs: integer,
        b_cs: integer,
        beta: *mut scomplex,
        c: *mut scomplex,
        c_rs: integer,
        c_cs: integer,
    );
    pub fn bl1_zsymm(
        side: side1_t,
        uplo: uplo1_t,
        m: integer,
        n: integer,
        alpha: *mut dcomplex,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut dcomplex,
        b_rs: integer,
        b_cs: integer,
        beta: *mut dcomplex,
        c: *mut dcomplex,
        c_rs: integer,
        c_cs: integer,
    );
    pub fn bl1_ssymm_blas(
        side: side1_t,
        uplo: uplo1_t,
        m: integer,
        n: integer,
        alpha: *mut f32,
        a: *mut f32,
        lda: integer,
        b: *mut f32,
        ldb: integer,
        beta: *mut f32,
        c: *mut f32,
        ldc: integer,
    );
    pub fn bl1_dsymm_blas(
        side: side1_t,
        uplo: uplo1_t,
        m: integer,
        n: integer,
        alpha: *mut f64,
        a: *mut f64,
        lda: integer,
        b: *mut f64,
        ldb: integer,
        beta: *mut f64,
        c: *mut f64,
        ldc: integer,
    );
    pub fn bl1_csymm_blas(
        side: side1_t,
        uplo: uplo1_t,
        m: integer,
        n: integer,
        alpha: *mut scomplex,
        a: *mut scomplex,
        lda: integer,
        b: *mut scomplex,
        ldb: integer,
        beta: *mut scomplex,
        c: *mut scomplex,
        ldc: integer,
    );
    pub fn bl1_zsymm_blas(
        side: side1_t,
        uplo: uplo1_t,
        m: integer,
        n: integer,
        alpha: *mut dcomplex,
        a: *mut dcomplex,
        lda: integer,
        b: *mut dcomplex,
        ldb: integer,
        beta: *mut dcomplex,
        c: *mut dcomplex,
        ldc: integer,
    );
    pub fn bl1_ssyrk(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        k: integer,
        alpha: *mut f32,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
        beta: *mut f32,
        c: *mut f32,
        c_rs: integer,
        c_cs: integer,
    );
    pub fn bl1_dsyrk(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        k: integer,
        alpha: *mut f64,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
        beta: *mut f64,
        c: *mut f64,
        c_rs: integer,
        c_cs: integer,
    );
    pub fn bl1_csyrk(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        k: integer,
        alpha: *mut scomplex,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
        beta: *mut scomplex,
        c: *mut scomplex,
        c_rs: integer,
        c_cs: integer,
    );
    pub fn bl1_zsyrk(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        k: integer,
        alpha: *mut dcomplex,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
        beta: *mut dcomplex,
        c: *mut dcomplex,
        c_rs: integer,
        c_cs: integer,
    );
    pub fn bl1_ssyrk_blas(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        k: integer,
        alpha: *mut f32,
        a: *mut f32,
        lda: integer,
        beta: *mut f32,
        c: *mut f32,
        ldc: integer,
    );
    pub fn bl1_dsyrk_blas(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        k: integer,
        alpha: *mut f64,
        a: *mut f64,
        lda: integer,
        beta: *mut f64,
        c: *mut f64,
        ldc: integer,
    );
    pub fn bl1_csyrk_blas(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        k: integer,
        alpha: *mut scomplex,
        a: *mut scomplex,
        lda: integer,
        beta: *mut scomplex,
        c: *mut scomplex,
        ldc: integer,
    );
    pub fn bl1_zsyrk_blas(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        k: integer,
        alpha: *mut dcomplex,
        a: *mut dcomplex,
        lda: integer,
        beta: *mut dcomplex,
        c: *mut dcomplex,
        ldc: integer,
    );
    pub fn bl1_ssyr2k(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        k: integer,
        alpha: *mut f32,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
        b: *mut f32,
        b_rs: integer,
        b_cs: integer,
        beta: *mut f32,
        c: *mut f32,
        c_rs: integer,
        c_cs: integer,
    );
    pub fn bl1_dsyr2k(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        k: integer,
        alpha: *mut f64,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
        b: *mut f64,
        b_rs: integer,
        b_cs: integer,
        beta: *mut f64,
        c: *mut f64,
        c_rs: integer,
        c_cs: integer,
    );
    pub fn bl1_csyr2k(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        k: integer,
        alpha: *mut scomplex,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut scomplex,
        b_rs: integer,
        b_cs: integer,
        beta: *mut scomplex,
        c: *mut scomplex,
        c_rs: integer,
        c_cs: integer,
    );
    pub fn bl1_zsyr2k(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        k: integer,
        alpha: *mut dcomplex,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut dcomplex,
        b_rs: integer,
        b_cs: integer,
        beta: *mut dcomplex,
        c: *mut dcomplex,
        c_rs: integer,
        c_cs: integer,
    );
    pub fn bl1_ssyr2k_blas(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        k: integer,
        alpha: *mut f32,
        a: *mut f32,
        lda: integer,
        b: *mut f32,
        ldb: integer,
        beta: *mut f32,
        c: *mut f32,
        ldc: integer,
    );
    pub fn bl1_dsyr2k_blas(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        k: integer,
        alpha: *mut f64,
        a: *mut f64,
        lda: integer,
        b: *mut f64,
        ldb: integer,
        beta: *mut f64,
        c: *mut f64,
        ldc: integer,
    );
    pub fn bl1_csyr2k_blas(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        k: integer,
        alpha: *mut scomplex,
        a: *mut scomplex,
        lda: integer,
        b: *mut scomplex,
        ldb: integer,
        beta: *mut scomplex,
        c: *mut scomplex,
        ldc: integer,
    );
    pub fn bl1_zsyr2k_blas(
        uplo: uplo1_t,
        trans: trans1_t,
        m: integer,
        k: integer,
        alpha: *mut dcomplex,
        a: *mut dcomplex,
        lda: integer,
        b: *mut dcomplex,
        ldb: integer,
        beta: *mut dcomplex,
        c: *mut dcomplex,
        ldc: integer,
    );
    pub fn bl1_strmm(
        side: side1_t,
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        n: integer,
        alpha: *mut f32,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
        b: *mut f32,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_dtrmm(
        side: side1_t,
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        n: integer,
        alpha: *mut f64,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
        b: *mut f64,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_ctrmm(
        side: side1_t,
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        n: integer,
        alpha: *mut scomplex,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut scomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_ztrmm(
        side: side1_t,
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        n: integer,
        alpha: *mut dcomplex,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut dcomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_strmm_blas(
        side: side1_t,
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        n: integer,
        alpha: *mut f32,
        a: *mut f32,
        lda: integer,
        b: *mut f32,
        ldb: integer,
    );
    pub fn bl1_dtrmm_blas(
        side: side1_t,
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        n: integer,
        alpha: *mut f64,
        a: *mut f64,
        lda: integer,
        b: *mut f64,
        ldb: integer,
    );
    pub fn bl1_ctrmm_blas(
        side: side1_t,
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        n: integer,
        alpha: *mut scomplex,
        a: *mut scomplex,
        lda: integer,
        b: *mut scomplex,
        ldb: integer,
    );
    pub fn bl1_ztrmm_blas(
        side: side1_t,
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        n: integer,
        alpha: *mut dcomplex,
        a: *mut dcomplex,
        lda: integer,
        b: *mut dcomplex,
        ldb: integer,
    );
    pub fn bl1_strsm(
        side: side1_t,
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        n: integer,
        alpha: *mut f32,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
        b: *mut f32,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_dtrsm(
        side: side1_t,
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        n: integer,
        alpha: *mut f64,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
        b: *mut f64,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_ctrsm(
        side: side1_t,
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        n: integer,
        alpha: *mut scomplex,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut scomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_ztrsm(
        side: side1_t,
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        n: integer,
        alpha: *mut dcomplex,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut dcomplex,
        b_rs: integer,
        b_cs: integer,
    );
    pub fn bl1_strsm_blas(
        side: side1_t,
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        n: integer,
        alpha: *mut f32,
        a: *mut f32,
        lda: integer,
        b: *mut f32,
        ldb: integer,
    );
    pub fn bl1_dtrsm_blas(
        side: side1_t,
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        n: integer,
        alpha: *mut f64,
        a: *mut f64,
        lda: integer,
        b: *mut f64,
        ldb: integer,
    );
    pub fn bl1_ctrsm_blas(
        side: side1_t,
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        n: integer,
        alpha: *mut scomplex,
        a: *mut scomplex,
        lda: integer,
        b: *mut scomplex,
        ldb: integer,
    );
    pub fn bl1_ztrsm_blas(
        side: side1_t,
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        n: integer,
        alpha: *mut dcomplex,
        a: *mut dcomplex,
        lda: integer,
        b: *mut dcomplex,
        ldb: integer,
    );
    pub fn bl1_strmmsx(
        side: side1_t,
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        n: integer,
        alpha: *mut f32,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
        b: *mut f32,
        b_rs: integer,
        b_cs: integer,
        beta: *mut f32,
        c: *mut f32,
        c_rs: integer,
        c_cs: integer,
    );
    pub fn bl1_dtrmmsx(
        side: side1_t,
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        n: integer,
        alpha: *mut f64,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
        b: *mut f64,
        b_rs: integer,
        b_cs: integer,
        beta: *mut f64,
        c: *mut f64,
        c_rs: integer,
        c_cs: integer,
    );
    pub fn bl1_ctrmmsx(
        side: side1_t,
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        n: integer,
        alpha: *mut scomplex,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut scomplex,
        b_rs: integer,
        b_cs: integer,
        beta: *mut scomplex,
        c: *mut scomplex,
        c_rs: integer,
        c_cs: integer,
    );
    pub fn bl1_ztrmmsx(
        side: side1_t,
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        n: integer,
        alpha: *mut dcomplex,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut dcomplex,
        b_rs: integer,
        b_cs: integer,
        beta: *mut dcomplex,
        c: *mut dcomplex,
        c_rs: integer,
        c_cs: integer,
    );
    pub fn bl1_strsmsx(
        side: side1_t,
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        n: integer,
        alpha: *mut f32,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
        b: *mut f32,
        b_rs: integer,
        b_cs: integer,
        beta: *mut f32,
        c: *mut f32,
        c_rs: integer,
        c_cs: integer,
    );
    pub fn bl1_dtrsmsx(
        side: side1_t,
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        n: integer,
        alpha: *mut f64,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
        b: *mut f64,
        b_rs: integer,
        b_cs: integer,
        beta: *mut f64,
        c: *mut f64,
        c_rs: integer,
        c_cs: integer,
    );
    pub fn bl1_ctrsmsx(
        side: side1_t,
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        n: integer,
        alpha: *mut scomplex,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut scomplex,
        b_rs: integer,
        b_cs: integer,
        beta: *mut scomplex,
        c: *mut scomplex,
        c_rs: integer,
        c_cs: integer,
    );
    pub fn bl1_ztrsmsx(
        side: side1_t,
        uplo: uplo1_t,
        trans: trans1_t,
        diag: diag1_t,
        m: integer,
        n: integer,
        alpha: *mut dcomplex,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
        b: *mut dcomplex,
        b_rs: integer,
        b_cs: integer,
        beta: *mut dcomplex,
        c: *mut dcomplex,
        c_rs: integer,
        c_cs: integer,
    );
    pub fn bl1_saxmyv2(
        conjx: conj1_t,
        n: integer,
        alpha: *mut f32,
        beta: *mut f32,
        x: *mut f32,
        inc_x: integer,
        y: *mut f32,
        inc_y: integer,
        z: *mut f32,
        inc_z: integer,
    );
    pub fn bl1_daxmyv2(
        conjx: conj1_t,
        n: integer,
        alpha: *mut f64,
        beta: *mut f64,
        x: *mut f64,
        inc_x: integer,
        y: *mut f64,
        inc_y: integer,
        z: *mut f64,
        inc_z: integer,
    );
    pub fn bl1_caxmyv2(
        conjx: conj1_t,
        n: integer,
        alpha: *mut scomplex,
        beta: *mut scomplex,
        x: *mut scomplex,
        inc_x: integer,
        y: *mut scomplex,
        inc_y: integer,
        z: *mut scomplex,
        inc_z: integer,
    );
    pub fn bl1_zaxmyv2(
        conjx: conj1_t,
        n: integer,
        alpha: *mut dcomplex,
        beta: *mut dcomplex,
        x: *mut dcomplex,
        inc_x: integer,
        y: *mut dcomplex,
        inc_y: integer,
        z: *mut dcomplex,
        inc_z: integer,
    );
    pub fn bl1_saxpyv2b(
        n: integer,
        beta1: *mut f32,
        beta2: *mut f32,
        a1: *mut f32,
        inc_a1: integer,
        a2: *mut f32,
        inc_a2: integer,
        w: *mut f32,
        inc_w: integer,
    );
    pub fn bl1_daxpyv2b(
        n: integer,
        beta1: *mut f64,
        beta2: *mut f64,
        a1: *mut f64,
        inc_a1: integer,
        a2: *mut f64,
        inc_a2: integer,
        w: *mut f64,
        inc_w: integer,
    );
    pub fn bl1_caxpyv2b(
        n: integer,
        beta1: *mut scomplex,
        beta2: *mut scomplex,
        a1: *mut scomplex,
        inc_a1: integer,
        a2: *mut scomplex,
        inc_a2: integer,
        w: *mut scomplex,
        inc_w: integer,
    );
    pub fn bl1_zaxpyv2b(
        n: integer,
        beta1: *mut dcomplex,
        beta2: *mut dcomplex,
        a1: *mut dcomplex,
        inc_a1: integer,
        a2: *mut dcomplex,
        inc_a2: integer,
        w: *mut dcomplex,
        inc_w: integer,
    );
    pub fn bl1_saxpyv3b(
        n: integer,
        beta1: *mut f32,
        beta2: *mut f32,
        beta3: *mut f32,
        a1: *mut f32,
        inc_a1: integer,
        a2: *mut f32,
        inc_a2: integer,
        a3: *mut f32,
        inc_a3: integer,
        w: *mut f32,
        inc_w: integer,
    );
    pub fn bl1_daxpyv3b(
        n: integer,
        beta1: *mut f64,
        beta2: *mut f64,
        beta3: *mut f64,
        a1: *mut f64,
        inc_a1: integer,
        a2: *mut f64,
        inc_a2: integer,
        a3: *mut f64,
        inc_a3: integer,
        w: *mut f64,
        inc_w: integer,
    );
    pub fn bl1_caxpyv3b(
        n: integer,
        beta1: *mut scomplex,
        beta2: *mut scomplex,
        beta3: *mut scomplex,
        a1: *mut scomplex,
        inc_a1: integer,
        a2: *mut scomplex,
        inc_a2: integer,
        a3: *mut scomplex,
        inc_a3: integer,
        w: *mut scomplex,
        inc_w: integer,
    );
    pub fn bl1_zaxpyv3b(
        n: integer,
        beta1: *mut dcomplex,
        beta2: *mut dcomplex,
        beta3: *mut dcomplex,
        a1: *mut dcomplex,
        inc_a1: integer,
        a2: *mut dcomplex,
        inc_a2: integer,
        a3: *mut dcomplex,
        inc_a3: integer,
        w: *mut dcomplex,
        inc_w: integer,
    );
    pub fn bl1_saxpyv2bdotaxpy(
        n: integer,
        beta: *mut f32,
        u: *mut f32,
        inc_u: integer,
        gamma: *mut f32,
        z: *mut f32,
        inc_z: integer,
        a: *mut f32,
        inc_a: integer,
        x: *mut f32,
        inc_x: integer,
        kappa: *mut f32,
        rho: *mut f32,
        w: *mut f32,
        inc_w: integer,
    );
    pub fn bl1_daxpyv2bdotaxpy(
        n: integer,
        beta: *mut f64,
        u: *mut f64,
        inc_u: integer,
        gamma: *mut f64,
        z: *mut f64,
        inc_z: integer,
        a: *mut f64,
        inc_a: integer,
        x: *mut f64,
        inc_x: integer,
        kappa: *mut f64,
        rho: *mut f64,
        w: *mut f64,
        inc_w: integer,
    );
    pub fn bl1_caxpyv2bdotaxpy(
        n: integer,
        beta: *mut scomplex,
        u: *mut scomplex,
        inc_u: integer,
        gamma: *mut scomplex,
        z: *mut scomplex,
        inc_z: integer,
        a: *mut scomplex,
        inc_a: integer,
        x: *mut scomplex,
        inc_x: integer,
        kappa: *mut scomplex,
        rho: *mut scomplex,
        w: *mut scomplex,
        inc_w: integer,
    );
    pub fn bl1_zaxpyv2bdotaxpy(
        n: integer,
        beta: *mut dcomplex,
        u: *mut dcomplex,
        inc_u: integer,
        gamma: *mut dcomplex,
        z: *mut dcomplex,
        inc_z: integer,
        a: *mut dcomplex,
        inc_a: integer,
        x: *mut dcomplex,
        inc_x: integer,
        kappa: *mut dcomplex,
        rho: *mut dcomplex,
        w: *mut dcomplex,
        inc_w: integer,
    );
    pub fn bl1_sdotsv2(
        conjxy: conj1_t,
        n: integer,
        x: *mut f32,
        inc_x: integer,
        y: *mut f32,
        inc_y: integer,
        z: *mut f32,
        inc_z: integer,
        beta: *mut f32,
        rho_xz: *mut f32,
        rho_yz: *mut f32,
    );
    pub fn bl1_ddotsv2(
        conjxy: conj1_t,
        n: integer,
        x: *mut f64,
        inc_x: integer,
        y: *mut f64,
        inc_y: integer,
        z: *mut f64,
        inc_z: integer,
        beta: *mut f64,
        rho_xz: *mut f64,
        rho_yz: *mut f64,
    );
    pub fn bl1_cdotsv2(
        conjxy: conj1_t,
        n: integer,
        x: *mut scomplex,
        inc_x: integer,
        y: *mut scomplex,
        inc_y: integer,
        z: *mut scomplex,
        inc_z: integer,
        beta: *mut scomplex,
        rho_xz: *mut scomplex,
        rho_yz: *mut scomplex,
    );
    pub fn bl1_zdotsv2(
        conjxy: conj1_t,
        n: integer,
        x: *mut dcomplex,
        inc_x: integer,
        y: *mut dcomplex,
        inc_y: integer,
        z: *mut dcomplex,
        inc_z: integer,
        beta: *mut dcomplex,
        rho_xz: *mut dcomplex,
        rho_yz: *mut dcomplex,
    );
    pub fn bl1_sdotsv3(
        conjxyw: conj1_t,
        n: integer,
        x: *mut f32,
        inc_x: integer,
        y: *mut f32,
        inc_y: integer,
        w: *mut f32,
        inc_w: integer,
        z: *mut f32,
        inc_z: integer,
        beta: *mut f32,
        rho_xz: *mut f32,
        rho_yz: *mut f32,
        rho_wz: *mut f32,
    );
    pub fn bl1_ddotsv3(
        conjxyw: conj1_t,
        n: integer,
        x: *mut f64,
        inc_x: integer,
        y: *mut f64,
        inc_y: integer,
        w: *mut f64,
        inc_w: integer,
        z: *mut f64,
        inc_z: integer,
        beta: *mut f64,
        rho_xz: *mut f64,
        rho_yz: *mut f64,
        rho_wz: *mut f64,
    );
    pub fn bl1_cdotsv3(
        conjxyw: conj1_t,
        n: integer,
        x: *mut scomplex,
        inc_x: integer,
        y: *mut scomplex,
        inc_y: integer,
        w: *mut scomplex,
        inc_w: integer,
        z: *mut scomplex,
        inc_z: integer,
        beta: *mut scomplex,
        rho_xz: *mut scomplex,
        rho_yz: *mut scomplex,
        rho_wz: *mut scomplex,
    );
    pub fn bl1_zdotsv3(
        conjxyw: conj1_t,
        n: integer,
        x: *mut dcomplex,
        inc_x: integer,
        y: *mut dcomplex,
        inc_y: integer,
        w: *mut dcomplex,
        inc_w: integer,
        z: *mut dcomplex,
        inc_z: integer,
        beta: *mut dcomplex,
        rho_xz: *mut dcomplex,
        rho_yz: *mut dcomplex,
        rho_wz: *mut dcomplex,
    );
    pub fn bl1_sdotaxpy(
        n: integer,
        a: *mut f32,
        inc_a: integer,
        x: *mut f32,
        inc_x: integer,
        kappa: *mut f32,
        rho: *mut f32,
        w: *mut f32,
        inc_w: integer,
    );
    pub fn bl1_ddotaxpy(
        n: integer,
        a: *mut f64,
        inc_a: integer,
        x: *mut f64,
        inc_x: integer,
        kappa: *mut f64,
        rho: *mut f64,
        w: *mut f64,
        inc_w: integer,
    );
    pub fn bl1_cdotaxpy(
        n: integer,
        a: *mut scomplex,
        inc_a: integer,
        x: *mut scomplex,
        inc_x: integer,
        kappa: *mut scomplex,
        rho: *mut scomplex,
        w: *mut scomplex,
        inc_w: integer,
    );
    pub fn bl1_zdotaxpy(
        n: integer,
        a: *mut dcomplex,
        inc_a: integer,
        x: *mut dcomplex,
        inc_x: integer,
        kappa: *mut dcomplex,
        rho: *mut dcomplex,
        w: *mut dcomplex,
        inc_w: integer,
    );
    pub fn bl1_sdotaxmyv2(
        n: integer,
        alpha: *mut f32,
        beta: *mut f32,
        x: *mut f32,
        inc_x: integer,
        u: *mut f32,
        inc_u: integer,
        rho: *mut f32,
        y: *mut f32,
        inc_y: integer,
        z: *mut f32,
        inc_z: integer,
    );
    pub fn bl1_ddotaxmyv2(
        n: integer,
        alpha: *mut f64,
        beta: *mut f64,
        x: *mut f64,
        inc_x: integer,
        u: *mut f64,
        inc_u: integer,
        rho: *mut f64,
        y: *mut f64,
        inc_y: integer,
        z: *mut f64,
        inc_z: integer,
    );
    pub fn bl1_cdotaxmyv2(
        n: integer,
        alpha: *mut scomplex,
        beta: *mut scomplex,
        x: *mut scomplex,
        inc_x: integer,
        u: *mut scomplex,
        inc_u: integer,
        rho: *mut scomplex,
        y: *mut scomplex,
        inc_y: integer,
        z: *mut scomplex,
        inc_z: integer,
    );
    pub fn bl1_zdotaxmyv2(
        n: integer,
        alpha: *mut dcomplex,
        beta: *mut dcomplex,
        x: *mut dcomplex,
        inc_x: integer,
        u: *mut dcomplex,
        inc_u: integer,
        rho: *mut dcomplex,
        y: *mut dcomplex,
        inc_y: integer,
        z: *mut dcomplex,
        inc_z: integer,
    );
    pub fn bl1_sdotv2axpyv2b(
        n: integer,
        a1: *mut f32,
        inc_a1: integer,
        a2: *mut f32,
        inc_a2: integer,
        x: *mut f32,
        inc_x: integer,
        kappa1: *mut f32,
        kappa2: *mut f32,
        rho1: *mut f32,
        rho2: *mut f32,
        w: *mut f32,
        inc_w: integer,
    );
    pub fn bl1_ddotv2axpyv2b(
        n: integer,
        a1: *mut f64,
        inc_a1: integer,
        a2: *mut f64,
        inc_a2: integer,
        x: *mut f64,
        inc_x: integer,
        kappa1: *mut f64,
        kappa2: *mut f64,
        rho1: *mut f64,
        rho2: *mut f64,
        w: *mut f64,
        inc_w: integer,
    );
    pub fn bl1_cdotv2axpyv2b(
        n: integer,
        a1: *mut scomplex,
        inc_a1: integer,
        a2: *mut scomplex,
        inc_a2: integer,
        x: *mut scomplex,
        inc_x: integer,
        kappa1: *mut scomplex,
        kappa2: *mut scomplex,
        rho1: *mut scomplex,
        rho2: *mut scomplex,
        w: *mut scomplex,
        inc_w: integer,
    );
    pub fn bl1_zdotv2axpyv2b(
        n: integer,
        a1: *mut dcomplex,
        inc_a1: integer,
        a2: *mut dcomplex,
        inc_a2: integer,
        x: *mut dcomplex,
        inc_x: integer,
        kappa1: *mut dcomplex,
        kappa2: *mut dcomplex,
        rho1: *mut dcomplex,
        rho2: *mut dcomplex,
        w: *mut dcomplex,
        inc_w: integer,
    );
    pub fn bl1_zaxpyv2bdots(
        n: integer,
        alpha1: *mut dcomplex,
        alpha2: *mut dcomplex,
        x1: *mut dcomplex,
        inc_x1: integer,
        x2: *mut dcomplex,
        inc_x2: integer,
        y: *mut dcomplex,
        inc_y: integer,
        u: *mut dcomplex,
        inc_u: integer,
        beta: *mut dcomplex,
        rho: *mut dcomplex,
    );
    pub static mut FLA_THREE: FLA_Obj;
    pub static mut FLA_TWO: FLA_Obj;
    pub static mut FLA_ONE: FLA_Obj;
    pub static mut FLA_ONE_HALF: FLA_Obj;
    pub static mut FLA_ZERO: FLA_Obj;
    pub static mut FLA_MINUS_ONE_HALF: FLA_Obj;
    pub static mut FLA_MINUS_ONE: FLA_Obj;
    pub static mut FLA_MINUS_TWO: FLA_Obj;
    pub static mut FLA_MINUS_THREE: FLA_Obj;
    pub static mut FLA_EPSILON: FLA_Obj;
    pub static mut FLA_SAFE_MIN: FLA_Obj;
    pub static mut FLA_SAFE_MIN_SQUARE: FLA_Obj;
    pub static mut FLA_SAFE_INV_MIN: FLA_Obj;
    pub static mut FLA_SAFE_INV_MIN_SQUARE: FLA_Obj;
    pub static mut FLA_UNDERFLOW_THRES: FLA_Obj;
    pub static mut FLA_OVERFLOW_THRES: FLA_Obj;
    pub static mut FLA_UNDERFLOW_SQUARE_THRES: FLA_Obj;
    pub static mut FLA_OVERFLOW_SQUARE_THRES: FLA_Obj;
    pub static fzero: f32;
    pub static dzero: f64;
    pub static czero: scomplex;
    pub static zzero: dcomplex;
    pub fn FLA_Cntl_obj_free(cntl: *mut c_void);
    pub fn FLA_Cntl_axpy_obj_create(
        matrix_type: FLA_Matrix_type,
        variant: c_int,
        blocksize: *mut fla_blocksize_t,
        sub_axpy: *mut fla_axpy_t,
    ) -> *mut fla_axpy_t;
    pub fn FLA_Cntl_axpyt_obj_create(
        matrix_type: FLA_Matrix_type,
        variant: c_int,
        blocksize: *mut fla_blocksize_t,
        sub_axpyt: *mut fla_axpyt_t,
    ) -> *mut fla_axpyt_t;
    pub fn FLA_Cntl_copy_obj_create(
        matrix_type: FLA_Matrix_type,
        variant: c_int,
        blocksize: *mut fla_blocksize_t,
        sub_copy: *mut fla_copy_t,
    ) -> *mut fla_copy_t;
    pub fn FLA_Cntl_copyt_obj_create(
        matrix_type: FLA_Matrix_type,
        variant: c_int,
        blocksize: *mut fla_blocksize_t,
        sub_copyt: *mut fla_copyt_t,
    ) -> *mut fla_copyt_t;
    pub fn FLA_Cntl_copyr_obj_create(
        matrix_type: FLA_Matrix_type,
        variant: c_int,
        blocksize: *mut fla_blocksize_t,
        sub_copyr: *mut fla_copyr_t,
        sub_copy: *mut fla_copy_t,
    ) -> *mut fla_copyr_t;
    pub fn FLA_Cntl_scal_obj_create(
        matrix_type: FLA_Matrix_type,
        variant: c_int,
        blocksize: *mut fla_blocksize_t,
        sub_scal: *mut fla_scal_t,
    ) -> *mut fla_scal_t;
    pub fn FLA_Cntl_scalr_obj_create(
        matrix_type: FLA_Matrix_type,
        variant: c_int,
        blocksize: *mut fla_blocksize_t,
        sub_scalr: *mut fla_scalr_t,
        sub_scal: *mut fla_scal_t,
    ) -> *mut fla_scalr_t;
    pub fn FLA_Cntl_swap_obj_create(
        matrix_type: FLA_Matrix_type,
        variant: c_int,
        blocksize: *mut fla_blocksize_t,
        sub_swap: *mut fla_swap_t,
    ) -> *mut fla_swap_t;
    pub fn FLA_Cntl_tpose_obj_create(
        matrix_type: FLA_Matrix_type,
        variant: c_int,
        blocksize: *mut fla_blocksize_t,
        sub_trans: *mut fla_tpose_t,
        sub_swap: *mut fla_swap_t,
    ) -> *mut fla_tpose_t;
    pub fn FLA_Cntl_gemv_obj_create(
        matrix_type: FLA_Matrix_type,
        variant: c_int,
        blocksize: *mut fla_blocksize_t,
        sub_scal: *mut fla_scal_t,
        sub_gemv: *mut fla_gemv_t,
    ) -> *mut fla_gemv_t;
    pub fn FLA_Cntl_trsv_obj_create(
        matrix_type: FLA_Matrix_type,
        variant: c_int,
        blocksize: *mut fla_blocksize_t,
        sub_trsv: *mut fla_trsv_t,
        sub_gemv: *mut fla_gemv_t,
    ) -> *mut fla_trsv_t;
    pub fn FLA_Cntl_gemm_obj_create(
        matrix_type: FLA_Matrix_type,
        variant: c_int,
        blocksize: *mut fla_blocksize_t,
        sub_scal: *mut fla_scal_t,
        sub_gemm: *mut fla_gemm_t,
    ) -> *mut fla_gemm_t;
    pub fn FLA_Cntl_hemm_obj_create(
        matrix_type: FLA_Matrix_type,
        variant: c_int,
        blocksize: *mut fla_blocksize_t,
        sub_scal: *mut fla_scal_t,
        sub_hemm: *mut fla_hemm_t,
        sub_gemm1: *mut fla_gemm_t,
        sub_gemm2: *mut fla_gemm_t,
    ) -> *mut fla_hemm_t;
    pub fn FLA_Cntl_herk_obj_create(
        matrix_type: FLA_Matrix_type,
        variant: c_int,
        blocksize: *mut fla_blocksize_t,
        sub_scalr: *mut fla_scalr_t,
        sub_herk: *mut fla_herk_t,
        sub_gemm: *mut fla_gemm_t,
    ) -> *mut fla_herk_t;
    pub fn FLA_Cntl_her2k_obj_create(
        matrix_type: FLA_Matrix_type,
        variant: c_int,
        blocksize: *mut fla_blocksize_t,
        sub_scalr: *mut fla_scalr_t,
        sub_her2k: *mut fla_her2k_t,
        sub_gemm1: *mut fla_gemm_t,
        sub_gemm2: *mut fla_gemm_t,
    ) -> *mut fla_her2k_t;
    pub fn FLA_Cntl_symm_obj_create(
        matrix_type: FLA_Matrix_type,
        variant: c_int,
        blocksize: *mut fla_blocksize_t,
        sub_scal: *mut fla_scal_t,
        sub_symm: *mut fla_symm_t,
        sub_gemm1: *mut fla_gemm_t,
        sub_gemm2: *mut fla_gemm_t,
    ) -> *mut fla_symm_t;
    pub fn FLA_Cntl_syrk_obj_create(
        matrix_type: FLA_Matrix_type,
        variant: c_int,
        blocksize: *mut fla_blocksize_t,
        sub_scalr: *mut fla_scalr_t,
        sub_syrk: *mut fla_syrk_t,
        sub_gemm: *mut fla_gemm_t,
    ) -> *mut fla_syrk_t;
    pub fn FLA_Cntl_syr2k_obj_create(
        matrix_type: FLA_Matrix_type,
        variant: c_int,
        blocksize: *mut fla_blocksize_t,
        sub_scalr: *mut fla_scalr_t,
        sub_syr2k: *mut fla_syr2k_t,
        sub_gemm1: *mut fla_gemm_t,
        sub_gemm2: *mut fla_gemm_t,
    ) -> *mut fla_syr2k_t;
    pub fn FLA_Cntl_trmm_obj_create(
        matrix_type: FLA_Matrix_type,
        variant: c_int,
        blocksize: *mut fla_blocksize_t,
        sub_scal: *mut fla_scal_t,
        sub_trmm: *mut fla_trmm_t,
        sub_gemm: *mut fla_gemm_t,
    ) -> *mut fla_trmm_t;
    pub fn FLA_Cntl_trsm_obj_create(
        matrix_type: FLA_Matrix_type,
        variant: c_int,
        blocksize: *mut fla_blocksize_t,
        sub_scal: *mut fla_scal_t,
        sub_trsm: *mut fla_trsm_t,
        sub_gemm: *mut fla_gemm_t,
    ) -> *mut fla_trsm_t;
    pub fn FLA_Cntl_chol_obj_create(
        matrix_type: FLA_Matrix_type,
        variant: c_int,
        blocksize: *mut fla_blocksize_t,
        sub_chol: *mut fla_chol_t,
        sub_herk: *mut fla_herk_t,
        sub_trsm: *mut fla_trsm_t,
        sub_gemm: *mut fla_gemm_t,
    ) -> *mut fla_chol_t;
    pub fn FLA_Cntl_lu_obj_create(
        matrix_type: FLA_Matrix_type,
        variant: c_int,
        blocksize: *mut fla_blocksize_t,
        sub_lu: *mut fla_lu_t,
        sub_gemm1: *mut fla_gemm_t,
        sub_gemm2: *mut fla_gemm_t,
        sub_gemm3: *mut fla_gemm_t,
        sub_trsm1: *mut fla_trsm_t,
        sub_trsm2: *mut fla_trsm_t,
        sub_appiv1: *mut fla_appiv_t,
        sub_appiv2: *mut fla_appiv_t,
    ) -> *mut fla_lu_t;
    pub fn FLA_Cntl_appiv_obj_create(
        matrix_type: FLA_Matrix_type,
        variant: c_int,
        blocksize: *mut fla_blocksize_t,
        sub_appiv: *mut fla_appiv_t,
    ) -> *mut fla_appiv_t;
    pub fn FLA_Cntl_qrut_obj_create(
        matrix_type: FLA_Matrix_type,
        variant: c_int,
        blocksize: *mut fla_blocksize_t,
        sub_qrut: *mut fla_qrut_t,
        sub_apqut: *mut fla_apqut_t,
    ) -> *mut fla_qrut_t;
    pub fn FLA_Cntl_qr2ut_obj_create(
        matrix_type: FLA_Matrix_type,
        variant: c_int,
        blocksize: *mut fla_blocksize_t,
        sub_qr2ut: *mut fla_qr2ut_t,
        sub_gemm1: *mut fla_gemm_t,
        sub_gemm2: *mut fla_gemm_t,
        sub_trsm: *mut fla_trsm_t,
        sub_copy: *mut fla_copy_t,
        sub_axpy: *mut fla_axpy_t,
    ) -> *mut fla_qr2ut_t;
    pub fn FLA_Cntl_lqut_obj_create(
        matrix_type: FLA_Matrix_type,
        variant: c_int,
        blocksize: *mut fla_blocksize_t,
        sub_lqut: *mut fla_lqut_t,
        sub_apqut: *mut fla_apqut_t,
    ) -> *mut fla_lqut_t;
    pub fn FLA_Cntl_caqr2ut_obj_create(
        matrix_type: FLA_Matrix_type,
        variant: c_int,
        blocksize: *mut fla_blocksize_t,
        sub_caqr2ut: *mut fla_caqr2ut_t,
        sub_gemm1: *mut fla_gemm_t,
        sub_gemm2: *mut fla_gemm_t,
        sub_trmm1: *mut fla_trmm_t,
        sub_trmm2: *mut fla_trmm_t,
        sub_trsm: *mut fla_trsm_t,
        sub_axpy1: *mut fla_axpy_t,
        sub_axpy2: *mut fla_axpy_t,
        sub_axpy3: *mut fla_axpy_t,
        sub_copy: *mut fla_copy_t,
    ) -> *mut fla_caqr2ut_t;
    pub fn FLA_Cntl_hessut_obj_create(
        matrix_type: FLA_Matrix_type,
        variant: c_int,
        blocksize: *mut fla_blocksize_t,
    ) -> *mut fla_hessut_t;
    pub fn FLA_Cntl_tridiagut_obj_create(
        matrix_type: FLA_Matrix_type,
        variant: c_int,
        blocksize: *mut fla_blocksize_t,
    ) -> *mut fla_tridiagut_t;
    pub fn FLA_Cntl_bidiagut_obj_create(
        matrix_type: FLA_Matrix_type,
        variant: c_int,
        blocksize: *mut fla_blocksize_t,
    ) -> *mut fla_bidiagut_t;
    pub fn FLA_Cntl_trinv_obj_create(
        matrix_type: FLA_Matrix_type,
        variant: c_int,
        blocksize: *mut fla_blocksize_t,
        sub_trinv: *mut fla_trinv_t,
        sub_trmm: *mut fla_trmm_t,
        sub_trsm1: *mut fla_trsm_t,
        sub_trsm2: *mut fla_trsm_t,
        sub_gemm: *mut fla_gemm_t,
    ) -> *mut fla_trinv_t;
    pub fn FLA_Cntl_ttmm_obj_create(
        matrix_type: FLA_Matrix_type,
        variant: c_int,
        blocksize: *mut fla_blocksize_t,
        sub_ttmm: *mut fla_ttmm_t,
        sub_herk: *mut fla_herk_t,
        sub_trmm: *mut fla_trmm_t,
        sub_gemm: *mut fla_gemm_t,
    ) -> *mut fla_ttmm_t;
    pub fn FLA_Cntl_sylv_obj_create(
        matrix_type: FLA_Matrix_type,
        variant: c_int,
        blocksize: *mut fla_blocksize_t,
        sub_sylv1: *mut fla_sylv_t,
        sub_sylv2: *mut fla_sylv_t,
        sub_sylv3: *mut fla_sylv_t,
        sub_gemm1: *mut fla_gemm_t,
        sub_gemm2: *mut fla_gemm_t,
        sub_gemm3: *mut fla_gemm_t,
        sub_gemm4: *mut fla_gemm_t,
        sub_gemm5: *mut fla_gemm_t,
        sub_gemm6: *mut fla_gemm_t,
        sub_gemm7: *mut fla_gemm_t,
        sub_gemm8: *mut fla_gemm_t,
    ) -> *mut fla_sylv_t;
    pub fn FLA_Cntl_lyap_obj_create(
        matrix_type: FLA_Matrix_type,
        variant: c_int,
        blocksize: *mut fla_blocksize_t,
        sub_scal: *mut fla_scal_t,
        sub_lyap: *mut fla_lyap_t,
        sub_sylv: *mut fla_sylv_t,
        sub_gemm1: *mut fla_gemm_t,
        sub_gemm2: *mut fla_gemm_t,
        sub_hemm: *mut fla_hemm_t,
        sub_her2k: *mut fla_her2k_t,
    ) -> *mut fla_lyap_t;
    pub fn FLA_Cntl_spdinv_obj_create(
        matrix_type: FLA_Matrix_type,
        variant: c_int,
        blocksize: *mut fla_blocksize_t,
        sub_chol: *mut fla_chol_t,
        sub_trinv: *mut fla_trinv_t,
        sub_ttmm: *mut fla_ttmm_t,
    ) -> *mut fla_spdinv_t;
    pub fn FLA_Cntl_apqut_obj_create(
        matrix_type: FLA_Matrix_type,
        variant: c_int,
        blocksize: *mut fla_blocksize_t,
        sub_apqut: *mut fla_apqut_t,
        sub_trmm1: *mut fla_trmm_t,
        sub_trmm2: *mut fla_trmm_t,
        sub_gemm1: *mut fla_gemm_t,
        sub_gemm2: *mut fla_gemm_t,
        sub_trsm: *mut fla_trsm_t,
        sub_copyt: *mut fla_copyt_t,
        sub_axpyt: *mut fla_axpyt_t,
    ) -> *mut fla_apqut_t;
    pub fn FLA_Cntl_apq2ut_obj_create(
        matrix_type: FLA_Matrix_type,
        variant: c_int,
        blocksize: *mut fla_blocksize_t,
        sub_apq2ut: *mut fla_apq2ut_t,
        sub_gemm1: *mut fla_gemm_t,
        sub_gemm2: *mut fla_gemm_t,
        sub_trsm: *mut fla_trsm_t,
        sub_copyt: *mut fla_copyt_t,
        sub_axpyt: *mut fla_axpyt_t,
    ) -> *mut fla_apq2ut_t;
    pub fn FLA_Cntl_apcaq2ut_obj_create(
        matrix_type: FLA_Matrix_type,
        variant: c_int,
        blocksize: *mut fla_blocksize_t,
        sub_apcaq2ut: *mut fla_apcaq2ut_t,
        sub_gemm1: *mut fla_gemm_t,
        sub_gemm2: *mut fla_gemm_t,
        sub_trmm1: *mut fla_trmm_t,
        sub_trmm2: *mut fla_trmm_t,
        sub_trsm: *mut fla_trsm_t,
        sub_axpy1: *mut fla_axpy_t,
        sub_axpy2: *mut fla_axpy_t,
        sub_axpy3: *mut fla_axpy_t,
        sub_copy: *mut fla_copy_t,
    ) -> *mut fla_apcaq2ut_t;
    pub fn FLA_Cntl_qrutinc_obj_create(
        matrix_type: FLA_Matrix_type,
        variant: c_int,
        blocksize: *mut fla_blocksize_t,
        sub_qrut: *mut fla_qrut_t,
        sub_apqut: *mut fla_apqut_t,
        sub_qr2ut: *mut fla_qr2ut_t,
        sub_apq2ut: *mut fla_apq2ut_t,
    ) -> *mut fla_qrutinc_t;
    pub fn FLA_Cntl_apqutinc_obj_create(
        matrix_type: FLA_Matrix_type,
        variant: c_int,
        blocksize: *mut fla_blocksize_t,
        sub_apqut: *mut fla_apqut_t,
        sub_apq2ut: *mut fla_apq2ut_t,
    ) -> *mut fla_apqutinc_t;
    pub fn FLA_Cntl_caqrutinc_obj_create(
        matrix_type: FLA_Matrix_type,
        variant: c_int,
        blocksize: *mut fla_blocksize_t,
        sub_caqr2ut: *mut fla_caqr2ut_t,
        sub_apcaq2ut: *mut fla_apcaq2ut_t,
    ) -> *mut fla_caqrutinc_t;
    pub fn FLA_Cntl_apcaqutinc_obj_create(
        matrix_type: FLA_Matrix_type,
        variant: c_int,
        blocksize: *mut fla_blocksize_t,
        sub_apcaq2ut: *mut fla_apcaq2ut_t,
    ) -> *mut fla_apcaqutinc_t;
    pub fn FLA_Cntl_uddateut_obj_create(
        matrix_type: FLA_Matrix_type,
        variant: c_int,
        blocksize: *mut fla_blocksize_t,
        sub_uddateut: *mut fla_uddateut_t,
        sub_apqudut: *mut fla_apqudut_t,
    ) -> *mut fla_uddateut_t;
    pub fn FLA_Cntl_apqudut_obj_create(
        matrix_type: FLA_Matrix_type,
        variant: c_int,
        blocksize: *mut fla_blocksize_t,
        sub_apq2ut: *mut fla_apqudut_t,
        sub_gemm1: *mut fla_gemm_t,
        sub_gemm2: *mut fla_gemm_t,
        sub_gemm3: *mut fla_gemm_t,
        sub_gemm4: *mut fla_gemm_t,
        sub_trsm: *mut fla_trsm_t,
        sub_copyt: *mut fla_copyt_t,
        sub_axpyt: *mut fla_axpyt_t,
    ) -> *mut fla_apqudut_t;
    pub fn FLA_Cntl_uddateutinc_obj_create(
        matrix_type: FLA_Matrix_type,
        variant: c_int,
        blocksize: *mut fla_blocksize_t,
        sub_uddateut: *mut fla_uddateut_t,
        sub_apqudut: *mut fla_apqudut_t,
    ) -> *mut fla_uddateutinc_t;
    pub fn FLA_Cntl_apqudutinc_obj_create(
        matrix_type: FLA_Matrix_type,
        variant: c_int,
        blocksize: *mut fla_blocksize_t,
        sub_apqudut: *mut fla_apqudut_t,
    ) -> *mut fla_apqudutinc_t;
    pub fn FLA_Cntl_eig_gest_obj_create(
        matrix_type: FLA_Matrix_type,
        variant: c_int,
        blocksize: *mut fla_blocksize_t,
        sub_eig_gest: *mut fla_eig_gest_t,
        sub_axpy1: *mut fla_axpy_t,
        sub_axpy2: *mut fla_axpy_t,
        sub_gemm1: *mut fla_gemm_t,
        sub_gemm2: *mut fla_gemm_t,
        sub_gemm3: *mut fla_gemm_t,
        sub_hemm: *mut fla_hemm_t,
        sub_her2k: *mut fla_her2k_t,
        sub_trmm1: *mut fla_trmm_t,
        sub_trmm2: *mut fla_trmm_t,
        sub_trsm1: *mut fla_trsm_t,
        sub_trsm2: *mut fla_trsm_t,
    ) -> *mut fla_eig_gest_t;
    pub fn FLA_Cntl_init_flamec();
    pub fn FLA_Cntl_finalize_flamec();
    pub fn FLA_Transpose_cntl_init();
    pub fn FLA_Transpose_cntl_finalize();
    pub fn FLA_Axpy_cntl_init();
    pub fn FLA_Axpyt_cntl_init();
    pub fn FLA_Copy_cntl_init();
    pub fn FLA_Copyt_cntl_init();
    pub fn FLA_Copyr_cntl_init();
    pub fn FLA_Scal_cntl_init();
    pub fn FLA_Scalr_cntl_init();
    pub fn FLA_Axpy_cntl_finalize();
    pub fn FLA_Axpyt_cntl_finalize();
    pub fn FLA_Copy_cntl_finalize();
    pub fn FLA_Copyt_cntl_finalize();
    pub fn FLA_Copyr_cntl_finalize();
    pub fn FLA_Scal_cntl_finalize();
    pub fn FLA_Scalr_cntl_finalize();
    pub fn FLA_Gemv_cntl_init();
    pub fn FLA_Trsv_cntl_init();
    pub fn FLA_Gemv_cntl_finalize();
    pub fn FLA_Trsv_cntl_finalize();
    pub fn FLA_Gemm_cntl_init();
    pub fn FLA_Hemm_cntl_init();
    pub fn FLA_Herk_cntl_init();
    pub fn FLA_Her2k_cntl_init();
    pub fn FLA_Symm_cntl_init();
    pub fn FLA_Syrk_cntl_init();
    pub fn FLA_Syr2k_cntl_init();
    pub fn FLA_Trmm_cntl_init();
    pub fn FLA_Trsm_cntl_init();
    pub fn FLA_Gemm_cntl_finalize();
    pub fn FLA_Hemm_cntl_finalize();
    pub fn FLA_Herk_cntl_finalize();
    pub fn FLA_Her2k_cntl_finalize();
    pub fn FLA_Symm_cntl_finalize();
    pub fn FLA_Syrk_cntl_finalize();
    pub fn FLA_Syr2k_cntl_finalize();
    pub fn FLA_Trmm_cntl_finalize();
    pub fn FLA_Trsm_cntl_finalize();
    pub fn FLA_Apply_pivots_cntl_init();
    pub fn FLA_Chol_cntl_init();
    pub fn FLA_LU_piv_cntl_init();
    pub fn FLA_LU_nopiv_cntl_init();
    pub fn FLA_QR_UT_cntl_init();
    pub fn FLA_QR2_UT_cntl_init();
    pub fn FLA_LQ_UT_cntl_init();
    pub fn FLA_CAQR2_UT_cntl_init();
    pub fn FLA_UDdate_UT_cntl_init();
    pub fn FLA_Hess_UT_cntl_init();
    pub fn FLA_Tridiag_UT_cntl_init();
    pub fn FLA_Bidiag_UT_cntl_init();
    pub fn FLA_Trinv_cntl_init();
    pub fn FLA_Ttmm_cntl_init();
    pub fn FLA_Sylv_cntl_init();
    pub fn FLA_Lyap_cntl_init();
    pub fn FLA_SPDinv_cntl_init();
    pub fn FLA_Apply_Q_UT_cntl_init();
    pub fn FLA_Apply_Q2_UT_cntl_init();
    pub fn FLA_Apply_CAQ2_UT_cntl_init();
    pub fn FLA_Apply_QUD_UT_cntl_init();
    pub fn FLA_Eig_gest_cntl_init();
    pub fn FLA_Apply_pivots_cntl_finalize();
    pub fn FLA_Chol_cntl_finalize();
    pub fn FLA_LU_piv_cntl_finalize();
    pub fn FLA_LU_nopiv_cntl_finalize();
    pub fn FLA_QR_UT_cntl_finalize();
    pub fn FLA_QR2_UT_cntl_finalize();
    pub fn FLA_LQ_UT_cntl_finalize();
    pub fn FLA_CAQR2_UT_cntl_finalize();
    pub fn FLA_UDdate_UT_cntl_finalize();
    pub fn FLA_Hess_UT_cntl_finalize();
    pub fn FLA_Tridiag_UT_cntl_finalize();
    pub fn FLA_Bidiag_UT_cntl_finalize();
    pub fn FLA_Trinv_cntl_finalize();
    pub fn FLA_Ttmm_cntl_finalize();
    pub fn FLA_Sylv_cntl_finalize();
    pub fn FLA_Lyap_cntl_finalize();
    pub fn FLA_SPDinv_cntl_finalize();
    pub fn FLA_Apply_Q_UT_cntl_finalize();
    pub fn FLA_Apply_Q2_UT_cntl_finalize();
    pub fn FLA_Apply_CAQ2_UT_cntl_finalize();
    pub fn FLA_Apply_QUD_UT_cntl_finalize();
    pub fn FLA_Eig_gest_cntl_finalize();
    pub fn FLA_Cntl_init_flash();
    pub fn FLA_Cntl_finalize_flash();
    pub fn FLASH_Transpose_cntl_init();
    pub fn FLASH_Transpose_cntl_finalize();
    pub fn FLASH_Axpy_cntl_init();
    pub fn FLASH_Axpyt_cntl_init();
    pub fn FLASH_Copy_cntl_init();
    pub fn FLASH_Copyt_cntl_init();
    pub fn FLASH_Copyr_cntl_init();
    pub fn FLASH_Scal_cntl_init();
    pub fn FLASH_Scalr_cntl_init();
    pub fn FLASH_Axpy_cntl_finalize();
    pub fn FLASH_Axpyt_cntl_finalize();
    pub fn FLASH_Copy_cntl_finalize();
    pub fn FLASH_Copyt_cntl_finalize();
    pub fn FLASH_Copyr_cntl_finalize();
    pub fn FLASH_Scal_cntl_finalize();
    pub fn FLASH_Scalr_cntl_finalize();
    pub fn FLASH_Gemv_cntl_init();
    pub fn FLASH_Trsv_cntl_init();
    pub fn FLASH_Gemv_cntl_finalize();
    pub fn FLASH_Trsv_cntl_finalize();
    pub fn FLASH_Gemm_cntl_init();
    pub fn FLASH_Hemm_cntl_init();
    pub fn FLASH_Herk_cntl_init();
    pub fn FLASH_Her2k_cntl_init();
    pub fn FLASH_Symm_cntl_init();
    pub fn FLASH_Syrk_cntl_init();
    pub fn FLASH_Syr2k_cntl_init();
    pub fn FLASH_Trmm_cntl_init();
    pub fn FLASH_Trsm_cntl_init();
    pub fn FLASH_Gemm_cntl_finalize();
    pub fn FLASH_Hemm_cntl_finalize();
    pub fn FLASH_Herk_cntl_finalize();
    pub fn FLASH_Her2k_cntl_finalize();
    pub fn FLASH_Symm_cntl_finalize();
    pub fn FLASH_Syrk_cntl_finalize();
    pub fn FLASH_Syr2k_cntl_finalize();
    pub fn FLASH_Trmm_cntl_finalize();
    pub fn FLASH_Trsm_cntl_finalize();
    pub fn FLASH_Apply_pivots_cntl_init();
    pub fn FLASH_Chol_cntl_init();
    pub fn FLASH_LU_nopiv_cntl_init();
    pub fn FLASH_LU_piv_cntl_init();
    pub fn FLASH_LU_incpiv_cntl_init();
    pub fn FLASH_Trinv_cntl_init();
    pub fn FLASH_Ttmm_cntl_init();
    pub fn FLASH_SPDinv_cntl_init();
    pub fn FLASH_Sylv_cntl_init();
    pub fn FLASH_Lyap_cntl_init();
    pub fn FLASH_QR_UT_cntl_init();
    pub fn FLASH_QR2_UT_cntl_init();
    pub fn FLASH_LQ_UT_cntl_init();
    pub fn FLASH_CAQR2_UT_cntl_init();
    pub fn FLASH_UDdate_UT_cntl_init();
    pub fn FLASH_QR_UT_inc_cntl_init();
    pub fn FLASH_CAQR_UT_inc_cntl_init();
    pub fn FLASH_UDdate_UT_inc_cntl_init();
    pub fn FLASH_Apply_Q_UT_cntl_init();
    pub fn FLASH_Apply_Q2_UT_cntl_init();
    pub fn FLASH_Apply_CAQ2_UT_cntl_init();
    pub fn FLASH_Apply_QUD_UT_cntl_init();
    pub fn FLASH_Apply_Q_UT_inc_cntl_init();
    pub fn FLASH_Apply_CAQ_UT_inc_cntl_init();
    pub fn FLASH_Apply_QUD_UT_inc_cntl_init();
    pub fn FLASH_Eig_gest_cntl_init();
    pub fn FLASH_Apply_pivots_cntl_finalize();
    pub fn FLASH_Chol_cntl_finalize();
    pub fn FLASH_LU_nopiv_cntl_finalize();
    pub fn FLASH_LU_piv_cntl_finalize();
    pub fn FLASH_LU_incpiv_cntl_finalize();
    pub fn FLASH_Trinv_cntl_finalize();
    pub fn FLASH_Ttmm_cntl_finalize();
    pub fn FLASH_SPDinv_cntl_finalize();
    pub fn FLASH_Sylv_cntl_finalize();
    pub fn FLASH_Lyap_cntl_finalize();
    pub fn FLASH_QR_UT_cntl_finalize();
    pub fn FLASH_QR2_UT_cntl_finalize();
    pub fn FLASH_LQ_UT_cntl_finalize();
    pub fn FLASH_CAQR2_UT_cntl_finalize();
    pub fn FLASH_UDdate_UT_cntl_finalize();
    pub fn FLASH_QR_UT_inc_cntl_finalize();
    pub fn FLASH_CAQR_UT_inc_cntl_finalize();
    pub fn FLASH_UDdate_UT_inc_cntl_finalize();
    pub fn FLASH_Apply_Q_UT_cntl_finalize();
    pub fn FLASH_Apply_Q2_UT_cntl_finalize();
    pub fn FLASH_Apply_CAQ2_UT_cntl_finalize();
    pub fn FLASH_Apply_QUD_UT_cntl_finalize();
    pub fn FLASH_Apply_Q_UT_inc_cntl_finalize();
    pub fn FLASH_Apply_CAQ_UT_inc_cntl_finalize();
    pub fn FLASH_Apply_QUD_UT_inc_cntl_finalize();
    pub fn FLASH_Eig_gest_cntl_finalize();
    pub fn FLA_Cntl_init();
    pub fn FLA_Cntl_finalize();
    pub fn FLA_Blocksize_create(
        b_s: fla_dim_t,
        b_d: fla_dim_t,
        b_c: fla_dim_t,
        b_z: fla_dim_t,
    ) -> *mut fla_blocksize_t;
    pub fn FLA_Blocksize_create_copy(bp: *mut fla_blocksize_t) -> *mut fla_blocksize_t;
    pub fn FLA_Blocksize_set(
        bp: *mut fla_blocksize_t,
        b_s: fla_dim_t,
        b_d: fla_dim_t,
        b_c: fla_dim_t,
        b_z: fla_dim_t,
    );
    pub fn FLA_Blocksize_scale(bp: *mut fla_blocksize_t, factor: f64);
    pub fn FLA_Blocksize_free(bp: *mut fla_blocksize_t);
    pub fn FLA_Blocksize_extract(dt: FLA_Datatype, bp: *mut fla_blocksize_t) -> fla_dim_t;
    pub fn FLA_Query_blocksizes(dim: FLA_Dimension) -> *mut fla_blocksize_t;
    pub fn FLA_Query_blocksize(dt: FLA_Datatype, dim: FLA_Dimension) -> fla_dim_t;
    pub fn FLA_Determine_blocksize(
        A_unproc: FLA_Obj,
        to_dir: FLA_Quadrant,
        cntl_blocksizes: *mut fla_blocksize_t,
    ) -> fla_dim_t;
    pub fn FLA_determine_matrix_size(A_unproc: FLA_Obj, to_dir: FLA_Quadrant) -> fla_dim_t;
    pub fn FLA_Check_error_level() -> c_uint;
    pub fn FLA_Check_error_level_set(level: c_uint) -> c_uint;
    pub fn FLA_Check_error_code_helper(
        code: c_int,
        file: *mut c_char,
        line: c_int,
    ) -> FLA_Error;
    pub fn FLA_Check_valid_side(side: FLA_Side) -> FLA_Error;
    pub fn FLA_Check_valid_uplo(uplo: FLA_Uplo) -> FLA_Error;
    pub fn FLA_Check_valid_trans(trans: FLA_Trans) -> FLA_Error;
    pub fn FLA_Check_valid_diag(diag: FLA_Diag) -> FLA_Error;
    pub fn FLA_Check_valid_conj(conj: FLA_Conj) -> FLA_Error;
    pub fn FLA_Check_valid_direct(direct: FLA_Conj) -> FLA_Error;
    pub fn FLA_Check_valid_storev(storev: FLA_Conj) -> FLA_Error;
    pub fn FLA_Check_valid_inverse(inv: FLA_Inv) -> FLA_Error;
    pub fn FLA_Check_valid_datatype(datatype: FLA_Datatype) -> FLA_Error;
    pub fn FLA_Check_valid_object_datatype(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Check_valid_evd_type(evd_type: FLA_Evd_type) -> FLA_Error;
    pub fn FLA_Check_valid_svd_type(svd_type: FLA_Svd_type) -> FLA_Error;
    pub fn FLA_Check_valid_svd_type_combination(
        svd_type_u: FLA_Svd_type,
        svd_type_v: FLA_Svd_type,
    ) -> FLA_Error;
    pub fn FLA_Check_valid_svd_type_and_trans_combination(
        svd_type_u: FLA_Svd_type,
        transu: FLA_Trans,
        svd_type_v: FLA_Svd_type,
        transv: FLA_Trans,
    ) -> FLA_Error;
    pub fn FLA_Check_floating_datatype(datatype: FLA_Datatype) -> FLA_Error;
    pub fn FLA_Check_int_datatype(datatype: FLA_Datatype) -> FLA_Error;
    pub fn FLA_Check_real_datatype(datatype: FLA_Datatype) -> FLA_Error;
    pub fn FLA_Check_complex_datatype(datatype: FLA_Datatype) -> FLA_Error;
    pub fn FLA_Check_floating_object(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Check_int_object(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Check_real_object(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Check_comparable_object(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Check_complex_object(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Check_consistent_datatype(datatype: FLA_Datatype, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Check_consistent_object_datatype(A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Check_identical_object_precision(A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Check_square(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Check_if_scalar(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Check_if_vector(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Check_conformal_dims(trans: FLA_Trans, A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Check_matrix_matrix_dims(
        transa: FLA_Trans,
        transb: FLA_Trans,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Check_matrix_vector_dims(
        trans: FLA_Trans,
        A: FLA_Obj,
        x: FLA_Obj,
        y: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Check_equal_vector_dims(x: FLA_Obj, y: FLA_Obj) -> FLA_Error;
    pub fn FLA_Check_conj1_trans_and_datatype(trans: FLA_Trans, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Check_hess_indices(
        A: FLA_Obj,
        ilo: c_int,
        ihi: c_int,
    ) -> FLA_Error;
    pub fn FLA_Check_null_pointer(ptr: *mut c_void) -> FLA_Error;
    pub fn FLA_Check_object_dims(
        trans: FLA_Trans,
        m: fla_dim_t,
        n: fla_dim_t,
        A: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Check_valid_pivot_type(ptype: FLA_Pivot_type) -> FLA_Error;
    pub fn FLA_Check_malloc_pointer(ptr: *mut c_void) -> FLA_Error;
    pub fn FLA_Check_base_buffer_mismatch(A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Check_adjacent_objects_2x2(
        A11: FLA_Obj,
        A12: FLA_Obj,
        A21: FLA_Obj,
        A22: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Check_adjacent_objects_2x1(AT: FLA_Obj, AB: FLA_Obj) -> FLA_Error;
    pub fn FLA_Check_adjacent_objects_1x2(AL: FLA_Obj, AR: FLA_Obj) -> FLA_Error;
    pub fn FLA_Check_blocksize_value(b: fla_dim_t) -> FLA_Error;
    pub fn FLA_Check_blocksize_object(
        datatype: FLA_Datatype,
        bp: *mut fla_blocksize_t,
    ) -> FLA_Error;
    pub fn FLA_Check_file_descriptor(fd: c_int) -> FLA_Error;
    pub fn FLA_Check_lseek_result(
        requested_offset: c_int,
        lseek_r_val: c_int,
    ) -> FLA_Error;
    pub fn FLA_Check_close_result(close_r_val: c_int) -> FLA_Error;
    pub fn FLA_Check_unlink_result(unlink_r_val: c_int) -> FLA_Error;
    pub fn FLA_Check_read_result(
        requested_size: c_int,
        read_r_val: c_int,
    ) -> FLA_Error;
    pub fn FLA_Check_write_result(
        requested_size: c_int,
        write_r_val: c_int,
    ) -> FLA_Error;
    pub fn FLA_Check_valid_quadrant(quad: FLA_Quadrant) -> FLA_Error;
    pub fn FLA_Check_vector_dim_min(x: FLA_Obj, min_dim: fla_dim_t) -> FLA_Error;
    pub fn FLA_Check_pthread_create_result(pthread_create_r_val: c_int) -> FLA_Error;
    pub fn FLA_Check_pthread_join_result(pthread_join_r_val: c_int) -> FLA_Error;
    pub fn FLA_Check_valid_isgn_value(isgn: FLA_Obj) -> FLA_Error;
    pub fn FLA_Check_sylv_matrix_dims(A: FLA_Obj, B: FLA_Obj, C: FLA_Obj) -> FLA_Error;
    pub fn FLA_Check_chol_failure(r_val: FLA_Error) -> FLA_Error;
    pub fn FLA_Check_valid_elemtype(elemtype: FLA_Elemtype) -> FLA_Error;
    pub fn FLA_Check_posix_memalign_failure(r_val: c_int) -> FLA_Error;
    pub fn FLA_Check_submatrix_dims_and_offset(
        m: fla_dim_t,
        n: fla_dim_t,
        i: fla_dim_t,
        j: fla_dim_t,
        A: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Check_object_scalar_elemtype(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Check_object_matrix_elemtype(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Check_num_threads(n_threads: c_uint) -> FLA_Error;
    pub fn FLA_Check_conj_and_datatype(conj: FLA_Conj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Check_valid_complex_trans(trans: FLA_Trans) -> FLA_Error;
    pub fn FLA_Check_valid_real_trans(trans: FLA_Trans) -> FLA_Error;
    pub fn FLA_Check_valid_blas_trans(trans: FLA_Trans) -> FLA_Error;
    pub fn FLA_Check_nonconstant_datatype(datatype: FLA_Datatype) -> FLA_Error;
    pub fn FLA_Check_nonconstant_object(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Check_identical_object_datatype(A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Check_divide_by_zero(alpha: FLA_Obj) -> FLA_Error;
    pub fn FLA_Check_identical_object_elemtype(A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Check_pivot_index_range(p: FLA_Obj, k1: fla_dim_t, k2: fla_dim_t) -> FLA_Error;
    pub fn FLA_Check_householder_panel_dims(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Check_object_length_equals(A: FLA_Obj, m: fla_dim_t) -> FLA_Error;
    pub fn FLA_Check_object_width_equals(A: FLA_Obj, n: fla_dim_t) -> FLA_Error;
    pub fn FLA_Check_object_length_min(A: FLA_Obj, m: fla_dim_t) -> FLA_Error;
    pub fn FLA_Check_object_width_min(A: FLA_Obj, n: fla_dim_t) -> FLA_Error;
    pub fn FLA_Check_valid_error_level(level: c_uint) -> FLA_Error;
    pub fn FLA_Check_attempted_repart_2x2(
        A_quad: FLA_Obj,
        b_m: fla_dim_t,
        b_n: fla_dim_t,
    ) -> FLA_Error;
    pub fn FLA_Check_attempted_repart_2x1(A_side: FLA_Obj, b_m: fla_dim_t) -> FLA_Error;
    pub fn FLA_Check_attempted_repart_1x2(A_side: FLA_Obj, b_n: fla_dim_t) -> FLA_Error;
    pub fn FLA_Check_valid_leftright_side(side: FLA_Side) -> FLA_Error;
    pub fn FLA_Check_valid_topbottom_side(side: FLA_Side) -> FLA_Error;
    pub fn FLA_Check_matrix_strides(
        m: fla_dim_t,
        n: fla_dim_t,
        rs: fla_dim_t,
        cs: fla_dim_t,
    ) -> FLA_Error;
    pub fn FLA_Check_vector_dim(x: FLA_Obj, expected_length: fla_dim_t) -> FLA_Error;
    pub fn FLA_Check_row_vector(x: FLA_Obj) -> FLA_Error;
    pub fn FLA_Check_col_vector(x: FLA_Obj) -> FLA_Error;
    pub fn FLA_Check_valid_machval(val: FLA_Machval) -> FLA_Error;
    pub fn FLA_Check_valid_diag_offset(A: FLA_Obj, offset: FLA_Diag_off) -> FLA_Error;
    pub fn FLA_Check_col_storage(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Check_row_storage(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Error_string_for_code(code: c_int) -> *mut c_char;
    pub fn FLA_Error_messages_init();
    pub fn FLA_Print_message(
        str_: *mut c_char,
        file: *mut c_char,
        line: c_int,
    );
    pub fn FLA_Abort();
    pub fn FLA_Init();
    pub fn FLA_Finalize();
    pub fn FLA_Initialized() -> FLA_Bool;
    pub fn FLA_Init_safe(init_result: *mut FLA_Error);
    pub fn FLA_Finalize_safe(init_result: FLA_Error);
    pub fn FLA_Init_constants();
    pub fn FLA_Finalize_constants();
    pub fn FLA_Init_numerical_constants();
    pub fn FLA_Finalize_numerical_constants();
    pub fn FLA_Get_AOCL_Version() -> *mut c_char;
    pub fn FLA_Lock_init(fla_lock_ptr: *mut FLA_Lock);
    pub fn FLA_Lock_destroy(fla_lock_ptr: *mut FLA_Lock);
    pub fn FLA_Lock_acquire(fla_lock_ptr: *mut FLA_Lock);
    pub fn FLA_Lock_release(fla_lock_ptr: *mut FLA_Lock);
    pub fn FLA_Memory_leak_counter_init();
    pub fn FLA_Memory_leak_counter_finalize();
    pub fn FLA_Memory_leak_counter_status() -> FLA_Bool;
    pub fn FLA_Memory_leak_counter_set(new_status: FLA_Bool) -> FLA_Bool;
    pub fn FLA_malloc(size: usize) -> *mut c_void;
    pub fn FLA_realloc(old_ptr: *mut c_void, size: usize) -> *mut c_void;
    pub fn FLA_free(ptr: *mut c_void);
    pub fn FLA_Obj_copy_view(A: FLA_Obj, B: *mut FLA_Obj) -> FLA_Error;
    pub fn FLA_Obj_extract_real_scalar(alpha: FLA_Obj, alpha_value: *mut f64);
    pub fn FLA_Obj_extract_complex_scalar(alpha: FLA_Obj, alpha_value: *mut dcomplex);
    pub fn FLA_Obj_extract_real_part(alpha: FLA_Obj, beta: FLA_Obj);
    pub fn FLA_Obj_extract_imag_part(alpha: FLA_Obj, beta: FLA_Obj);
    pub fn FLA_Obj_set_real_part(alpha: FLA_Obj, beta: FLA_Obj);
    pub fn FLA_Obj_set_imag_part(alpha: FLA_Obj, beta: FLA_Obj);
    pub fn FLA_Obj_show(
        s1: *mut c_char,
        A: FLA_Obj,
        format: *mut c_char,
        s2: *mut c_char,
    ) -> FLA_Error;
    pub fn FLA_Obj_fshow(
        file: *mut FILE,
        s1: *mut c_char,
        A: FLA_Obj,
        format: *mut c_char,
        s2: *mut c_char,
    ) -> FLA_Error;
    pub fn FLA_Obj_copy_view_check(A: FLA_Obj, B: *mut FLA_Obj) -> FLA_Error;
    pub fn FLA_Obj_extract_real_scalar_check(alpha: FLA_Obj, alpha_value: *mut f64) -> FLA_Error;
    pub fn FLA_Obj_extract_complex_scalar_check(
        alpha: FLA_Obj,
        alpha_value: *mut dcomplex,
    ) -> FLA_Error;
    pub fn FLA_Obj_extract_real_part_check(alpha: FLA_Obj, beta: FLA_Obj) -> FLA_Error;
    pub fn FLA_Obj_extract_imag_part_check(alpha: FLA_Obj, beta: FLA_Obj) -> FLA_Error;
    pub fn FLA_Obj_set_real_part_check(alpha: FLA_Obj, beta: FLA_Obj) -> FLA_Error;
    pub fn FLA_Obj_set_imag_part_check(alpha: FLA_Obj, beta: FLA_Obj) -> FLA_Error;
    pub fn FLA_Obj_show_check(
        s1: *mut c_char,
        obj: FLA_Obj,
        format: *mut c_char,
        s2: *mut c_char,
    ) -> FLA_Error;
    pub fn FLA_Obj_fshow_check(
        file: *mut FILE,
        s1: *mut c_char,
        obj: FLA_Obj,
        format: *mut c_char,
        s2: *mut c_char,
    ) -> FLA_Error;
    pub fn FLA_Copy_buffer_to_object(
        trans: FLA_Trans,
        m: fla_dim_t,
        n: fla_dim_t,
        buffer: *mut c_void,
        rs: fla_dim_t,
        cs: fla_dim_t,
        i: fla_dim_t,
        j: fla_dim_t,
        obj: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Copy_object_to_buffer(
        trans: FLA_Trans,
        i: fla_dim_t,
        j: fla_dim_t,
        obj: FLA_Obj,
        m: fla_dim_t,
        n: fla_dim_t,
        buffer: *mut c_void,
        rs: fla_dim_t,
        cs: fla_dim_t,
    ) -> FLA_Error;
    pub fn FLA_Copy_buffer_to_object_check(
        trans: FLA_Trans,
        m: fla_dim_t,
        n: fla_dim_t,
        buffer: *mut c_void,
        rs: fla_dim_t,
        cs: fla_dim_t,
        i: fla_dim_t,
        j: fla_dim_t,
        obj: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Copy_object_to_buffer_check(
        trans: FLA_Trans,
        i: fla_dim_t,
        j: fla_dim_t,
        obj: FLA_Obj,
        m: fla_dim_t,
        n: fla_dim_t,
        buffer: *mut c_void,
        rs: fla_dim_t,
        cs: fla_dim_t,
    ) -> FLA_Error;
    pub fn FLA_Axpy_buffer_to_object(
        trans: FLA_Trans,
        alpha: FLA_Obj,
        m: fla_dim_t,
        n: fla_dim_t,
        buffer: *mut c_void,
        rs: fla_dim_t,
        cs: fla_dim_t,
        i: fla_dim_t,
        j: fla_dim_t,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Axpy_object_to_buffer(
        trans: FLA_Trans,
        alpha: FLA_Obj,
        i: fla_dim_t,
        j: fla_dim_t,
        C: FLA_Obj,
        m: fla_dim_t,
        n: fla_dim_t,
        buffer: *mut c_void,
        rs: fla_dim_t,
        cs: fla_dim_t,
    ) -> FLA_Error;
    pub fn FLA_Axpy_buffer_to_object_check(
        trans: FLA_Trans,
        alpha: FLA_Obj,
        m: fla_dim_t,
        n: fla_dim_t,
        buffer: *mut c_void,
        rs: fla_dim_t,
        cs: fla_dim_t,
        i: fla_dim_t,
        j: fla_dim_t,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Axpy_object_to_buffer_check(
        trans: FLA_Trans,
        alpha: FLA_Obj,
        i: fla_dim_t,
        j: fla_dim_t,
        C: FLA_Obj,
        m: fla_dim_t,
        n: fla_dim_t,
        buffer: *mut c_void,
        rs: fla_dim_t,
        cs: fla_dim_t,
    ) -> FLA_Error;
    pub fn FLA_Obj_nullify(obj: *mut FLA_Obj) -> FLA_Error;
    pub fn FLA_Obj_create(
        datatype: FLA_Datatype,
        m: fla_dim_t,
        n: fla_dim_t,
        rs: fla_dim_t,
        cs: fla_dim_t,
        obj: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Obj_create_ext(
        datatype: FLA_Datatype,
        elemtype: FLA_Elemtype,
        m: fla_dim_t,
        n: fla_dim_t,
        m_inner: fla_dim_t,
        n_inner: fla_dim_t,
        rs: fla_dim_t,
        cs: fla_dim_t,
        obj: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Obj_create_conf_to(trans: FLA_Trans, old: FLA_Obj, obj: *mut FLA_Obj) -> FLA_Error;
    pub fn FLA_Obj_create_copy_of(trans: FLA_Trans, old: FLA_Obj, obj: *mut FLA_Obj) -> FLA_Error;
    pub fn FLA_Obj_create_without_buffer(
        datatype: FLA_Datatype,
        m: fla_dim_t,
        n: fla_dim_t,
        obj: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Obj_create_constant(const_real: f64, obj: *mut FLA_Obj) -> FLA_Error;
    pub fn FLA_Obj_create_constant_ext(const_s: f32, const_d: f64, obj: *mut FLA_Obj) -> FLA_Error;
    pub fn FLA_Obj_create_complex_constant(
        const_real: f64,
        const_imag: f64,
        obj: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Obj_attach_buffer(
        buffer: *mut c_void,
        rs: fla_dim_t,
        cs: fla_dim_t,
        obj: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Obj_create_buffer(rs: fla_dim_t, cs: fla_dim_t, obj: *mut FLA_Obj) -> FLA_Error;
    pub fn FLA_Obj_free(obj: *mut FLA_Obj) -> FLA_Error;
    pub fn FLA_Obj_free_without_buffer(obj: *mut FLA_Obj) -> FLA_Error;
    pub fn FLA_Obj_free_buffer(obj: *mut FLA_Obj) -> FLA_Error;
    pub fn FLA_align_ldim(ldim: fla_dim_t, elem_size: fla_dim_t) -> fla_dim_t;
    pub fn FLA_compute_num_elem(
        elem_size: fla_dim_t,
        m: fla_dim_t,
        n: fla_dim_t,
        rs: *mut fla_dim_t,
        cs: *mut fla_dim_t,
    ) -> fla_dim_t;
    pub fn FLA_adjust_strides(m: fla_dim_t, n: fla_dim_t, rs: *mut fla_dim_t, cs: *mut fla_dim_t);
    pub fn FLA_Obj_flip_base(obj: *mut FLA_Obj) -> FLA_Error;
    pub fn FLA_Obj_flip_view(obj: *mut FLA_Obj) -> FLA_Error;
    pub fn FLA_Obj_create_ext_check(
        datatype: FLA_Datatype,
        elemtype: FLA_Elemtype,
        m: fla_dim_t,
        n: fla_dim_t,
        m_inner: fla_dim_t,
        n_inner: fla_dim_t,
        rs: fla_dim_t,
        cs: fla_dim_t,
        obj: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Obj_create_conf_to_check(
        trans: FLA_Trans,
        obj_old: FLA_Obj,
        obj: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Obj_create_without_buffer_check(
        datatype: FLA_Datatype,
        m: fla_dim_t,
        n: fla_dim_t,
        obj: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Obj_create_constant_check(const_real: f64, obj: *mut FLA_Obj) -> FLA_Error;
    pub fn FLA_Obj_create_constant_ext_check(
        const_s: f32,
        const_d: f64,
        obj: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Obj_create_complex_constant_check(
        const_real: f64,
        const_imag: f64,
        obj: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Obj_attach_buffer_check(
        buffer: *mut c_void,
        rs: fla_dim_t,
        cs: fla_dim_t,
        obj: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Obj_create_buffer_check(
        rs: fla_dim_t,
        cs: fla_dim_t,
        obj: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Obj_free_check(obj: *mut FLA_Obj) -> FLA_Error;
    pub fn FLA_Obj_free_without_buffer_check(obj: *mut FLA_Obj) -> FLA_Error;
    pub fn FLA_Obj_free_buffer_check(obj: *mut FLA_Obj) -> FLA_Error;
    pub fn FLA_Obj_create_buffer_task(
        rs: fla_dim_t,
        cs: fla_dim_t,
        obj: FLA_Obj,
        cntl: *mut c_void,
    ) -> FLA_Error;
    pub fn FLA_Obj_free_buffer_task(obj: FLA_Obj, cntl: *mut c_void) -> FLA_Error;
    pub fn FLA_Obj_datatype(obj: FLA_Obj) -> FLA_Datatype;
    pub fn FLA_Obj_datatype_proj_to_real(A: FLA_Obj) -> FLA_Datatype;
    pub fn FLA_Obj_datatype_proj_to_complex(A: FLA_Obj) -> FLA_Datatype;
    pub fn FLA_Obj_elemtype(obj: FLA_Obj) -> FLA_Elemtype;
    pub fn FLA_Obj_datatype_size(datatype: FLA_Datatype) -> fla_dim_t;
    pub fn FLA_Obj_elem_size(obj: FLA_Obj) -> fla_dim_t;
    pub fn FLA_Obj_length(obj: FLA_Obj) -> fla_dim_t;
    pub fn FLA_Obj_width(obj: FLA_Obj) -> fla_dim_t;
    pub fn FLA_Obj_structure(obj: FLA_Obj) -> FLA_Uplo;
    pub fn FLA_Obj_vector_dim(obj: FLA_Obj) -> fla_dim_t;
    pub fn FLA_Obj_vector_inc(obj: FLA_Obj) -> fla_dim_t;
    pub fn FLA_Obj_min_dim(obj: FLA_Obj) -> fla_dim_t;
    pub fn FLA_Obj_max_dim(obj: FLA_Obj) -> fla_dim_t;
    pub fn FLA_Obj_row_stride(obj: FLA_Obj) -> fla_dim_t;
    pub fn FLA_Obj_col_stride(obj: FLA_Obj) -> fla_dim_t;
    pub fn FLA_Obj_row_offset(obj: FLA_Obj) -> fla_dim_t;
    pub fn FLA_Obj_col_offset(obj: FLA_Obj) -> fla_dim_t;
    pub fn FLA_Obj_base_length(obj: FLA_Obj) -> fla_dim_t;
    pub fn FLA_Obj_base_width(obj: FLA_Obj) -> fla_dim_t;
    pub fn FLA_Obj_num_elem_alloc(obj: FLA_Obj) -> fla_dim_t;
    pub fn FLA_Obj_base_buffer(obj: FLA_Obj) -> *mut c_void;
    pub fn FLA_Obj_buffer_at_view(obj: FLA_Obj) -> *mut c_void;
    pub fn FLA_Obj_buffer_is_null(obj: FLA_Obj) -> FLA_Bool;
    pub fn FLA_Obj_is_int(A: FLA_Obj) -> FLA_Bool;
    pub fn FLA_Obj_is_floating_point(A: FLA_Obj) -> FLA_Bool;
    pub fn FLA_Obj_is_constant(A: FLA_Obj) -> FLA_Bool;
    pub fn FLA_Obj_is_real(A: FLA_Obj) -> FLA_Bool;
    pub fn FLA_Obj_is_complex(A: FLA_Obj) -> FLA_Bool;
    pub fn FLA_Obj_is_single_precision(A: FLA_Obj) -> FLA_Bool;
    pub fn FLA_Obj_is_double_precision(A: FLA_Obj) -> FLA_Bool;
    pub fn FLA_Obj_is_scalar(A: FLA_Obj) -> FLA_Bool;
    pub fn FLA_Obj_is_vector(A: FLA_Obj) -> FLA_Bool;
    pub fn FLA_Obj_has_zero_dim(A: FLA_Obj) -> FLA_Bool;
    pub fn FLA_Obj_is_row_major(A: FLA_Obj) -> FLA_Bool;
    pub fn FLA_Obj_is_col_major(A: FLA_Obj) -> FLA_Bool;
    pub fn FLA_Obj_is_conformal_to(trans: FLA_Trans, A: FLA_Obj, B: FLA_Obj) -> FLA_Bool;
    pub fn FLA_Obj_is(A: FLA_Obj, B: FLA_Obj) -> FLA_Bool;
    pub fn FLA_Obj_is_identical(A: FLA_Obj, B: FLA_Obj) -> FLA_Bool;
    pub fn FLA_Obj_is_overlapped(A: FLA_Obj, B: FLA_Obj) -> FLA_Bool;
    pub fn FLA_Obj_equals(A: FLA_Obj, B: FLA_Obj) -> FLA_Bool;
    pub fn FLA_Obj_gt(A: FLA_Obj, B: FLA_Obj) -> FLA_Bool;
    pub fn FLA_Obj_ge(A: FLA_Obj, B: FLA_Obj) -> FLA_Bool;
    pub fn FLA_Obj_lt(A: FLA_Obj, B: FLA_Obj) -> FLA_Bool;
    pub fn FLA_Obj_le(A: FLA_Obj, B: FLA_Obj) -> FLA_Bool;
    pub fn FLA_Submatrix_at(
        datatype: FLA_Datatype,
        buffer: *mut c_void,
        i: fla_dim_t,
        j: fla_dim_t,
        rs: fla_dim_t,
        cs: fla_dim_t,
    ) -> *mut c_void;
    pub fn FLA_Obj_has_nan(A: FLA_Obj) -> FLA_Bool;
    pub fn FLA_Obj_datatype_check(obj: FLA_Obj) -> FLA_Error;
    pub fn FLA_Obj_datatype_proj_to_real_check(obj: FLA_Obj) -> FLA_Error;
    pub fn FLA_Obj_elemtype_check(obj: FLA_Obj) -> FLA_Error;
    pub fn FLA_Obj_datatype_size_check(datatype: FLA_Datatype) -> FLA_Error;
    pub fn FLA_Obj_elem_size_check(obj: FLA_Obj) -> FLA_Error;
    pub fn FLA_Obj_buffer_at_view_check(obj: FLA_Obj) -> FLA_Error;
    pub fn FLA_Obj_equals_check(A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Obj_gt_check(A: FLA_Obj, B: FLA_Obj) -> FLA_Bool;
    pub fn FLA_Obj_ge_check(A: FLA_Obj, B: FLA_Obj) -> FLA_Bool;
    pub fn FLA_Obj_lt_check(A: FLA_Obj, B: FLA_Obj) -> FLA_Bool;
    pub fn FLA_Obj_le_check(A: FLA_Obj, B: FLA_Obj) -> FLA_Bool;
    pub fn FLA_Submatrix_at_check(
        datatype: FLA_Datatype,
        buffer: *mut c_void,
        i: fla_dim_t,
        j: fla_dim_t,
        rs: fla_dim_t,
        cs: fla_dim_t,
    ) -> FLA_Error;
    pub fn FLA_Obj_has_nan_check(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Param_map_flame_to_netlib_trans(
        trans: FLA_Trans,
        blas_trans: *mut c_void,
    );
    pub fn FLA_Param_map_flame_to_netlib_uplo(uplo: FLA_Uplo, blas_uplo: *mut c_void);
    pub fn FLA_Param_map_flame_to_netlib_side(side: FLA_Uplo, blas_side: *mut c_void);
    pub fn FLA_Param_map_flame_to_netlib_diag(diag: FLA_Diag, blas_diag: *mut c_void);
    pub fn FLA_Param_map_flame_to_netlib_direct(
        direct: FLA_Direct,
        lapack_direct: *mut c_void,
    );
    pub fn FLA_Param_map_flame_to_netlib_storev(
        storev: FLA_Store,
        lapack_storev: *mut c_void,
    );
    pub fn FLA_Param_map_flame_to_netlib_evd_type(
        evd_type: FLA_Evd_type,
        lapack_evd_type: *mut c_void,
    );
    pub fn FLA_Param_map_flame_to_netlib_svd_type(
        svd_type: FLA_Svd_type,
        lapack_svd_type: *mut c_void,
    );
    pub fn FLA_Param_map_flame_to_netlib_machval(
        machval: FLA_Machval,
        blas_machval: *mut c_void,
    );
    pub fn FLA_Param_map_flame_to_blis_trans(trans: FLA_Trans, blis_trans: *mut trans1_t);
    pub fn FLA_Param_map_flame_to_blis_conj(conj: FLA_Conj, blis_conj: *mut conj1_t);
    pub fn FLA_Param_map_flame_to_blis_uplo(uplo: FLA_Uplo, blis_uplo: *mut uplo1_t);
    pub fn FLA_Param_map_flame_to_blis_side(side: FLA_Uplo, blis_side: *mut side1_t);
    pub fn FLA_Param_map_flame_to_blis_diag(diag: FLA_Diag, blis_diag: *mut diag1_t);
    pub fn FLA_Param_map_blis_to_flame_trans(trans: trans1_t, flame_trans: *mut FLA_Trans);
    pub fn FLA_Param_map_blis_to_flame_uplo(uplo: uplo1_t, flame_uplo: *mut FLA_Uplo);
    pub fn FLA_Param_map_blis_to_flame_side(side: side1_t, flame_side: *mut FLA_Side);
    pub fn FLA_Param_map_blis_to_flame_diag(diag: diag1_t, flame_diag: *mut FLA_Diag);
    pub fn FLA_Param_map_char_to_flame_trans(
        trans: *mut c_char,
        flame_trans: *mut FLA_Trans,
    );
    pub fn FLA_Param_map_char_to_flame_uplo(
        uplo: *mut c_char,
        flame_uplo: *mut FLA_Uplo,
    );
    pub fn FLA_Param_map_char_to_flame_side(
        side: *mut c_char,
        flame_side: *mut FLA_Side,
    );
    pub fn FLA_Param_map_char_to_flame_diag(
        diag: *mut c_char,
        flame_diag: *mut FLA_Diag,
    );
    pub fn FLA_Param_map_char_to_flame_storev(
        storev: *mut c_char,
        flame_storev: *mut FLA_Direct,
    );
    pub fn FLA_Param_map_char_to_flame_direct(
        direct: *mut c_char,
        flame_direct: *mut FLA_Direct,
    );
    pub fn FLA_Param_map_char_to_flame_inv(inv: *mut c_char, flame_inv: *mut FLA_Inv);
    pub fn FLA_Param_map_netlib_to_flame_trans(
        trans: *mut c_char,
        flame_trans: *mut FLA_Trans,
    );
    pub fn FLA_Param_map_netlib_to_flame_uplo(
        uplo: *mut c_char,
        flame_uplo: *mut FLA_Uplo,
    );
    pub fn FLA_Param_map_netlib_to_flame_side(
        side: *mut c_char,
        flame_side: *mut FLA_Side,
    );
    pub fn FLA_Param_map_netlib_to_flame_diag(
        diag: *mut c_char,
        flame_diag: *mut FLA_Diag,
    );
    pub fn FLA_Param_map_netlib_to_flame_inv(
        itype: *mut c_int,
        flame_inv: *mut FLA_Inv,
    );
    pub fn FLA_Param_map_netlib_to_flame_svd_type(
        svd: *mut c_char,
        flame_svd: *mut FLA_Svd_type,
    );
    pub fn FLA_Part_2x2(
        A: FLA_Obj,
        A11: *mut FLA_Obj,
        A12: *mut FLA_Obj,
        A21: *mut FLA_Obj,
        A22: *mut FLA_Obj,
        mb: fla_dim_t,
        nb: fla_dim_t,
        quadrant: FLA_Quadrant,
    ) -> FLA_Error;
    pub fn FLA_Part_2x1(
        A: FLA_Obj,
        A1: *mut FLA_Obj,
        A2: *mut FLA_Obj,
        mb: fla_dim_t,
        side: FLA_Side,
    ) -> FLA_Error;
    pub fn FLA_Part_1x2(
        A: FLA_Obj,
        A1: *mut FLA_Obj,
        A2: *mut FLA_Obj,
        nb: fla_dim_t,
        side: FLA_Side,
    ) -> FLA_Error;
    pub fn FLA_Merge_2x2(
        A11: FLA_Obj,
        A12: FLA_Obj,
        A21: FLA_Obj,
        A22: FLA_Obj,
        A: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Merge_2x1(AT: FLA_Obj, AB: FLA_Obj, A: *mut FLA_Obj) -> FLA_Error;
    pub fn FLA_Merge_1x2(AL: FLA_Obj, AR: FLA_Obj, A: *mut FLA_Obj) -> FLA_Error;
    pub fn FLA_Repart_2x2_to_3x3(
        ATL: FLA_Obj,
        ATR: FLA_Obj,
        A00: *mut FLA_Obj,
        A01: *mut FLA_Obj,
        A02: *mut FLA_Obj,
        A10: *mut FLA_Obj,
        A11: *mut FLA_Obj,
        A12: *mut FLA_Obj,
        ABL: FLA_Obj,
        ABR: FLA_Obj,
        A20: *mut FLA_Obj,
        A21: *mut FLA_Obj,
        A22: *mut FLA_Obj,
        mb: fla_dim_t,
        nb: fla_dim_t,
        quadrant: FLA_Quadrant,
    ) -> FLA_Error;
    pub fn FLA_Repart_2x1_to_3x1(
        AT: FLA_Obj,
        A0: *mut FLA_Obj,
        A1: *mut FLA_Obj,
        AB: FLA_Obj,
        A2: *mut FLA_Obj,
        mb: fla_dim_t,
        side: FLA_Side,
    ) -> FLA_Error;
    pub fn FLA_Repart_1x2_to_1x3(
        AL: FLA_Obj,
        AR: FLA_Obj,
        A0: *mut FLA_Obj,
        A1: *mut FLA_Obj,
        A2: *mut FLA_Obj,
        nb: fla_dim_t,
        side: FLA_Side,
    ) -> FLA_Error;
    pub fn FLA_Cont_with_3x3_to_2x2(
        ATL: *mut FLA_Obj,
        ATR: *mut FLA_Obj,
        A00: FLA_Obj,
        A01: FLA_Obj,
        A02: FLA_Obj,
        A10: FLA_Obj,
        A11: FLA_Obj,
        A12: FLA_Obj,
        ABL: *mut FLA_Obj,
        ABR: *mut FLA_Obj,
        A20: FLA_Obj,
        A21: FLA_Obj,
        A22: FLA_Obj,
        quadrant: FLA_Quadrant,
    ) -> FLA_Error;
    pub fn FLA_Cont_with_3x1_to_2x1(
        AT: *mut FLA_Obj,
        A0: FLA_Obj,
        A1: FLA_Obj,
        AB: *mut FLA_Obj,
        A2: FLA_Obj,
        side: FLA_Side,
    ) -> FLA_Error;
    pub fn FLA_Cont_with_1x3_to_1x2(
        AL: *mut FLA_Obj,
        AR: *mut FLA_Obj,
        A0: FLA_Obj,
        A1: FLA_Obj,
        A2: FLA_Obj,
        side: FLA_Side,
    ) -> FLA_Error;
    pub fn FLA_Repart_3x3_to_5x5(
        ATL: FLA_Obj,
        ATM: FLA_Obj,
        ATR: FLA_Obj,
        AML: FLA_Obj,
        AMM: FLA_Obj,
        AMR: FLA_Obj,
        ABL: FLA_Obj,
        ABM: FLA_Obj,
        ABR: FLA_Obj,
        A00: *mut FLA_Obj,
        A01: *mut FLA_Obj,
        A02: *mut FLA_Obj,
        A03: *mut FLA_Obj,
        A04: *mut FLA_Obj,
        A10: *mut FLA_Obj,
        A11: *mut FLA_Obj,
        A12: *mut FLA_Obj,
        A13: *mut FLA_Obj,
        A14: *mut FLA_Obj,
        A20: *mut FLA_Obj,
        A21: *mut FLA_Obj,
        A22: *mut FLA_Obj,
        A23: *mut FLA_Obj,
        A24: *mut FLA_Obj,
        A30: *mut FLA_Obj,
        A31: *mut FLA_Obj,
        A32: *mut FLA_Obj,
        A33: *mut FLA_Obj,
        A34: *mut FLA_Obj,
        A40: *mut FLA_Obj,
        A41: *mut FLA_Obj,
        A42: *mut FLA_Obj,
        A43: *mut FLA_Obj,
        A44: *mut FLA_Obj,
        b: fla_dim_t,
        quadrant: FLA_Quadrant,
    ) -> FLA_Error;
    pub fn FLA_Cont_with_5x5_to_3x3(
        ATL: *mut FLA_Obj,
        ATM: *mut FLA_Obj,
        ATR: *mut FLA_Obj,
        AML: *mut FLA_Obj,
        AMM: *mut FLA_Obj,
        AMR: *mut FLA_Obj,
        ABL: *mut FLA_Obj,
        ABM: *mut FLA_Obj,
        ABR: *mut FLA_Obj,
        A00: FLA_Obj,
        A01: FLA_Obj,
        A02: FLA_Obj,
        A03: FLA_Obj,
        A04: FLA_Obj,
        A10: FLA_Obj,
        A11: FLA_Obj,
        A12: FLA_Obj,
        A13: FLA_Obj,
        A14: FLA_Obj,
        A20: FLA_Obj,
        A21: FLA_Obj,
        A22: FLA_Obj,
        A23: FLA_Obj,
        A24: FLA_Obj,
        A30: FLA_Obj,
        A31: FLA_Obj,
        A32: FLA_Obj,
        A33: FLA_Obj,
        A34: FLA_Obj,
        A40: FLA_Obj,
        A41: FLA_Obj,
        A42: FLA_Obj,
        A43: FLA_Obj,
        A44: FLA_Obj,
        quadrant: FLA_Quadrant,
    ) -> FLA_Error;
    pub fn FLA_Part_2x2_check(
        A: FLA_Obj,
        A11: *mut FLA_Obj,
        A12: *mut FLA_Obj,
        A21: *mut FLA_Obj,
        A22: *mut FLA_Obj,
        mb: fla_dim_t,
        nb: fla_dim_t,
        quadrant: FLA_Quadrant,
    ) -> FLA_Error;
    pub fn FLA_Part_2x1_check(
        A: FLA_Obj,
        A1: *mut FLA_Obj,
        A2: *mut FLA_Obj,
        mb: fla_dim_t,
        side: FLA_Side,
    ) -> FLA_Error;
    pub fn FLA_Part_1x2_check(
        A: FLA_Obj,
        A1: *mut FLA_Obj,
        A2: *mut FLA_Obj,
        nb: fla_dim_t,
        side: FLA_Side,
    ) -> FLA_Error;
    pub fn FLA_Merge_2x2_check(
        A11: FLA_Obj,
        A12: FLA_Obj,
        A21: FLA_Obj,
        A22: FLA_Obj,
        A: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Merge_2x1_check(AT: FLA_Obj, AB: FLA_Obj, A: *mut FLA_Obj) -> FLA_Error;
    pub fn FLA_Merge_1x2_check(AL: FLA_Obj, AR: FLA_Obj, A: *mut FLA_Obj) -> FLA_Error;
    pub fn FLA_Repart_2x2_to_3x3_check(
        ATL: FLA_Obj,
        ATR: FLA_Obj,
        A00: *mut FLA_Obj,
        A01: *mut FLA_Obj,
        A02: *mut FLA_Obj,
        A10: *mut FLA_Obj,
        A11: *mut FLA_Obj,
        A12: *mut FLA_Obj,
        ABL: FLA_Obj,
        ABR: FLA_Obj,
        A20: *mut FLA_Obj,
        A21: *mut FLA_Obj,
        A22: *mut FLA_Obj,
        mb: fla_dim_t,
        nb: fla_dim_t,
        quadrant: FLA_Quadrant,
    ) -> FLA_Error;
    pub fn FLA_Repart_2x1_to_3x1_check(
        AT: FLA_Obj,
        A0: *mut FLA_Obj,
        A1: *mut FLA_Obj,
        AB: FLA_Obj,
        A2: *mut FLA_Obj,
        mb: fla_dim_t,
        side: FLA_Side,
    ) -> FLA_Error;
    pub fn FLA_Repart_1x2_to_1x3_check(
        AL: FLA_Obj,
        AR: FLA_Obj,
        A0: *mut FLA_Obj,
        A1: *mut FLA_Obj,
        A2: *mut FLA_Obj,
        nb: fla_dim_t,
        side: FLA_Side,
    ) -> FLA_Error;
    pub fn FLA_Cont_with_3x3_to_2x2_check(
        ATL: *mut FLA_Obj,
        ATR: *mut FLA_Obj,
        A00: FLA_Obj,
        A01: FLA_Obj,
        A02: FLA_Obj,
        A10: FLA_Obj,
        A11: FLA_Obj,
        A12: FLA_Obj,
        ABL: *mut FLA_Obj,
        ABR: *mut FLA_Obj,
        A20: FLA_Obj,
        A21: FLA_Obj,
        A22: FLA_Obj,
        quadrant: FLA_Quadrant,
    ) -> FLA_Error;
    pub fn FLA_Cont_with_3x1_to_2x1_check(
        AT: *mut FLA_Obj,
        A0: FLA_Obj,
        A1: FLA_Obj,
        AB: *mut FLA_Obj,
        A2: FLA_Obj,
        side: FLA_Side,
    ) -> FLA_Error;
    pub fn FLA_Cont_with_1x3_to_1x2_check(
        AL: *mut FLA_Obj,
        AR: *mut FLA_Obj,
        A0: FLA_Obj,
        A1: FLA_Obj,
        A2: FLA_Obj,
        side: FLA_Side,
    ) -> FLA_Error;
    pub fn FLA_random_float() -> f32;
    pub fn FLA_random_double() -> f64;
    pub fn FLA_random_scomplex() -> scomplex;
    pub fn FLA_random_dcomplex() -> dcomplex;
    pub fn FLA_Absolute_square(alpha: FLA_Obj) -> FLA_Error;
    pub fn FLA_Absolute_value(alpha: FLA_Obj) -> FLA_Error;
    pub fn FLA_Clock() -> f64;
    pub fn FLA_Conjugate(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Conjugate_r(uplo: FLA_Uplo, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Fill_with_linear_dist(shift: FLA_Obj, delta: FLA_Obj, x: FLA_Obj) -> FLA_Error;
    pub fn FLA_Fill_with_inverse_dist(alpha: FLA_Obj, x: FLA_Obj) -> FLA_Error;
    pub fn FLA_Fill_with_geometric_dist(alpha: FLA_Obj, x: FLA_Obj) -> FLA_Error;
    pub fn FLA_Fill_with_random_dist(shift: FLA_Obj, max: FLA_Obj, x: FLA_Obj) -> FLA_Error;
    pub fn FLA_Fill_with_logarithmic_dist(max: FLA_Obj, x: FLA_Obj) -> FLA_Error;
    pub fn FLA_Fill_with_cluster_dist(
        n_clusters: FLA_Obj,
        cluster_width: FLA_Obj,
        x: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hermitianize(uplo: FLA_Uplo, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Invert(conj: FLA_Conj, x: FLA_Obj) -> FLA_Error;
    pub fn FLA_Inv_scal_elemwise(trans: FLA_Trans, A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Max_abs_value(A: FLA_Obj, amax: FLA_Obj) -> FLA_Error;
    pub fn FLA_Max_abs_value_herm(uplo: FLA_Uplo, A: FLA_Obj, maxabs: FLA_Obj) -> FLA_Error;
    pub fn FLA_Max_elemwise_diff(A: FLA_Obj, B: FLA_Obj) -> f64;
    pub fn FLA_Mult_add(alpha: FLA_Obj, beta: FLA_Obj, gamma: FLA_Obj) -> FLA_Error;
    pub fn FLA_Negate(x: FLA_Obj) -> FLA_Error;
    pub fn FLA_Norm1(A: FLA_Obj, norm: FLA_Obj) -> FLA_Error;
    pub fn FLA_Norm_inf(A: FLA_Obj, norm: FLA_Obj) -> FLA_Error;
    pub fn FLA_Norm_frob(A: FLA_Obj, norm: FLA_Obj) -> FLA_Error;
    pub fn FLA_Pow(base: FLA_Obj, exp: FLA_Obj, btoe: FLA_Obj) -> FLA_Error;
    pub fn FLA_Random_matrix(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Random_herm_matrix(uplo: FLA_Uplo, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Random_symm_matrix(uplo: FLA_Uplo, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Random_spd_matrix(uplo: FLA_Uplo, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Random_tri_matrix(uplo: FLA_Uplo, diag: FLA_Diag, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Random_unitary_matrix(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Scal_elemwise(trans: FLA_Trans, A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Setr(uplo: FLA_Uplo, alpha: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Shift_pivots_to_check(ptype: FLA_Pivot_type, p: FLA_Obj) -> FLA_Error;
    pub fn FLA_Sqrt(alpha: FLA_Obj) -> FLA_Error;
    pub fn FLA_Symmetrize(uplo: FLA_Uplo, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Triangularize(uplo: FLA_Uplo, diag: FLA_Diag, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Transpose(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Set(alpha: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Set_diag(alpha: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Set_offdiag(offset: integer, alpha: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Set_to_identity(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Add_to_diag(diag_value: *mut c_void, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Shift_diag(conj: FLA_Conj, sigma: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Scale_diag(conj: FLA_Conj, alpha: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Set_diagonal_vector(A: FLA_Obj, d: FLA_Obj) -> FLA_Error;
    pub fn FLA_Set_diagonal_matrix(d: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Absolute_square_check(alpha: FLA_Obj) -> FLA_Error;
    pub fn FLA_Absolute_value_check(alpha: FLA_Obj) -> FLA_Error;
    pub fn FLA_Conjugate_check(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Conjugate_r_check(uplo: FLA_Uplo, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Fill_with_linear_dist_check(shift: FLA_Obj, delta: FLA_Obj, x: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Fill_with_inverse_dist_check(alpha: FLA_Obj, x: FLA_Obj) -> FLA_Error;
    pub fn FLA_Fill_with_geometric_dist_check(alpha: FLA_Obj, x: FLA_Obj) -> FLA_Error;
    pub fn FLA_Fill_with_random_dist_check(shift: FLA_Obj, max: FLA_Obj, x: FLA_Obj) -> FLA_Error;
    pub fn FLA_Fill_with_logarithmic_dist_check(alpha: FLA_Obj, x: FLA_Obj) -> FLA_Error;
    pub fn FLA_Fill_with_cluster_dist_check(
        n_clusters: FLA_Obj,
        cluster_width: FLA_Obj,
        x: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hermitianize_check(uplo: FLA_Uplo, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Invert_check(conj: FLA_Conj, x: FLA_Obj) -> FLA_Error;
    pub fn FLA_Inv_scal_elemwise_check(trans: FLA_Trans, A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Max_abs_value_check(A: FLA_Obj, amax: FLA_Obj) -> FLA_Error;
    pub fn FLA_Max_abs_value_herm_check(uplo: FLA_Uplo, A: FLA_Obj, maxabs: FLA_Obj) -> FLA_Error;
    pub fn FLA_Max_elemwise_diff_check(A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Mult_add_check(alpha: FLA_Obj, beta: FLA_Obj, gamma: FLA_Obj) -> FLA_Error;
    pub fn FLA_Negate_check(x: FLA_Obj) -> FLA_Error;
    pub fn FLA_Norm1_check(A: FLA_Obj, norm: FLA_Obj) -> FLA_Error;
    pub fn FLA_Norm_inf_check(A: FLA_Obj, norm: FLA_Obj) -> FLA_Error;
    pub fn FLA_Norm_frob_check(A: FLA_Obj, norm: FLA_Obj) -> FLA_Error;
    pub fn FLA_Pow_check(base: FLA_Obj, exp: FLA_Obj, btoe: FLA_Obj) -> FLA_Error;
    pub fn FLA_Random_matrix_check(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Random_herm_matrix_check(uplo: FLA_Uplo, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Random_symm_matrix_check(uplo: FLA_Uplo, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Random_spd_matrix_check(uplo: FLA_Uplo, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Random_tri_matrix_check(uplo: FLA_Uplo, diag: FLA_Diag, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Random_unitary_matrix_check(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Scal_elemwise_check(trans: FLA_Trans, A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Setr_check(uplo: FLA_Uplo, alpha: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Sort_check(direct: FLA_Direct, x: FLA_Obj) -> FLA_Error;
    pub fn FLA_Sqrt_check(alpha: FLA_Obj) -> FLA_Error;
    pub fn FLA_Symmetrize_check(uplo: FLA_Uplo, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Triangularize_check(uplo: FLA_Uplo, diag: FLA_Diag, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Transpose_check(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Set_check(alpha: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Set_diag_check(alpha: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Set_to_identity_check(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Add_to_diag_check(diag_value: *mut c_void, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Shift_diag_check(conj: FLA_Conj, sigma: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Scale_diag_check(conj: FLA_Conj, alpha: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Transpose_blk_var1(A: FLA_Obj, cntl: *mut fla_tpose_t) -> FLA_Error;
    pub fn FLA_Transpose_blk_var2(A: FLA_Obj, cntl: *mut fla_tpose_t) -> FLA_Error;
    pub fn FLA_Transpose_unb_var1(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Transpose_unb_var2(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Swap_t_blk_var1(A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_swap_t) -> FLA_Error;
    pub fn FLA_Swap_t_blk_var2(A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_swap_t) -> FLA_Error;
    pub fn FLA_Sort(direct: FLA_Direct, x: FLA_Obj) -> FLA_Error;
    pub fn FLA_Sort_f_ops(m_x: integer, x: *mut f32, inc_x: integer) -> FLA_Error;
    pub fn FLA_Sort_b_ops(m_x: integer, x: *mut f32, inc_x: integer) -> FLA_Error;
    pub fn FLA_Sort_f_opd(m_x: integer, x: *mut f64, inc_x: integer) -> FLA_Error;
    pub fn FLA_Sort_b_opd(m_x: integer, x: *mut f64, inc_x: integer) -> FLA_Error;
    pub fn FLA_Househ2_UT(side: FLA_Side, chi_1: FLA_Obj, x2: FLA_Obj, tau: FLA_Obj) -> FLA_Error;
    pub fn FLA_Househ2_UT_l_ops(
        m_x2: integer,
        chi_1: *mut f32,
        x2: *mut f32,
        inc_x2: integer,
        tau: *mut f32,
    ) -> FLA_Error;
    pub fn FLA_Househ2_UT_l_opd(
        m_x2: integer,
        chi_1: *mut f64,
        x2: *mut f64,
        inc_x2: integer,
        tau: *mut f64,
    ) -> FLA_Error;
    pub fn FLA_Househ2_UT_l_opc(
        m_x2: integer,
        chi_1: *mut scomplex,
        x2: *mut scomplex,
        inc_x2: integer,
        tau: *mut scomplex,
    ) -> FLA_Error;
    pub fn FLA_Househ2_UT_l_opz(
        m_x2: integer,
        chi_1: *mut dcomplex,
        x2: *mut dcomplex,
        inc_x2: integer,
        tau: *mut dcomplex,
    ) -> FLA_Error;
    pub fn FLA_Househ2_UT_r_ops(
        m_x2: integer,
        chi_1: *mut f32,
        x2: *mut f32,
        inc_x2: integer,
        tau: *mut f32,
    ) -> FLA_Error;
    pub fn FLA_Househ2_UT_r_opd(
        m_x2: integer,
        chi_1: *mut f64,
        x2: *mut f64,
        inc_x2: integer,
        tau: *mut f64,
    ) -> FLA_Error;
    pub fn FLA_Househ2_UT_r_opc(
        m_x2: integer,
        chi_1: *mut scomplex,
        x2: *mut scomplex,
        inc_x2: integer,
        tau: *mut scomplex,
    ) -> FLA_Error;
    pub fn FLA_Househ2_UT_r_opz(
        m_x2: integer,
        chi_1: *mut dcomplex,
        x2: *mut dcomplex,
        inc_x2: integer,
        tau: *mut dcomplex,
    ) -> FLA_Error;
    pub fn FLA_Househ3UD_UT(chi_1: FLA_Obj, x2: FLA_Obj, y2: FLA_Obj, tau: FLA_Obj) -> FLA_Error;
    pub fn FLA_Househ3UD_UT_ops(
        m_x2: integer,
        m_y2: integer,
        chi_1: *mut f32,
        x2: *mut f32,
        inc_x2: integer,
        y2: *mut f32,
        inc_y2: integer,
        tau: *mut f32,
    ) -> FLA_Error;
    pub fn FLA_Househ3UD_UT_opd(
        m_x2: integer,
        m_y2: integer,
        chi_1: *mut f64,
        x2: *mut f64,
        inc_x2: integer,
        y2: *mut f64,
        inc_y2: integer,
        tau: *mut f64,
    ) -> FLA_Error;
    pub fn FLA_Househ3UD_UT_opc(
        m_x2: integer,
        m_y2: integer,
        chi_1: *mut scomplex,
        x2: *mut scomplex,
        inc_x2: integer,
        y2: *mut scomplex,
        inc_y2: integer,
        tau: *mut scomplex,
    ) -> FLA_Error;
    pub fn FLA_Househ3UD_UT_opz(
        m_x2: integer,
        m_y2: integer,
        chi_1: *mut dcomplex,
        x2: *mut dcomplex,
        inc_x2: integer,
        y2: *mut dcomplex,
        inc_y2: integer,
        tau: *mut dcomplex,
    ) -> FLA_Error;
    pub fn FLA_Househ2s_UT(
        side: FLA_Side,
        chi_1: FLA_Obj,
        x2: FLA_Obj,
        alpha: FLA_Obj,
        chi_1_minus_alpha: FLA_Obj,
        tau: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Househ2s_UT_l_ops(
        m_x2: integer,
        chi_1: *mut f32,
        x2: *mut f32,
        inc_x2: integer,
        alpha: *mut f32,
        chi_1_minus_alpha: *mut f32,
        tau: *mut f32,
    ) -> FLA_Error;
    pub fn FLA_Househ2s_UT_l_opd(
        m_x2: integer,
        chi_1: *mut f64,
        x2: *mut f64,
        inc_x2: integer,
        alpha: *mut f64,
        chi_1_minus_alpha: *mut f64,
        tau: *mut f64,
    ) -> FLA_Error;
    pub fn FLA_Househ2s_UT_l_opc(
        m_x2: integer,
        chi_1: *mut scomplex,
        x2: *mut scomplex,
        inc_x2: integer,
        alpha: *mut scomplex,
        chi_1_minus_alpha: *mut scomplex,
        tau: *mut scomplex,
    ) -> FLA_Error;
    pub fn FLA_Househ2s_UT_l_opz(
        m_x2: integer,
        chi_1: *mut dcomplex,
        x2: *mut dcomplex,
        inc_x2: integer,
        alpha: *mut dcomplex,
        chi_1_minus_alpha: *mut dcomplex,
        tau: *mut dcomplex,
    ) -> FLA_Error;
    pub fn FLA_Househ2s_UT_r_ops(
        m_x2: integer,
        chi_1: *mut f32,
        x2: *mut f32,
        inc_x2: integer,
        alpha: *mut f32,
        chi_1_minus_alpha: *mut f32,
        tau: *mut f32,
    ) -> FLA_Error;
    pub fn FLA_Househ2s_UT_r_opd(
        m_x2: integer,
        chi_1: *mut f64,
        x2: *mut f64,
        inc_x2: integer,
        alpha: *mut f64,
        chi_1_minus_alpha: *mut f64,
        tau: *mut f64,
    ) -> FLA_Error;
    pub fn FLA_Househ2s_UT_r_opc(
        m_x2: integer,
        chi_1: *mut scomplex,
        x2: *mut scomplex,
        inc_x2: integer,
        alpha: *mut scomplex,
        chi_1_minus_alpha: *mut scomplex,
        tau: *mut scomplex,
    ) -> FLA_Error;
    pub fn FLA_Househ2s_UT_r_opz(
        m_x2: integer,
        chi_1: *mut dcomplex,
        x2: *mut dcomplex,
        inc_x2: integer,
        alpha: *mut dcomplex,
        chi_1_minus_alpha: *mut dcomplex,
        tau: *mut dcomplex,
    ) -> FLA_Error;
    pub fn FLA_Hev_2x2(
        alpha11: FLA_Obj,
        alpha21: FLA_Obj,
        alpha22: FLA_Obj,
        lambda1: FLA_Obj,
        lambda2: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hev_2x2_ops(
        buff_alpha11: *mut f32,
        buff_alpha21: *mut f32,
        buff_alpha22: *mut f32,
        buff_lambda1: *mut f32,
        buff_lambda2: *mut f32,
    ) -> FLA_Error;
    pub fn FLA_Hev_2x2_opd(
        buff_alpha11: *mut f64,
        buff_alpha21: *mut f64,
        buff_alpha22: *mut f64,
        buff_lambda1: *mut f64,
        buff_lambda2: *mut f64,
    ) -> FLA_Error;
    pub fn FLA_Hevv_2x2(
        alpha11: FLA_Obj,
        alpha21: FLA_Obj,
        alpha22: FLA_Obj,
        lambda1: FLA_Obj,
        lambda2: FLA_Obj,
        gamma1: FLA_Obj,
        sigma1: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hevv_2x2_ops(
        alpha11: *mut f32,
        alpha21: *mut f32,
        alpha22: *mut f32,
        lambda1: *mut f32,
        lambda2: *mut f32,
        gamma1: *mut f32,
        sigma1: *mut f32,
    ) -> FLA_Error;
    pub fn FLA_Hevv_2x2_opd(
        alpha11: *mut f64,
        alpha21: *mut f64,
        alpha22: *mut f64,
        lambda1: *mut f64,
        lambda2: *mut f64,
        gamma1: *mut f64,
        sigma1: *mut f64,
    ) -> FLA_Error;
    pub fn FLA_Hevv_2x2_opc(
        alpha11: *mut scomplex,
        alpha21: *mut scomplex,
        alpha22: *mut scomplex,
        lambda1: *mut f32,
        lambda2: *mut f32,
        gamma1: *mut f32,
        sigma1: *mut scomplex,
    ) -> FLA_Error;
    pub fn FLA_Hevv_2x2_opz(
        alpha11: *mut dcomplex,
        alpha21: *mut dcomplex,
        alpha22: *mut dcomplex,
        lambda1: *mut f64,
        lambda2: *mut f64,
        gamma1: *mut f64,
        sigma1: *mut dcomplex,
    ) -> FLA_Error;
    pub fn FLA_Wilkshift_tridiag(
        delta1: FLA_Obj,
        epsilon: FLA_Obj,
        delta2: FLA_Obj,
        kappa: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Wilkshift_tridiag_ops(
        delta1: f32,
        epsilon: f32,
        delta2: f32,
        kappa: *mut f32,
    ) -> FLA_Error;
    pub fn FLA_Wilkshift_tridiag_opd(
        delta1: f64,
        epsilon: f64,
        delta2: f64,
        kappa: *mut f64,
    ) -> FLA_Error;
    pub fn FLA_Pythag2(chi: FLA_Obj, psi: FLA_Obj, rho: FLA_Obj) -> FLA_Error;
    pub fn FLA_Pythag2_ops(chi: *mut f32, psi: *mut f32, rho: *mut f32) -> FLA_Error;
    pub fn FLA_Pythag2_opd(chi: *mut f64, psi: *mut f64, rho: *mut f64) -> FLA_Error;
    pub fn FLA_Pythag3(chi: FLA_Obj, psi: FLA_Obj, zeta: FLA_Obj, rho: FLA_Obj) -> FLA_Error;
    pub fn FLA_Pythag3_ops(
        chi: *mut f32,
        psi: *mut f32,
        zeta: *mut f32,
        rho: *mut f32,
    ) -> FLA_Error;
    pub fn FLA_Pythag3_opd(
        chi: *mut f64,
        psi: *mut f64,
        zeta: *mut f64,
        rho: *mut f64,
    ) -> FLA_Error;
    pub fn FLA_Sort_evd(direct: FLA_Direct, l: FLA_Obj, V: FLA_Obj) -> FLA_Error;
    pub fn FLA_Sort_evd_f_ops(
        m_A: integer,
        l: *mut f32,
        inc_l: integer,
        V: *mut f32,
        rs_V: integer,
        cs_V: integer,
    ) -> FLA_Error;
    pub fn FLA_Sort_evd_b_ops(
        m_A: integer,
        l: *mut f32,
        inc_l: integer,
        V: *mut f32,
        rs_V: integer,
        cs_V: integer,
    ) -> FLA_Error;
    pub fn FLA_Sort_evd_f_opd(
        m_A: integer,
        l: *mut f64,
        inc_l: integer,
        V: *mut f64,
        rs_V: integer,
        cs_V: integer,
    ) -> FLA_Error;
    pub fn FLA_Sort_evd_b_opd(
        m_A: integer,
        l: *mut f64,
        inc_l: integer,
        V: *mut f64,
        rs_V: integer,
        cs_V: integer,
    ) -> FLA_Error;
    pub fn FLA_Sort_evd_f_opc(
        m_A: integer,
        l: *mut f32,
        inc_l: integer,
        V: *mut scomplex,
        rs_V: integer,
        cs_V: integer,
    ) -> FLA_Error;
    pub fn FLA_Sort_evd_b_opc(
        m_A: integer,
        l: *mut f32,
        inc_l: integer,
        V: *mut scomplex,
        rs_V: integer,
        cs_V: integer,
    ) -> FLA_Error;
    pub fn FLA_Sort_evd_f_opz(
        m_A: integer,
        l: *mut f64,
        inc_l: integer,
        V: *mut dcomplex,
        rs_V: integer,
        cs_V: integer,
    ) -> FLA_Error;
    pub fn FLA_Sort_evd_b_opz(
        m_A: integer,
        l: *mut f64,
        inc_l: integer,
        V: *mut dcomplex,
        rs_V: integer,
        cs_V: integer,
    ) -> FLA_Error;
    pub fn FLA_Sort_bsvd_ext(
        direct: FLA_Direct,
        s: FLA_Obj,
        apply_U: FLA_Bool,
        U: FLA_Obj,
        apply_V: FLA_Bool,
        V: FLA_Obj,
        apply_C: FLA_Bool,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sort_bsvd_ext_f_ops(
        m_s: integer,
        s: *mut f32,
        inc_s: integer,
        m_U: integer,
        U: *mut f32,
        rs_U: integer,
        cs_U: integer,
        m_V: integer,
        V: *mut f32,
        rs_V: integer,
        cs_V: integer,
        n_C: integer,
        C: *mut f32,
        rs_C: integer,
        cs_C: integer,
    ) -> FLA_Error;
    pub fn FLA_Sort_bsvd_ext_b_ops(
        m_s: integer,
        s: *mut f32,
        inc_s: integer,
        m_U: integer,
        U: *mut f32,
        rs_U: integer,
        cs_U: integer,
        m_V: integer,
        V: *mut f32,
        rs_V: integer,
        cs_V: integer,
        n_C: integer,
        C: *mut f32,
        rs_C: integer,
        cs_C: integer,
    ) -> FLA_Error;
    pub fn FLA_Sort_bsvd_ext_f_opd(
        m_s: integer,
        s: *mut f64,
        inc_s: integer,
        m_U: integer,
        U: *mut f64,
        rs_U: integer,
        cs_U: integer,
        m_V: integer,
        V: *mut f64,
        rs_V: integer,
        cs_V: integer,
        n_C: integer,
        C: *mut f64,
        rs_C: integer,
        cs_C: integer,
    ) -> FLA_Error;
    pub fn FLA_Sort_bsvd_ext_b_opd(
        m_s: integer,
        s: *mut f64,
        inc_s: integer,
        m_U: integer,
        U: *mut f64,
        rs_U: integer,
        cs_U: integer,
        m_V: integer,
        V: *mut f64,
        rs_V: integer,
        cs_V: integer,
        n_C: integer,
        C: *mut f64,
        rs_C: integer,
        cs_C: integer,
    ) -> FLA_Error;
    pub fn FLA_Sort_bsvd_ext_f_opc(
        m_s: integer,
        s: *mut f32,
        inc_s: integer,
        m_U: integer,
        U: *mut scomplex,
        rs_U: integer,
        cs_U: integer,
        m_V: integer,
        V: *mut scomplex,
        rs_V: integer,
        cs_V: integer,
        n_C: integer,
        C: *mut scomplex,
        rs_C: integer,
        cs_C: integer,
    ) -> FLA_Error;
    pub fn FLA_Sort_bsvd_ext_b_opc(
        m_s: integer,
        s: *mut f32,
        inc_s: integer,
        m_U: integer,
        U: *mut scomplex,
        rs_U: integer,
        cs_U: integer,
        m_V: integer,
        V: *mut scomplex,
        rs_V: integer,
        cs_V: integer,
        n_C: integer,
        C: *mut scomplex,
        rs_C: integer,
        cs_C: integer,
    ) -> FLA_Error;
    pub fn FLA_Sort_bsvd_ext_f_opz(
        m_s: integer,
        s: *mut f64,
        inc_s: integer,
        m_U: integer,
        U: *mut dcomplex,
        rs_U: integer,
        cs_U: integer,
        m_V: integer,
        V: *mut dcomplex,
        rs_V: integer,
        cs_V: integer,
        n_C: integer,
        C: *mut dcomplex,
        rs_C: integer,
        cs_C: integer,
    ) -> FLA_Error;
    pub fn FLA_Sort_bsvd_ext_b_opz(
        m_s: integer,
        s: *mut f64,
        inc_s: integer,
        m_U: integer,
        U: *mut dcomplex,
        rs_U: integer,
        cs_U: integer,
        m_V: integer,
        V: *mut dcomplex,
        rs_V: integer,
        cs_V: integer,
        n_C: integer,
        C: *mut dcomplex,
        rs_C: integer,
        cs_C: integer,
    ) -> FLA_Error;
    pub fn FLA_Sort_svd(direct: FLA_Direct, s: FLA_Obj, U: FLA_Obj, V: FLA_Obj) -> FLA_Error;
    pub fn FLA_Sort_svd_f_ops(
        m_U: integer,
        n_V: integer,
        s: *mut f32,
        inc_s: integer,
        U: *mut f32,
        rs_U: integer,
        cs_U: integer,
        V: *mut f32,
        rs_V: integer,
        cs_V: integer,
    ) -> FLA_Error;
    pub fn FLA_Sort_svd_b_ops(
        m_U: integer,
        n_V: integer,
        s: *mut f32,
        inc_s: integer,
        U: *mut f32,
        rs_U: integer,
        cs_U: integer,
        V: *mut f32,
        rs_V: integer,
        cs_V: integer,
    ) -> FLA_Error;
    pub fn FLA_Sort_svd_f_opd(
        m_U: integer,
        n_V: integer,
        s: *mut f64,
        inc_s: integer,
        U: *mut f64,
        rs_U: integer,
        cs_U: integer,
        V: *mut f64,
        rs_V: integer,
        cs_V: integer,
    ) -> FLA_Error;
    pub fn FLA_Sort_svd_b_opd(
        m_U: integer,
        n_V: integer,
        s: *mut f64,
        inc_s: integer,
        U: *mut f64,
        rs_U: integer,
        cs_U: integer,
        V: *mut f64,
        rs_V: integer,
        cs_V: integer,
    ) -> FLA_Error;
    pub fn FLA_Sort_svd_f_opc(
        m_U: integer,
        n_V: integer,
        s: *mut f32,
        inc_s: integer,
        U: *mut scomplex,
        rs_U: integer,
        cs_U: integer,
        V: *mut scomplex,
        rs_V: integer,
        cs_V: integer,
    ) -> FLA_Error;
    pub fn FLA_Sort_svd_b_opc(
        m_U: integer,
        n_V: integer,
        s: *mut f32,
        inc_s: integer,
        U: *mut scomplex,
        rs_U: integer,
        cs_U: integer,
        V: *mut scomplex,
        rs_V: integer,
        cs_V: integer,
    ) -> FLA_Error;
    pub fn FLA_Sort_svd_f_opz(
        m_U: integer,
        n_V: integer,
        s: *mut f64,
        inc_s: integer,
        U: *mut dcomplex,
        rs_U: integer,
        cs_U: integer,
        V: *mut dcomplex,
        rs_V: integer,
        cs_V: integer,
    ) -> FLA_Error;
    pub fn FLA_Sort_svd_b_opz(
        m_U: integer,
        n_V: integer,
        s: *mut f64,
        inc_s: integer,
        U: *mut dcomplex,
        rs_U: integer,
        cs_U: integer,
        V: *mut dcomplex,
        rs_V: integer,
        cs_V: integer,
    ) -> FLA_Error;
    pub fn FLA_Sv_2x2(
        alpha11: FLA_Obj,
        alpha12: FLA_Obj,
        alpha22: FLA_Obj,
        sigma1: FLA_Obj,
        sigma2: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sv_2x2_ops(
        alpha11: *mut f32,
        alpha12: *mut f32,
        alpha22: *mut f32,
        sigma1: *mut f32,
        sigma2: *mut f32,
    ) -> FLA_Error;
    pub fn FLA_Sv_2x2_opd(
        alpha11: *mut f64,
        alpha12: *mut f64,
        alpha22: *mut f64,
        sigma1: *mut f64,
        sigma2: *mut f64,
    ) -> FLA_Error;
    pub fn FLA_Svv_2x2(
        alpha11: FLA_Obj,
        alpha12: FLA_Obj,
        alpha22: FLA_Obj,
        sigma1: FLA_Obj,
        sigma2: FLA_Obj,
        gammaL: FLA_Obj,
        sigmaL: FLA_Obj,
        gammaR: FLA_Obj,
        sigmaR: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Svv_2x2_ops(
        alpha11: *mut f32,
        alpha12: *mut f32,
        alpha22: *mut f32,
        sigma1: *mut f32,
        sigma2: *mut f32,
        gammaL: *mut f32,
        sigmaL: *mut f32,
        gammaR: *mut f32,
        sigmaR: *mut f32,
    ) -> FLA_Error;
    pub fn FLA_Svv_2x2_opd(
        alpha11: *mut f64,
        alpha12: *mut f64,
        alpha22: *mut f64,
        sigma1: *mut f64,
        sigma2: *mut f64,
        gammaL: *mut f64,
        sigmaL: *mut f64,
        gammaR: *mut f64,
        sigmaR: *mut f64,
    ) -> FLA_Error;
    pub fn FLA_Mach_params(machval: FLA_Machval, val: FLA_Obj) -> FLA_Error;
    pub fn FLA_Mach_params_ops(machval: FLA_Machval) -> f32;
    pub fn FLA_Mach_params_opd(machval: FLA_Machval) -> f64;
    pub fn FLA_Apply_diag_matrix(
        side: FLA_Side,
        conj: FLA_Conj,
        x: FLA_Obj,
        A: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Shift_pivots_to(ptype: FLA_Pivot_type, p: FLA_Obj) -> FLA_Error;
    pub fn FLA_Form_perm_matrix(p: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_LU_find_zero_on_diagonal(A: FLA_Obj) -> FLA_Error;
    pub fn fla_dlamch(cmach: *mut c_char, cmach_len: ftnlen) -> doublereal;
    pub fn fla_slamch(cmach: *mut c_char, cmach_len: ftnlen) -> real;
    pub fn fla_lsame(
        ca: *mut c_char,
        cb: *mut c_char,
        ca_len: ftnlen,
        cb_len: ftnlen,
    ) -> logical;
    pub fn fla_pow_di(a: *mut doublereal, n: *mut integer) -> f64;
    pub fn fla_pow_ri(a: *mut real, n: *mut integer) -> real;
    pub fn FLA_Househ2_UT_check(
        side: FLA_Side,
        chi_1: FLA_Obj,
        x2: FLA_Obj,
        tau: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Househ3UD_UT_check(
        chi_1: FLA_Obj,
        x2: FLA_Obj,
        y2: FLA_Obj,
        tau: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Househ2s_UT_check(
        side: FLA_Side,
        chi_1: FLA_Obj,
        x2: FLA_Obj,
        alpha: FLA_Obj,
        chi_1_minus_alpha: FLA_Obj,
        tau: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Givens2_check(
        chi_1: FLA_Obj,
        chi_2: FLA_Obj,
        gamma: FLA_Obj,
        sigma: FLA_Obj,
        chi_1_new: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Apply_GTG_check(
        gamma: FLA_Obj,
        sigma: FLA_Obj,
        delta1: FLA_Obj,
        epsilon1: FLA_Obj,
        delta2: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_1x2_check(
        gamma: FLA_Obj,
        sigma: FLA_Obj,
        beta: FLA_Obj,
        epsilon: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_mx2_check(
        gamma: FLA_Obj,
        sigma: FLA_Obj,
        a1: FLA_Obj,
        a2: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_check(
        side: FLA_Side,
        direct: FLA_Direct,
        G: FLA_Obj,
        A: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Wilkshift_tridiag_check(
        delta1: FLA_Obj,
        epsilon: FLA_Obj,
        delta2: FLA_Obj,
        kappa: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Wilkshift_bidiag_check(
        epsilon1: FLA_Obj,
        delta1: FLA_Obj,
        epsilon2: FLA_Obj,
        delta2: FLA_Obj,
        kappa: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Introduce_bulge_check(
        shift: FLA_Obj,
        gamma: FLA_Obj,
        sigma: FLA_Obj,
        delta1: FLA_Obj,
        epsilon1: FLA_Obj,
        delta2: FLA_Obj,
        beta: FLA_Obj,
        epsilon2: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Mach_params_check(machval: FLA_Machval, val: FLA_Obj) -> FLA_Error;
    pub fn FLA_Sort_evd_check(direct: FLA_Direct, l: FLA_Obj, V: FLA_Obj) -> FLA_Error;
    pub fn FLA_Sort_svd_check(direct: FLA_Direct, s: FLA_Obj, U: FLA_Obj, V: FLA_Obj) -> FLA_Error;
    pub fn FLA_Apply_diag_matrix_check(
        side: FLA_Side,
        conj: FLA_Conj,
        x: FLA_Obj,
        A: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Form_perm_matrix_check(p: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_LU_find_zero_on_diagonal_check(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Asum(x: FLA_Obj, asum_x: FLA_Obj) -> FLA_Error;
    pub fn FLA_Axpy(alpha: FLA_Obj, A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Axpys(
        alpha0: FLA_Obj,
        alpha1: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Axpyt(trans: FLA_Trans, alpha: FLA_Obj, A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Axpyrt(
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Copy(A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Copyr(uplo: FLA_Uplo, A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Copyrt(uplo: FLA_Uplo, trans: FLA_Trans, A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Copyt(trans: FLA_Trans, A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Dot(x: FLA_Obj, y: FLA_Obj, rho: FLA_Obj) -> FLA_Error;
    pub fn FLA_Dot2cs(
        conj: FLA_Conj,
        alpha: FLA_Obj,
        x: FLA_Obj,
        y: FLA_Obj,
        beta: FLA_Obj,
        rho: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Dot2s(
        alpha: FLA_Obj,
        x: FLA_Obj,
        y: FLA_Obj,
        beta: FLA_Obj,
        rho: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Dotc(conj: FLA_Conj, x: FLA_Obj, y: FLA_Obj, rho: FLA_Obj) -> FLA_Error;
    pub fn FLA_Dotcs(
        conj: FLA_Conj,
        alpha: FLA_Obj,
        x: FLA_Obj,
        y: FLA_Obj,
        beta: FLA_Obj,
        rho: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Dots(
        alpha: FLA_Obj,
        x: FLA_Obj,
        y: FLA_Obj,
        beta: FLA_Obj,
        rho: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Amax(x: FLA_Obj, index: FLA_Obj) -> FLA_Error;
    pub fn FLA_Inv_scal(alpha: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Inv_scalc(conjalpha: FLA_Conj, alpha: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Nrm2(x: FLA_Obj, norm_x: FLA_Obj) -> FLA_Error;
    pub fn FLA_Scal(alpha: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Scalc(conjalpha: FLA_Conj, alpha: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Scalr(uplo: FLA_Uplo, alpha: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Swap(A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Swapt(trans: FLA_Trans, A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Axpy_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_axpy_t,
    ) -> FLA_Error;
    pub fn FLA_Axpyt_task(
        trans: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_axpyt_t,
    ) -> FLA_Error;
    pub fn FLA_Copy_task(A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_copy_t) -> FLA_Error;
    pub fn FLA_Copyt_task(
        trans: FLA_Trans,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_copyt_t,
    ) -> FLA_Error;
    pub fn FLA_Copyr_task(
        uplo: FLA_Uplo,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_copyr_t,
    ) -> FLA_Error;
    pub fn FLA_Scal_task(alpha: FLA_Obj, A: FLA_Obj, cntl: *mut fla_scal_t) -> FLA_Error;
    pub fn FLA_Scalr_task(
        uplo: FLA_Uplo,
        alpha: FLA_Obj,
        A: FLA_Obj,
        cntl: *mut fla_scalr_t,
    ) -> FLA_Error;
    pub fn FLA_Axpyt_n_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_axpyt_t,
    ) -> FLA_Error;
    pub fn FLA_Axpyt_t_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_axpyt_t,
    ) -> FLA_Error;
    pub fn FLA_Axpyt_c_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_axpyt_t,
    ) -> FLA_Error;
    pub fn FLA_Axpyt_h_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_axpyt_t,
    ) -> FLA_Error;
    pub fn FLA_Copyt_n_task(A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_copyt_t) -> FLA_Error;
    pub fn FLA_Copyt_t_task(A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_copyt_t) -> FLA_Error;
    pub fn FLA_Copyt_c_task(A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_copyt_t) -> FLA_Error;
    pub fn FLA_Copyt_h_task(A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_copyt_t) -> FLA_Error;
    pub fn FLA_Copyr_l_task(A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_copyr_t) -> FLA_Error;
    pub fn FLA_Copyr_u_task(A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_copyr_t) -> FLA_Error;
    pub fn FLA_Scalr_l_task(alpha: FLA_Obj, A: FLA_Obj, cntl: *mut fla_scalr_t) -> FLA_Error;
    pub fn FLA_Scalr_u_task(alpha: FLA_Obj, A: FLA_Obj, cntl: *mut fla_scalr_t) -> FLA_Error;
    pub fn FLA_Asum_external(x: FLA_Obj, asum_x: FLA_Obj) -> FLA_Error;
    pub fn FLA_Axpy_external(alpha: FLA_Obj, A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Axpys_external(
        alpha0: FLA_Obj,
        alpha1: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Axpyt_external(
        trans: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Axpyrt_external(
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Copy_external(A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Copyr_external(uplo: FLA_Uplo, A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Copyrt_external(
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Copyt_external(trans: FLA_Trans, A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Dot_external(x: FLA_Obj, y: FLA_Obj, rho: FLA_Obj) -> FLA_Error;
    pub fn FLA_Dotc_external(conj: FLA_Conj, x: FLA_Obj, y: FLA_Obj, rho: FLA_Obj) -> FLA_Error;
    pub fn FLA_Dots_external(
        alpha: FLA_Obj,
        x: FLA_Obj,
        y: FLA_Obj,
        beta: FLA_Obj,
        rho: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Dotcs_external(
        conj: FLA_Conj,
        alpha: FLA_Obj,
        x: FLA_Obj,
        y: FLA_Obj,
        beta: FLA_Obj,
        rho: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Dot2s_external(
        alpha: FLA_Obj,
        x: FLA_Obj,
        y: FLA_Obj,
        beta: FLA_Obj,
        rho: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Dot2cs_external(
        conj: FLA_Conj,
        alpha: FLA_Obj,
        x: FLA_Obj,
        y: FLA_Obj,
        beta: FLA_Obj,
        rho: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Amax_external(x: FLA_Obj, index: FLA_Obj) -> FLA_Error;
    pub fn FLA_Inv_scal_external(alpha: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Inv_scalc_external(conjalpha: FLA_Conj, alpha: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Nrm2_external(x: FLA_Obj, nrm_x: FLA_Obj) -> FLA_Error;
    pub fn FLA_Scal_external(alpha: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Scalc_external(conjalpha: FLA_Conj, alpha: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Scalr_external(uplo: FLA_Uplo, alpha: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Swap_external(A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Swapt_external(trans: FLA_Trans, A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Axpy_external_gpu(
        alpha: FLA_Obj,
        A: FLA_Obj,
        A_gpu: *mut c_void,
        B: FLA_Obj,
        B_gpu: *mut c_void,
    ) -> FLA_Error;
    pub fn FLA_Copy_external_gpu(
        A: FLA_Obj,
        A_gpu: *mut c_void,
        B: FLA_Obj,
        B_gpu: *mut c_void,
    ) -> FLA_Error;
    pub fn FLA_Scal_external_gpu(
        alpha: FLA_Obj,
        A: FLA_Obj,
        A_gpu: *mut c_void,
    ) -> FLA_Error;
    pub fn FLA_Scalr_external_gpu(
        uplo: FLA_Uplo,
        alpha: FLA_Obj,
        A: FLA_Obj,
        A_gpu: *mut c_void,
    ) -> FLA_Error;
    pub fn FLA_Asum_check(x: FLA_Obj, asum_x: FLA_Obj) -> FLA_Error;
    pub fn FLA_Axpy_check(alpha: FLA_Obj, A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Axpys_check(
        alpha0: FLA_Obj,
        alpha1: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Axpyt_check(trans: FLA_Trans, alpha: FLA_Obj, A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Axpyrt_check(
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Copy_check(A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Copyr_check(uplo: FLA_Uplo, A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Copyrt_check(uplo: FLA_Uplo, trans: FLA_Trans, A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Copyt_check(trans: FLA_Trans, A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Dot_check(x: FLA_Obj, y: FLA_Obj, rho: FLA_Obj) -> FLA_Error;
    pub fn FLA_Dotc_check(conj: FLA_Conj, x: FLA_Obj, y: FLA_Obj, rho: FLA_Obj) -> FLA_Error;
    pub fn FLA_Dots_check(
        alpha: FLA_Obj,
        x: FLA_Obj,
        y: FLA_Obj,
        beta: FLA_Obj,
        rho: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Dotcs_check(
        conj: FLA_Conj,
        alpha: FLA_Obj,
        x: FLA_Obj,
        y: FLA_Obj,
        beta: FLA_Obj,
        rho: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Dot2s_check(
        alpha: FLA_Obj,
        x: FLA_Obj,
        y: FLA_Obj,
        beta: FLA_Obj,
        rho: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Dot2cs_check(
        conj: FLA_Conj,
        alpha: FLA_Obj,
        x: FLA_Obj,
        y: FLA_Obj,
        beta: FLA_Obj,
        rho: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Amax_check(x: FLA_Obj, index: FLA_Obj) -> FLA_Error;
    pub fn FLA_Inv_scal_check(alpha: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Inv_scalc_check(conjalpha: FLA_Conj, alpha: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Nrm2_check(x: FLA_Obj, nrm_x: FLA_Obj) -> FLA_Error;
    pub fn FLA_Scal_check(alpha: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Scalc_check(conjalpha: FLA_Conj, alpha: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Scalr_check(uplo: FLA_Uplo, alpha: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Swap_check(A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Swapt_check(trans: FLA_Trans, A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Axpy_internal_check(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_axpy_t,
    ) -> FLA_Error;
    pub fn FLA_Axpyt_internal_check(
        trans: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_axpyt_t,
    ) -> FLA_Error;
    pub fn FLA_Copy_internal_check(A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_copy_t) -> FLA_Error;
    pub fn FLA_Copyt_internal_check(
        trans: FLA_Trans,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_copyt_t,
    ) -> FLA_Error;
    pub fn FLA_Copyr_internal_check(
        uplo: FLA_Uplo,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_copyr_t,
    ) -> FLA_Error;
    pub fn FLA_Scal_internal_check(alpha: FLA_Obj, A: FLA_Obj, cntl: *mut fla_scal_t) -> FLA_Error;
    pub fn FLA_Scalr_internal_check(
        uplo: FLA_Uplo,
        alpha: FLA_Obj,
        A: FLA_Obj,
        cntl: *mut fla_scalr_t,
    ) -> FLA_Error;
    pub fn FLA_Gemv(
        transa: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        x: FLA_Obj,
        beta: FLA_Obj,
        y: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemvc(
        transa: FLA_Trans,
        conjx: FLA_Conj,
        alpha: FLA_Obj,
        A: FLA_Obj,
        x: FLA_Obj,
        beta: FLA_Obj,
        y: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Ger(alpha: FLA_Obj, x: FLA_Obj, y: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Gerc(
        conjx: FLA_Conj,
        conjy: FLA_Conj,
        alpha: FLA_Obj,
        x: FLA_Obj,
        y: FLA_Obj,
        A: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemv(
        uplo: FLA_Uplo,
        alpha: FLA_Obj,
        A: FLA_Obj,
        x: FLA_Obj,
        beta: FLA_Obj,
        y: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemvc(
        uplo: FLA_Uplo,
        conja: FLA_Conj,
        alpha: FLA_Obj,
        A: FLA_Obj,
        x: FLA_Obj,
        beta: FLA_Obj,
        y: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her(uplo: FLA_Uplo, alpha: FLA_Obj, x: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Herc(
        uplo: FLA_Uplo,
        conj: FLA_Conj,
        alpha: FLA_Obj,
        x: FLA_Obj,
        A: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2(
        uplo: FLA_Uplo,
        alpha: FLA_Obj,
        x: FLA_Obj,
        y: FLA_Obj,
        A: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2c(
        uplo: FLA_Uplo,
        conj: FLA_Conj,
        alpha: FLA_Obj,
        x: FLA_Obj,
        y: FLA_Obj,
        A: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Symv(
        uplo: FLA_Uplo,
        alpha: FLA_Obj,
        A: FLA_Obj,
        x: FLA_Obj,
        beta: FLA_Obj,
        y: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syr(uplo: FLA_Uplo, alpha: FLA_Obj, x: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Syr2(
        uplo: FLA_Uplo,
        alpha: FLA_Obj,
        x: FLA_Obj,
        y: FLA_Obj,
        A: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmv(
        uplo: FLA_Uplo,
        transa: FLA_Trans,
        diag: FLA_Diag,
        A: FLA_Obj,
        x: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmvsx(
        uplo: FLA_Uplo,
        transa: FLA_Trans,
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        x: FLA_Obj,
        beta: FLA_Obj,
        y: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsv(
        uplo: FLA_Uplo,
        transa: FLA_Trans,
        diag: FLA_Diag,
        A: FLA_Obj,
        x: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsvsx(
        uplo: FLA_Uplo,
        transa: FLA_Trans,
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        x: FLA_Obj,
        beta: FLA_Obj,
        y: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemv_task(
        transa: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        x: FLA_Obj,
        beta: FLA_Obj,
        y: FLA_Obj,
        cntl: *mut fla_gemv_t,
    ) -> FLA_Error;
    pub fn FLA_Trsv_task(
        uplo: FLA_Uplo,
        transa: FLA_Trans,
        diag: FLA_Diag,
        A: FLA_Obj,
        x: FLA_Obj,
        cntl: *mut fla_trsv_t,
    ) -> FLA_Error;
    pub fn FLA_Gemv_h_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        x: FLA_Obj,
        beta: FLA_Obj,
        y: FLA_Obj,
        cntl: *mut fla_gemv_t,
    ) -> FLA_Error;
    pub fn FLA_Gemv_n_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        x: FLA_Obj,
        beta: FLA_Obj,
        y: FLA_Obj,
        cntl: *mut fla_gemv_t,
    ) -> FLA_Error;
    pub fn FLA_Gemv_t_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        x: FLA_Obj,
        beta: FLA_Obj,
        y: FLA_Obj,
        cntl: *mut fla_gemv_t,
    ) -> FLA_Error;
    pub fn FLA_Trsv_lc_task(
        diag: FLA_Diag,
        A: FLA_Obj,
        x: FLA_Obj,
        cntl: *mut fla_trsv_t,
    ) -> FLA_Error;
    pub fn FLA_Trsv_ln_task(
        diag: FLA_Diag,
        A: FLA_Obj,
        x: FLA_Obj,
        cntl: *mut fla_trsv_t,
    ) -> FLA_Error;
    pub fn FLA_Trsv_lt_task(
        diag: FLA_Diag,
        A: FLA_Obj,
        x: FLA_Obj,
        cntl: *mut fla_trsv_t,
    ) -> FLA_Error;
    pub fn FLA_Trsv_uc_task(
        diag: FLA_Diag,
        A: FLA_Obj,
        x: FLA_Obj,
        cntl: *mut fla_trsv_t,
    ) -> FLA_Error;
    pub fn FLA_Trsv_un_task(
        diag: FLA_Diag,
        A: FLA_Obj,
        x: FLA_Obj,
        cntl: *mut fla_trsv_t,
    ) -> FLA_Error;
    pub fn FLA_Trsv_ut_task(
        diag: FLA_Diag,
        A: FLA_Obj,
        x: FLA_Obj,
        cntl: *mut fla_trsv_t,
    ) -> FLA_Error;
    pub fn FLA_Gemv_external(
        transa: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        x: FLA_Obj,
        beta: FLA_Obj,
        y: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemvc_external(
        transa: FLA_Trans,
        conjx: FLA_Conj,
        alpha: FLA_Obj,
        A: FLA_Obj,
        x: FLA_Obj,
        beta: FLA_Obj,
        y: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Ger_external(alpha: FLA_Obj, x: FLA_Obj, y: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Gerc_external(
        conjx: FLA_Conj,
        conjy: FLA_Conj,
        alpha: FLA_Obj,
        x: FLA_Obj,
        y: FLA_Obj,
        A: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemv_external(
        uplo: FLA_Uplo,
        alpha: FLA_Obj,
        A: FLA_Obj,
        x: FLA_Obj,
        beta: FLA_Obj,
        y: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemvc_external(
        uplo: FLA_Uplo,
        conja: FLA_Conj,
        alpha: FLA_Obj,
        A: FLA_Obj,
        x: FLA_Obj,
        beta: FLA_Obj,
        y: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her_external(uplo: FLA_Uplo, alpha: FLA_Obj, x: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Herc_external(
        uplo: FLA_Uplo,
        conj: FLA_Conj,
        alpha: FLA_Obj,
        x: FLA_Obj,
        A: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2_external(
        uplo: FLA_Uplo,
        alpha: FLA_Obj,
        x: FLA_Obj,
        y: FLA_Obj,
        A: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2c_external(
        uplo: FLA_Uplo,
        conj: FLA_Conj,
        alpha: FLA_Obj,
        x: FLA_Obj,
        y: FLA_Obj,
        A: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Symv_external(
        uplo: FLA_Uplo,
        alpha: FLA_Obj,
        A: FLA_Obj,
        x: FLA_Obj,
        beta: FLA_Obj,
        y: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syr_external(uplo: FLA_Uplo, alpha: FLA_Obj, x: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Syr2_external(
        uplo: FLA_Uplo,
        alpha: FLA_Obj,
        x: FLA_Obj,
        y: FLA_Obj,
        A: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmv_external(
        uplo: FLA_Uplo,
        transa: FLA_Trans,
        diag: FLA_Diag,
        A: FLA_Obj,
        x: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmvsx_external(
        uplo: FLA_Uplo,
        transa: FLA_Trans,
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        x: FLA_Obj,
        beta: FLA_Obj,
        y: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsv_external(
        uplo: FLA_Uplo,
        transa: FLA_Trans,
        diag: FLA_Diag,
        A: FLA_Obj,
        x: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsvsx_external(
        uplo: FLA_Uplo,
        transa: FLA_Trans,
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        x: FLA_Obj,
        beta: FLA_Obj,
        y: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemv_external_gpu(
        transa: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        A_gpu: *mut c_void,
        x: FLA_Obj,
        x_gpu: *mut c_void,
        beta: FLA_Obj,
        y: FLA_Obj,
        y_gpu: *mut c_void,
    ) -> FLA_Error;
    pub fn FLA_Trsv_external_gpu(
        uplo: FLA_Uplo,
        transa: FLA_Trans,
        diag: FLA_Diag,
        A: FLA_Obj,
        A_gpu: *mut c_void,
        x: FLA_Obj,
        x_gpu: *mut c_void,
    ) -> FLA_Error;
    pub fn FLA_Gemv_check(
        transa: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        x: FLA_Obj,
        beta: FLA_Obj,
        y: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemvc_check(
        transa: FLA_Trans,
        conjx: FLA_Conj,
        alpha: FLA_Obj,
        A: FLA_Obj,
        x: FLA_Obj,
        beta: FLA_Obj,
        y: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Ger_check(alpha: FLA_Obj, x: FLA_Obj, y: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Gerc_check(
        conjx: FLA_Conj,
        conjy: FLA_Conj,
        alpha: FLA_Obj,
        x: FLA_Obj,
        y: FLA_Obj,
        A: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemv_check(
        uplo: FLA_Uplo,
        alpha: FLA_Obj,
        A: FLA_Obj,
        x: FLA_Obj,
        beta: FLA_Obj,
        y: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemvc_check(
        uplo: FLA_Uplo,
        conja: FLA_Conj,
        alpha: FLA_Obj,
        A: FLA_Obj,
        x: FLA_Obj,
        beta: FLA_Obj,
        y: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her_check(uplo: FLA_Uplo, alpha: FLA_Obj, x: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Herc_check(
        uplo: FLA_Uplo,
        conj: FLA_Conj,
        alpha: FLA_Obj,
        x: FLA_Obj,
        A: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2_check(
        uplo: FLA_Uplo,
        alpha: FLA_Obj,
        x: FLA_Obj,
        y: FLA_Obj,
        A: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2c_check(
        uplo: FLA_Uplo,
        conj: FLA_Conj,
        alpha: FLA_Obj,
        x: FLA_Obj,
        y: FLA_Obj,
        A: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Symv_check(
        uplo: FLA_Uplo,
        alpha: FLA_Obj,
        A: FLA_Obj,
        x: FLA_Obj,
        beta: FLA_Obj,
        y: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syr_check(uplo: FLA_Uplo, alpha: FLA_Obj, x: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Syr2_check(
        uplo: FLA_Uplo,
        alpha: FLA_Obj,
        x: FLA_Obj,
        y: FLA_Obj,
        A: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmv_check(
        uplo: FLA_Uplo,
        transa: FLA_Trans,
        diag: FLA_Diag,
        A: FLA_Obj,
        x: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmvsx_check(
        uplo: FLA_Uplo,
        transa: FLA_Trans,
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        x: FLA_Obj,
        beta: FLA_Obj,
        y: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsv_check(
        uplo: FLA_Uplo,
        transa: FLA_Trans,
        diag: FLA_Diag,
        A: FLA_Obj,
        x: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsvsx_check(
        uplo: FLA_Uplo,
        transa: FLA_Trans,
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        x: FLA_Obj,
        beta: FLA_Obj,
        y: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemv_internal_check(
        transa: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        x: FLA_Obj,
        beta: FLA_Obj,
        y: FLA_Obj,
        cntl: *mut fla_gemv_t,
    ) -> FLA_Error;
    pub fn FLA_Trsv_internal_check(
        uplo: FLA_Uplo,
        transa: FLA_Trans,
        diag: FLA_Diag,
        A: FLA_Obj,
        x: FLA_Obj,
        cntl: *mut fla_trsv_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm(
        transa: FLA_Trans,
        transb: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemm(
        side: FLA_Side,
        uplo: FLA_Uplo,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Herk(
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2k(
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Symm(
        side: FLA_Side,
        uplo: FLA_Uplo,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syrk(
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syr2k(
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm(
        side: FLA_Side,
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmmsx(
        side: FLA_Side,
        uplo: FLA_Uplo,
        transa: FLA_Trans,
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm(
        side: FLA_Side,
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsmsx(
        side: FLA_Side,
        uplo: FLA_Uplo,
        transa: FLA_Trans,
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemp(
        transa: FLA_Trans,
        transb: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gepm(
        transa: FLA_Trans,
        transb: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gepp(
        transa: FLA_Trans,
        transb: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_task(
        transa: FLA_Trans,
        transb: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_task(
        side: FLA_Side,
        uplo: FLA_Uplo,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Herk_task(
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_herk_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_task(
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_task(
        side: FLA_Side,
        uplo: FLA_Uplo,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Syrk_task(
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syrk_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_task(
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_task(
        side: FLA_Side,
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_task(
        side: FLA_Side,
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_cc_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_ch_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_cn_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_ct_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_hc_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_hh_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_hn_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_ht_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nc_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nh_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nn_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nt_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_tc_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_th_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_tn_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_tt_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_ll_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_lu_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_rl_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_ru_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_ln_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_lh_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_un_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_uh_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Herk_ln_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_herk_t,
    ) -> FLA_Error;
    pub fn FLA_Herk_lh_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_herk_t,
    ) -> FLA_Error;
    pub fn FLA_Herk_un_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_herk_t,
    ) -> FLA_Error;
    pub fn FLA_Herk_uh_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_herk_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_ll_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_lu_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_rl_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_ru_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_ln_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_lt_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_un_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_ut_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syrk_ln_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syrk_t,
    ) -> FLA_Error;
    pub fn FLA_Syrk_lt_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syrk_t,
    ) -> FLA_Error;
    pub fn FLA_Syrk_un_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syrk_t,
    ) -> FLA_Error;
    pub fn FLA_Syrk_ut_task(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syrk_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_llc_task(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_llh_task(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_lln_task(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_llt_task(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_luc_task(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_luh_task(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_lun_task(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_lut_task(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rlc_task(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rlh_task(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rln_task(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rlt_task(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_ruc_task(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_ruh_task(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_run_task(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rut_task(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_llc_task(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_llh_task(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_lln_task(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_llt_task(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_luc_task(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_luh_task(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_lun_task(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_lut_task(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rlc_task(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rlh_task(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rln_task(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rlt_task(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_ruc_task(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_ruh_task(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_run_task(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rut_task(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_external(
        transa: FLA_Trans,
        transb: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemm_external(
        side: FLA_Side,
        uplo: FLA_Uplo,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Herk_external(
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2k_external(
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Symm_external(
        side: FLA_Side,
        uplo: FLA_Uplo,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syrk_external(
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_external(
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_external(
        side: FLA_Side,
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_external(
        side: FLA_Side,
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmmsx_external(
        side: FLA_Side,
        uplo: FLA_Uplo,
        transa: FLA_Trans,
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsmsx_external(
        side: FLA_Side,
        uplo: FLA_Uplo,
        transa: FLA_Trans,
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_external_gpu(
        transa: FLA_Trans,
        transb: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        A_gpu: *mut c_void,
        B: FLA_Obj,
        B_gpu: *mut c_void,
        beta: FLA_Obj,
        C: FLA_Obj,
        C_gpu: *mut c_void,
    ) -> FLA_Error;
    pub fn FLA_Hemm_external_gpu(
        side: FLA_Side,
        uplo: FLA_Uplo,
        alpha: FLA_Obj,
        A: FLA_Obj,
        A_gpu: *mut c_void,
        B: FLA_Obj,
        B_gpu: *mut c_void,
        beta: FLA_Obj,
        C: FLA_Obj,
        C_gpu: *mut c_void,
    ) -> FLA_Error;
    pub fn FLA_Herk_external_gpu(
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        A_gpu: *mut c_void,
        beta: FLA_Obj,
        C: FLA_Obj,
        C_gpu: *mut c_void,
    ) -> FLA_Error;
    pub fn FLA_Her2k_external_gpu(
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        A_gpu: *mut c_void,
        B: FLA_Obj,
        B_gpu: *mut c_void,
        beta: FLA_Obj,
        C: FLA_Obj,
        C_gpu: *mut c_void,
    ) -> FLA_Error;
    pub fn FLA_Symm_external_gpu(
        side: FLA_Side,
        uplo: FLA_Uplo,
        alpha: FLA_Obj,
        A: FLA_Obj,
        A_gpu: *mut c_void,
        B: FLA_Obj,
        B_gpu: *mut c_void,
        beta: FLA_Obj,
        C: FLA_Obj,
        C_gpu: *mut c_void,
    ) -> FLA_Error;
    pub fn FLA_Syrk_external_gpu(
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        A_gpu: *mut c_void,
        beta: FLA_Obj,
        C: FLA_Obj,
        C_gpu: *mut c_void,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_external_gpu(
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        A_gpu: *mut c_void,
        B: FLA_Obj,
        B_gpu: *mut c_void,
        beta: FLA_Obj,
        C: FLA_Obj,
        C_gpu: *mut c_void,
    ) -> FLA_Error;
    pub fn FLA_Trmm_external_gpu(
        side: FLA_Side,
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        A_gpu: *mut c_void,
        B: FLA_Obj,
        B_gpu: *mut c_void,
    ) -> FLA_Error;
    pub fn FLA_Trsm_external_gpu(
        side: FLA_Side,
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        A_gpu: *mut c_void,
        B: FLA_Obj,
        B_gpu: *mut c_void,
    ) -> FLA_Error;
    pub fn FLA_Gemm_check(
        transa: FLA_Trans,
        transb: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemm_check(
        side: FLA_Side,
        uplo: FLA_Uplo,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2k_check(
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Herk_check(
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Symm_check(
        side: FLA_Side,
        uplo: FLA_Uplo,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_check(
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syrk_check(
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_check(
        side: FLA_Side,
        uplo: FLA_Uplo,
        transa: FLA_Trans,
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmmsx_check(
        side: FLA_Side,
        uplo: FLA_Uplo,
        transa: FLA_Trans,
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_check(
        side: FLA_Side,
        uplo: FLA_Uplo,
        transa: FLA_Trans,
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsmsx_check(
        side: FLA_Side,
        uplo: FLA_Uplo,
        transa: FLA_Trans,
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_internal_check(
        transa: FLA_Trans,
        transb: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_internal_check(
        side: FLA_Side,
        uplo: FLA_Uplo,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Herk_internal_check(
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_herk_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_internal_check(
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_internal_check(
        side: FLA_Side,
        uplo: FLA_Uplo,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Syrk_internal_check(
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syrk_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_internal_check(
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_internal_check(
        side: FLA_Side,
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_internal_check(
        side: FLA_Side,
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Chol(uplo: FLA_Uplo, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_LU_nopiv(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_LU_piv(A: FLA_Obj, p: FLA_Obj) -> FLA_Error;
    pub fn FLA_QR_UT(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_QR_UT_piv(A: FLA_Obj, T: FLA_Obj, w: FLA_Obj, p: FLA_Obj) -> FLA_Error;
    pub fn FLA_LQ_UT(A: FLA_Obj, S: FLA_Obj) -> FLA_Error;
    pub fn FLA_Trinv(uplo: FLA_Uplo, diag: FLA_Diag, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Ttmm(uplo: FLA_Uplo, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Sylv(
        transa: FLA_Trans,
        transb: FLA_Trans,
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_SPDinv(uplo: FLA_Uplo, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Hess_UT(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest(inv: FLA_Inv, uplo: FLA_Uplo, A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Accum_T_UT(
        direct: FLA_Direct,
        storev: FLA_Store,
        A: FLA_Obj,
        tau: FLA_Obj,
        T: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Apply_H2_UT(
        side: FLA_Side,
        tau: FLA_Obj,
        u2: FLA_Obj,
        a1: FLA_Obj,
        A2: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Apply_HUD_UT(
        side: FLA_Side,
        tau: FLA_Obj,
        w12t: FLA_Obj,
        u2: FLA_Obj,
        v2: FLA_Obj,
        r12t: FLA_Obj,
        C2: FLA_Obj,
        D2: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT(
        side: FLA_Side,
        trans: FLA_Trans,
        direct: FLA_Direct,
        storev: FLA_Store,
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Apply_pivots(side: FLA_Side, trans: FLA_Trans, p: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Chol_task(uplo: FLA_Uplo, A: FLA_Obj, cntl: *mut fla_chol_t) -> FLA_Error;
    pub fn FLA_Chol_l_task(A: FLA_Obj, cntl: *mut fla_chol_t) -> FLA_Error;
    pub fn FLA_Chol_u_task(A: FLA_Obj, cntl: *mut fla_chol_t) -> FLA_Error;
    pub fn FLA_LU_piv_macro_task(A: FLA_Obj, p: FLA_Obj, cntl: *mut fla_lu_t) -> FLA_Error;
    pub fn FLA_Apply_pivots_task(
        side: FLA_Side,
        trans: FLA_Trans,
        p: FLA_Obj,
        A: FLA_Obj,
        cntl: *mut fla_appiv_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_pivots_ln_task(p: FLA_Obj, A: FLA_Obj, cntl: *mut fla_appiv_t) -> FLA_Error;
    pub fn FLA_Apply_pivots_macro_task(
        side: FLA_Side,
        trans: FLA_Trans,
        p: FLA_Obj,
        A: FLA_Obj,
        cntl: *mut fla_appiv_t,
    ) -> FLA_Error;
    pub fn FLA_LU_nopiv_task(A: FLA_Obj, cntl: *mut fla_lu_t) -> FLA_Error;
    pub fn FLA_LU_piv_task(A: FLA_Obj, p: FLA_Obj, cntl: *mut fla_lu_t) -> FLA_Error;
    pub fn FLA_LU_piv_copy_task(
        A: FLA_Obj,
        p: FLA_Obj,
        U: FLA_Obj,
        cntl: *mut fla_lu_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_piv_task(
        A: FLA_Obj,
        B: FLA_Obj,
        p: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_SA_LU_task(
        U: FLA_Obj,
        D: FLA_Obj,
        p: FLA_Obj,
        L: FLA_Obj,
        nb_alg: fla_dim_t,
        cntl: *mut fla_lu_t,
    ) -> FLA_Error;
    pub fn FLA_SA_FS_task(
        L: FLA_Obj,
        D: FLA_Obj,
        p: FLA_Obj,
        C: FLA_Obj,
        E: FLA_Obj,
        nb_alg: fla_dim_t,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Trinv_task(
        uplo: FLA_Uplo,
        diag: FLA_Diag,
        A: FLA_Obj,
        cntl: *mut fla_trinv_t,
    ) -> FLA_Error;
    pub fn FLA_Trinv_ln_task(A: FLA_Obj, cntl: *mut fla_trinv_t) -> FLA_Error;
    pub fn FLA_Trinv_lu_task(A: FLA_Obj, cntl: *mut fla_trinv_t) -> FLA_Error;
    pub fn FLA_Trinv_un_task(A: FLA_Obj, cntl: *mut fla_trinv_t) -> FLA_Error;
    pub fn FLA_Trinv_uu_task(A: FLA_Obj, cntl: *mut fla_trinv_t) -> FLA_Error;
    pub fn FLA_Ttmm_task(uplo: FLA_Uplo, A: FLA_Obj, cntl: *mut fla_ttmm_t) -> FLA_Error;
    pub fn FLA_Ttmm_l_task(A: FLA_Obj, cntl: *mut fla_ttmm_t) -> FLA_Error;
    pub fn FLA_Ttmm_u_task(A: FLA_Obj, cntl: *mut fla_ttmm_t) -> FLA_Error;
    pub fn FLA_Sylv_task(
        transa: FLA_Trans,
        transb: FLA_Trans,
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nn_task(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nh_task(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hn_task(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hh_task(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Lyap_task(
        trans: FLA_Trans,
        isgn: FLA_Obj,
        A: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_lyap_t,
    ) -> FLA_Error;
    pub fn FLA_Lyap_n_task(
        isgn: FLA_Obj,
        A: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_lyap_t,
    ) -> FLA_Error;
    pub fn FLA_Lyap_h_task(
        isgn: FLA_Obj,
        A: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_lyap_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_task(
        side: FLA_Side,
        trans: FLA_Trans,
        direct: FLA_Direct,
        storev: FLA_Store,
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_lhbc_task(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_lhbr_task(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_lhfc_task(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_lhfr_task(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_lnbc_task(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_lnbr_task(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_lnfc_task(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_lnfr_task(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_rhbc_task(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_rhbr_task(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_rhfc_task(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_rhfr_task(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_rnbc_task(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_rnbr_task(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_rnfc_task(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_rnfr_task(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q2_UT_task(
        side: FLA_Side,
        trans: FLA_Trans,
        direct: FLA_Direct,
        storev: FLA_Store,
        D: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        C: FLA_Obj,
        E: FLA_Obj,
        cntl: *mut fla_apq2ut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q2_UT_lhfc_task(
        D: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        C: FLA_Obj,
        E: FLA_Obj,
        cntl: *mut fla_apq2ut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_CAQ2_UT_task(
        side: FLA_Side,
        trans: FLA_Trans,
        direct: FLA_Direct,
        storev: FLA_Store,
        D: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        C: FLA_Obj,
        E: FLA_Obj,
        cntl: *mut fla_apcaq2ut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_CAQ2_UT_lhfc_task(
        D: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        C: FLA_Obj,
        E: FLA_Obj,
        cntl: *mut fla_apcaq2ut_t,
    ) -> FLA_Error;
    pub fn FLA_QR2_UT_task(B: FLA_Obj, D: FLA_Obj, T: FLA_Obj, cntl: *mut fla_qr2ut_t)
        -> FLA_Error;
    pub fn FLA_CAQR2_UT_task(
        B: FLA_Obj,
        D: FLA_Obj,
        T: FLA_Obj,
        cntl: *mut fla_caqr2ut_t,
    ) -> FLA_Error;
    pub fn FLA_QR_UT_macro_task(A: FLA_Obj, T: FLA_Obj, cntl: *mut fla_qrut_t) -> FLA_Error;
    pub fn FLA_QR_UT_task(A: FLA_Obj, T: FLA_Obj, cntl: *mut fla_qrut_t) -> FLA_Error;
    pub fn FLA_QR_UT_copy_task(
        A: FLA_Obj,
        T: FLA_Obj,
        U: FLA_Obj,
        cntl: *mut fla_qrut_t,
    ) -> FLA_Error;
    pub fn FLA_LQ_UT_macro_task(A: FLA_Obj, T: FLA_Obj, cntl: *mut fla_lqut_t) -> FLA_Error;
    pub fn FLA_LQ_UT_task(A: FLA_Obj, T: FLA_Obj, cntl: *mut fla_lqut_t) -> FLA_Error;
    pub fn FLA_UDdate_UT_task(
        R: FLA_Obj,
        C: FLA_Obj,
        D: FLA_Obj,
        T: FLA_Obj,
        cntl: *mut fla_uddateut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_QUD_UT_task(
        side: FLA_Side,
        trans: FLA_Trans,
        direct: FLA_Direct,
        storev: FLA_Store,
        T: FLA_Obj,
        W: FLA_Obj,
        R: FLA_Obj,
        U: FLA_Obj,
        C: FLA_Obj,
        V: FLA_Obj,
        D: FLA_Obj,
        cntl: *mut fla_apqudut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_QUD_UT_lhfc_task(
        T: FLA_Obj,
        W: FLA_Obj,
        R: FLA_Obj,
        U: FLA_Obj,
        C: FLA_Obj,
        V: FLA_Obj,
        D: FLA_Obj,
        cntl: *mut fla_apqudut_t,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_task(
        inv: FLA_Inv,
        uplo: FLA_Uplo,
        A: FLA_Obj,
        Y: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_eig_gest_t,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_il_task(
        A: FLA_Obj,
        Y: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_eig_gest_t,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_iu_task(
        A: FLA_Obj,
        Y: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_eig_gest_t,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nl_task(
        A: FLA_Obj,
        Y: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_eig_gest_t,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nu_task(
        A: FLA_Obj,
        Y: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_eig_gest_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_blk_external(
        side: FLA_Side,
        trans: FLA_Trans,
        storev: FLA_Store,
        A: FLA_Obj,
        t: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Apply_pivots_unb_external(
        side: FLA_Side,
        trans: FLA_Trans,
        p: FLA_Obj,
        A: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Apply_pivots_ln_unb_ext(p: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Apply_pivots_macro_external(
        side: FLA_Side,
        trans: FLA_Trans,
        p: FLA_Obj,
        A: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Chol_blk_external(uplo: FLA_Uplo, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Chol_l_blk_ext(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Chol_u_blk_ext(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Chol_unb_external(uplo: FLA_Uplo, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Chol_l_unb_ext(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Chol_u_unb_ext(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_LU_piv_blk_external(A: FLA_Obj, p: FLA_Obj) -> FLA_Error;
    pub fn FLA_LU_piv_blk_ext(A: FLA_Obj, p: FLA_Obj) -> FLA_Error;
    pub fn FLA_LU_piv_unb_external(A: FLA_Obj, p: FLA_Obj) -> FLA_Error;
    pub fn FLA_LU_piv_unb_ext(A: FLA_Obj, p: FLA_Obj) -> FLA_Error;
    pub fn FLA_QR_blk_external(A: FLA_Obj, t: FLA_Obj) -> FLA_Error;
    pub fn FLA_QR_unb_external(A: FLA_Obj, t: FLA_Obj) -> FLA_Error;
    pub fn FLA_LQ_blk_external(A: FLA_Obj, t: FLA_Obj) -> FLA_Error;
    pub fn FLA_LQ_unb_external(A: FLA_Obj, t: FLA_Obj) -> FLA_Error;
    pub fn FLA_Hess_blk_external(A: FLA_Obj, t: FLA_Obj, ilo: integer, ihi: integer) -> FLA_Error;
    pub fn FLA_Hess_unb_external(A: FLA_Obj, t: FLA_Obj, ilo: integer, ihi: integer) -> FLA_Error;
    pub fn FLA_Tridiag_blk_external(uplo: FLA_Uplo, A: FLA_Obj, t: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_unb_external(uplo: FLA_Uplo, A: FLA_Obj, t: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_blk_external(A: FLA_Obj, tu: FLA_Obj, tv: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_unb_external(A: FLA_Obj, tu: FLA_Obj, tv: FLA_Obj) -> FLA_Error;
    pub fn FLA_QR_form_Q_external(A: FLA_Obj, t: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_form_Q_external(uplo: FLA_Uplo, A: FLA_Obj, t: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_apply_Q_external(
        side: FLA_Side,
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        A: FLA_Obj,
        t: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_form_U_external(A: FLA_Obj, t: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_form_V_external(A: FLA_Obj, t: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_apply_U_external(
        side: FLA_Side,
        trans: FLA_Trans,
        A: FLA_Obj,
        t: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_apply_V_external(
        side: FLA_Side,
        trans: FLA_Trans,
        A: FLA_Obj,
        t: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trinv_blk_external(uplo: FLA_Uplo, diag: FLA_Diag, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Trinv_ln_blk_ext(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Trinv_lu_blk_ext(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Trinv_un_blk_ext(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Trinv_uu_blk_ext(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Trinv_unb_external(uplo: FLA_Uplo, diag: FLA_Diag, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Trinv_ln_unb_ext(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Trinv_lu_unb_ext(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Trinv_un_unb_ext(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Trinv_uu_unb_ext(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Ttmm_blk_external(uplo: FLA_Uplo, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Ttmm_l_blk_ext(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Ttmm_u_blk_ext(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Ttmm_unb_external(uplo: FLA_Uplo, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Ttmm_l_unb_ext(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Ttmm_u_unb_ext(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Sylv_blk_external(
        transa: FLA_Trans,
        transb: FLA_Trans,
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nn_blk_ext(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nh_blk_ext(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hn_blk_ext(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hh_blk_ext(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_unb_external(
        transa: FLA_Trans,
        transb: FLA_Trans,
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nn_unb_ext(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nh_unb_ext(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hn_unb_ext(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hh_unb_ext(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_SPDinv_blk_external(uplo: FLA_Uplo, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_blk_external(
        inv: FLA_Inv,
        uplo: FLA_Uplo,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_il_blk_ext(A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_iu_blk_ext(A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_nl_blk_ext(A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_nu_blk_ext(A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_unb_external(
        inv: FLA_Inv,
        uplo: FLA_Uplo,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_il_unb_ext(A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_iu_unb_ext(A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_nl_unb_ext(A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_nu_unb_ext(A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tevd_external(jobz: FLA_Evd_type, d: FLA_Obj, e: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tevdd_external(jobz: FLA_Evd_type, d: FLA_Obj, e: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tevdr_external(
        jobz: FLA_Evd_type,
        d: FLA_Obj,
        e: FLA_Obj,
        l: FLA_Obj,
        A: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hevd_external(
        jobz: FLA_Evd_type,
        uplo: FLA_Uplo,
        A: FLA_Obj,
        l: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hevdd_external(
        jobz: FLA_Evd_type,
        uplo: FLA_Uplo,
        A: FLA_Obj,
        l: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hevdr_external(
        jobz: FLA_Evd_type,
        uplo: FLA_Uplo,
        A: FLA_Obj,
        l: FLA_Obj,
        Z: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Bsvd_external(
        uplo: FLA_Uplo,
        d: FLA_Obj,
        e: FLA_Obj,
        U: FLA_Obj,
        V: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Bsvdd_external(
        uplo: FLA_Uplo,
        d: FLA_Obj,
        e: FLA_Obj,
        U: FLA_Obj,
        V: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Svd_external(
        jobu: FLA_Svd_type,
        jobv: FLA_Svd_type,
        A: FLA_Obj,
        s: FLA_Obj,
        U: FLA_Obj,
        V: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Svdd_external(
        jobz: FLA_Svd_type,
        A: FLA_Obj,
        s: FLA_Obj,
        U: FLA_Obj,
        V: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Chol_check(uplo: FLA_Uplo, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Chol_solve_check(uplo: FLA_Uplo, A: FLA_Obj, B: FLA_Obj, X: FLA_Obj) -> FLA_Error;
    pub fn FLA_LU_nopiv_check(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_LU_nopiv_solve_check(A: FLA_Obj, B: FLA_Obj, X: FLA_Obj) -> FLA_Error;
    pub fn FLA_LU_piv_check(A: FLA_Obj, p: FLA_Obj) -> FLA_Error;
    pub fn FLA_LU_piv_solve_check(A: FLA_Obj, p: FLA_Obj, B: FLA_Obj, X: FLA_Obj) -> FLA_Error;
    pub fn FLA_LU_incpiv_check(A: FLA_Obj, p: FLA_Obj, L: FLA_Obj) -> FLA_Error;
    pub fn FLA_LU_incpiv_solve_check(
        A: FLA_Obj,
        p: FLA_Obj,
        L: FLA_Obj,
        B: FLA_Obj,
        X: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_FS_incpiv_check(A: FLA_Obj, p: FLA_Obj, L: FLA_Obj, b: FLA_Obj) -> FLA_Error;
    pub fn FLA_QR_check(A: FLA_Obj, t: FLA_Obj) -> FLA_Error;
    pub fn FLA_QR_UT_check(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_QR_UT_solve_check(A: FLA_Obj, T: FLA_Obj, B: FLA_Obj, X: FLA_Obj) -> FLA_Error;
    pub fn FLA_QR_UT_recover_tau_check(T: FLA_Obj, tau: FLA_Obj) -> FLA_Error;
    pub fn FLA_QR_UT_form_Q_check(A: FLA_Obj, T: FLA_Obj, Q: FLA_Obj) -> FLA_Error;
    pub fn FLA_LQ_check(A: FLA_Obj, t: FLA_Obj) -> FLA_Error;
    pub fn FLA_LQ_UT_check(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_LQ_UT_solve_check(A: FLA_Obj, T: FLA_Obj, B: FLA_Obj, X: FLA_Obj) -> FLA_Error;
    pub fn FLA_LQ_UT_recover_tau_check(T: FLA_Obj, tau: FLA_Obj) -> FLA_Error;
    pub fn FLA_LQ_UT_form_Q_check(A: FLA_Obj, T: FLA_Obj, Q: FLA_Obj) -> FLA_Error;
    pub fn FLA_Hess_check(A: FLA_Obj, t: FLA_Obj, ilo: integer, ihi: integer) -> FLA_Error;
    pub fn FLA_Hess_UT_check(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Hess_UT_recover_tau_check(T: FLA_Obj, tau: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_check(uplo: FLA_Uplo, A: FLA_Obj, t: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_UT_check(uplo: FLA_Uplo, A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_UT_recover_tau_check(T: FLA_Obj, tau: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_UT_scale_diagonals_check(
        uplo: FLA_Uplo,
        alpha: FLA_Obj,
        A: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Tridiag_UT_extract_diagonals_check(
        uplo: FLA_Uplo,
        A: FLA_Obj,
        d: FLA_Obj,
        e: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Tridiag_UT_extract_real_diagonals_check(
        uplo: FLA_Uplo,
        A: FLA_Obj,
        d: FLA_Obj,
        e: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Tridiag_UT_realify_check(uplo: FLA_Uplo, A: FLA_Obj, d: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_UT_realify_subdiagonal_check(b: FLA_Obj, d: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_UT_shift_U_check(uplo: FLA_Uplo, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_UT_form_Q_check(
        uplo: FLA_Uplo,
        A: FLA_Obj,
        T: FLA_Obj,
        Q: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trinv_check(uplo: FLA_Uplo, diag: FLA_Diag, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_check(A: FLA_Obj, tu: FLA_Obj, tv: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_check(A: FLA_Obj, TU: FLA_Obj, TV: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_recover_tau_check(
        TU: FLA_Obj,
        TV: FLA_Obj,
        tu: FLA_Obj,
        tv: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_extract_diagonals_check(A: FLA_Obj, d: FLA_Obj, e: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_extract_real_diagonals_check(
        A: FLA_Obj,
        d: FLA_Obj,
        e: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_scale_diagonals_check(alpha: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_realify_check(A: FLA_Obj, d: FLA_Obj, e: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_realify_diagonals_check(
        uplo: FLA_Uplo,
        a: FLA_Obj,
        b: FLA_Obj,
        d: FLA_Obj,
        e: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_form_U_check(A: FLA_Obj, T: FLA_Obj, U: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_form_V_check(A: FLA_Obj, S: FLA_Obj, V: FLA_Obj) -> FLA_Error;
    pub fn FLA_Ttmm_check(uplo: FLA_Uplo, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Sylv_check(
        transa: FLA_Trans,
        transb: FLA_Trans,
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Lyap_check(
        trans: FLA_Trans,
        isgn: FLA_Obj,
        A: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_SPDinv_check(uplo: FLA_Uplo, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_check(inv: FLA_Inv, uplo: FLA_Uplo, A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Apply_Q_check(
        side: FLA_Side,
        trans: FLA_Trans,
        storev: FLA_Store,
        A: FLA_Obj,
        t: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_QR_form_Q_check(A: FLA_Obj, t: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_form_Q_check(uplo: FLA_Uplo, A: FLA_Obj, t: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_apply_Q_check(
        side: FLA_Side,
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        A: FLA_Obj,
        t: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_form_U_check(A: FLA_Obj, t: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_form_V_check(A: FLA_Obj, t: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_apply_U_check(
        side: FLA_Side,
        trans: FLA_Trans,
        A: FLA_Obj,
        t: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_apply_V_check(
        side: FLA_Side,
        trans: FLA_Trans,
        A: FLA_Obj,
        t: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_check(
        side: FLA_Side,
        trans: FLA_Trans,
        direct: FLA_Direct,
        storev: FLA_Store,
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q2_UT_check(
        side: FLA_Side,
        trans: FLA_Trans,
        direct: FLA_Direct,
        storev: FLA_Store,
        D: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        C: FLA_Obj,
        E: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Apply_QUD_UT_check(
        side: FLA_Side,
        trans: FLA_Trans,
        direct: FLA_Direct,
        storev: FLA_Store,
        T: FLA_Obj,
        W: FLA_Obj,
        R: FLA_Obj,
        U: FLA_Obj,
        C: FLA_Obj,
        V: FLA_Obj,
        D: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Apply_pivots_check(
        side: FLA_Side,
        trans: FLA_Trans,
        p: FLA_Obj,
        A: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_QR2_UT_check(B: FLA_Obj, D: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_CAQR2_UT_check(B: FLA_Obj, D: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_QR_UT_inc_check(A: FLA_Obj, TW: FLA_Obj) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_inc_check(
        side: FLA_Side,
        trans: FLA_Trans,
        direct: FLA_Direct,
        storev: FLA_Store,
        A: FLA_Obj,
        TW: FLA_Obj,
        W1: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Apply_CAQ_UT_inc_check(
        side: FLA_Side,
        trans: FLA_Trans,
        direct: FLA_Direct,
        storev: FLA_Store,
        A: FLA_Obj,
        ATW: FLA_Obj,
        R: FLA_Obj,
        RTW: FLA_Obj,
        W1: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_QR_UT_inc_solve_check(A: FLA_Obj, TW: FLA_Obj, B: FLA_Obj, X: FLA_Obj) -> FLA_Error;
    pub fn FLA_CAQR_UT_inc_solve_check(
        p: fla_dim_t,
        A: FLA_Obj,
        ATW: FLA_Obj,
        R: FLA_Obj,
        RTW: FLA_Obj,
        B: FLA_Obj,
        X: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_UDdate_UT_check(R: FLA_Obj, C: FLA_Obj, D: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_UDdate_UT_update_rhs_check(
        T: FLA_Obj,
        bR: FLA_Obj,
        C: FLA_Obj,
        bC: FLA_Obj,
        D: FLA_Obj,
        bD: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_UDdate_UT_solve_check(R: FLA_Obj, bR: FLA_Obj, x: FLA_Obj) -> FLA_Error;
    pub fn FLA_UDdate_UT_inc_check(
        R: FLA_Obj,
        C: FLA_Obj,
        D: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_UDdate_UT_inc_update_rhs_check(
        T: FLA_Obj,
        bR: FLA_Obj,
        C: FLA_Obj,
        bC: FLA_Obj,
        D: FLA_Obj,
        bD: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_UDdate_UT_inc_solve_check(R: FLA_Obj, bR: FLA_Obj, x: FLA_Obj) -> FLA_Error;
    pub fn FLA_CAQR_UT_inc_check(
        p: fla_dim_t,
        A: FLA_Obj,
        ATW: FLA_Obj,
        R: FLA_Obj,
        RTW: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Apply_QUD_UT_inc_check(
        side: FLA_Side,
        trans: FLA_Trans,
        direct: FLA_Direct,
        storev: FLA_Store,
        T: FLA_Obj,
        W: FLA_Obj,
        R: FLA_Obj,
        U: FLA_Obj,
        C: FLA_Obj,
        V: FLA_Obj,
        D: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Apply_H2_UT_check(
        side: FLA_Side,
        tau: FLA_Obj,
        u2: FLA_Obj,
        a1t: FLA_Obj,
        A2: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Apply_HUD_UT_check(
        side: FLA_Side,
        tau: FLA_Obj,
        w12t: FLA_Obj,
        u2: FLA_Obj,
        v2: FLA_Obj,
        r12t: FLA_Obj,
        C2: FLA_Obj,
        D2: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Accum_T_UT_check(
        direct: FLA_Direct,
        storev: FLA_Store,
        A: FLA_Obj,
        tau: FLA_Obj,
        T: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Tevd_compute_scaling_check(d: FLA_Obj, e: FLA_Obj, sigma: FLA_Obj) -> FLA_Error;
    pub fn FLA_Hevd_compute_scaling_check(uplo: FLA_Uplo, A: FLA_Obj, sigma: FLA_Obj) -> FLA_Error;
    pub fn FLA_Hevd_check(jobz: FLA_Evd_type, uplo: FLA_Uplo, A: FLA_Obj, l: FLA_Obj) -> FLA_Error;
    pub fn FLA_Hevdd_check(jobz: FLA_Evd_type, uplo: FLA_Uplo, A: FLA_Obj, l: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Hevdr_check(
        jobz: FLA_Evd_type,
        uplo: FLA_Uplo,
        A: FLA_Obj,
        l: FLA_Obj,
        Z: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Bsvd_check(
        uplo: FLA_Uplo,
        d: FLA_Obj,
        e: FLA_Obj,
        G: FLA_Obj,
        H: FLA_Obj,
        jobu: FLA_Svd_type,
        U: FLA_Obj,
        jobv: FLA_Svd_type,
        V: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Bsvd_ext_check(
        uplo: FLA_Uplo,
        d: FLA_Obj,
        e: FLA_Obj,
        G: FLA_Obj,
        H: FLA_Obj,
        jobu: FLA_Svd_type,
        U: FLA_Obj,
        jobv: FLA_Svd_type,
        V: FLA_Obj,
        apply_Uh2C: FLA_Bool,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Bsvd_compute_scaling_check(d: FLA_Obj, e: FLA_Obj, sigma: FLA_Obj) -> FLA_Error;
    pub fn FLA_Svd_compute_scaling_check(A: FLA_Obj, sigma: FLA_Obj) -> FLA_Error;
    pub fn FLA_Svd_check(
        jobu: FLA_Svd_type,
        jobv: FLA_Svd_type,
        A: FLA_Obj,
        s: FLA_Obj,
        U: FLA_Obj,
        V: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Svd_ext_check(
        jobu: FLA_Svd_type,
        transu: FLA_Trans,
        jobv: FLA_Svd_type,
        transv: FLA_Trans,
        A: FLA_Obj,
        s: FLA_Obj,
        U: FLA_Obj,
        V: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Svdd_check(
        jobz: FLA_Svd_type,
        A: FLA_Obj,
        s: FLA_Obj,
        U: FLA_Obj,
        V: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Chol_internal_check(uplo: FLA_Uplo, A: FLA_Obj, cntl: *mut fla_chol_t) -> FLA_Error;
    pub fn FLA_LU_nopiv_internal_check(A: FLA_Obj, cntl: *mut fla_lu_t) -> FLA_Error;
    pub fn FLA_Trinv_internal_check(
        uplo: FLA_Uplo,
        diag: FLA_Diag,
        A: FLA_Obj,
        cntl: *mut fla_trinv_t,
    ) -> FLA_Error;
    pub fn FLA_Ttmm_internal_check(uplo: FLA_Uplo, A: FLA_Obj, cntl: *mut fla_ttmm_t) -> FLA_Error;
    pub fn FLA_SPDinv_internal_check(
        uplo: FLA_Uplo,
        A: FLA_Obj,
        cntl: *mut fla_spdinv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_internal_check(
        transa: FLA_Trans,
        transb: FLA_Trans,
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Lyap_internal_check(
        trans: FLA_Trans,
        isgn: FLA_Obj,
        A: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_lyap_t,
    ) -> FLA_Error;
    pub fn FLA_QR_UT_internal_check(A: FLA_Obj, T: FLA_Obj, cntl: *mut fla_qrut_t) -> FLA_Error;
    pub fn FLA_QR_UT_copy_internal_check(
        A: FLA_Obj,
        T: FLA_Obj,
        U: FLA_Obj,
        cntl: *mut fla_qrut_t,
    ) -> FLA_Error;
    pub fn FLA_QR2_UT_internal_check(
        B: FLA_Obj,
        D: FLA_Obj,
        T: FLA_Obj,
        cntl: *mut fla_qr2ut_t,
    ) -> FLA_Error;
    pub fn FLA_CAQR2_UT_internal_check(
        B: FLA_Obj,
        D: FLA_Obj,
        T: FLA_Obj,
        cntl: *mut fla_caqr2ut_t,
    ) -> FLA_Error;
    pub fn FLA_LQ_UT_internal_check(A: FLA_Obj, T: FLA_Obj, cntl: *mut fla_lqut_t) -> FLA_Error;
    pub fn FLA_Hess_UT_internal_check(A: FLA_Obj, T: FLA_Obj, cntl: *mut fla_hessut_t)
        -> FLA_Error;
    pub fn FLA_Tridiag_UT_internal_check(
        uplo: FLA_Uplo,
        A: FLA_Obj,
        T: FLA_Obj,
        cntl: *mut fla_tridiagut_t,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_internal_check(
        A: FLA_Obj,
        TU: FLA_Obj,
        TV: FLA_Obj,
        cntl: *mut fla_bidiagut_t,
    ) -> FLA_Error;
    pub fn FLA_UDdate_UT_internal_check(
        R: FLA_Obj,
        C: FLA_Obj,
        D: FLA_Obj,
        T: FLA_Obj,
        cntl: *mut fla_uddateut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_internal_check(
        side: FLA_Side,
        trans: FLA_Trans,
        direct: FLA_Direct,
        storev: FLA_Store,
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q2_UT_internal_check(
        side: FLA_Side,
        trans: FLA_Trans,
        direct: FLA_Direct,
        storev: FLA_Store,
        D: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        C: FLA_Obj,
        E: FLA_Obj,
        cntl: *mut fla_apq2ut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_CAQ2_UT_internal_check(
        side: FLA_Side,
        trans: FLA_Trans,
        direct: FLA_Direct,
        storev: FLA_Store,
        D: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        C: FLA_Obj,
        E: FLA_Obj,
        cntl: *mut fla_apcaq2ut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_QUD_UT_internal_check(
        side: FLA_Side,
        trans: FLA_Trans,
        direct: FLA_Direct,
        storev: FLA_Store,
        T: FLA_Obj,
        W: FLA_Obj,
        R: FLA_Obj,
        U: FLA_Obj,
        C: FLA_Obj,
        V: FLA_Obj,
        D: FLA_Obj,
        cntl: *mut fla_apqudut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_inc_internal_check(
        side: FLA_Side,
        trans: FLA_Trans,
        direct: FLA_Direct,
        storev: FLA_Store,
        A: FLA_Obj,
        TW: FLA_Obj,
        W1: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqutinc_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_CAQ_UT_inc_internal_check(
        side: FLA_Side,
        trans: FLA_Trans,
        direct: FLA_Direct,
        storev: FLA_Store,
        R: FLA_Obj,
        TW: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apcaqutinc_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_QUD_UT_inc_internal_check(
        side: FLA_Side,
        trans: FLA_Trans,
        direct: FLA_Direct,
        storev: FLA_Store,
        T: FLA_Obj,
        W: FLA_Obj,
        R: FLA_Obj,
        U: FLA_Obj,
        C: FLA_Obj,
        V: FLA_Obj,
        D: FLA_Obj,
        cntl: *mut fla_apqudutinc_t,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_internal_check(
        inv: FLA_Inv,
        uplo: FLA_Uplo,
        A: FLA_Obj,
        Y: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_eig_gest_t,
    ) -> FLA_Error;
    pub fn FLA_Axpy_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_axpy_t,
    ) -> FLA_Error;
    pub fn FLA_Axpy_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_axpy_t,
    ) -> FLA_Error;
    pub fn FLA_Axpy_blk_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_axpy_t,
    ) -> FLA_Error;
    pub fn FLA_Axpy_blk_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_axpy_t,
    ) -> FLA_Error;
    pub fn FLA_Axpy_internal(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_axpy_t,
    ) -> FLA_Error;
    pub fn FLA_Axpyt_n_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_axpyt_t,
    ) -> FLA_Error;
    pub fn FLA_Axpyt_n_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_axpyt_t,
    ) -> FLA_Error;
    pub fn FLA_Axpyt_n_blk_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_axpyt_t,
    ) -> FLA_Error;
    pub fn FLA_Axpyt_n_blk_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_axpyt_t,
    ) -> FLA_Error;
    pub fn FLA_Axpyt_t_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_axpyt_t,
    ) -> FLA_Error;
    pub fn FLA_Axpyt_t_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_axpyt_t,
    ) -> FLA_Error;
    pub fn FLA_Axpyt_t_blk_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_axpyt_t,
    ) -> FLA_Error;
    pub fn FLA_Axpyt_t_blk_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_axpyt_t,
    ) -> FLA_Error;
    pub fn FLA_Axpyt_c_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_axpyt_t,
    ) -> FLA_Error;
    pub fn FLA_Axpyt_c_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_axpyt_t,
    ) -> FLA_Error;
    pub fn FLA_Axpyt_c_blk_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_axpyt_t,
    ) -> FLA_Error;
    pub fn FLA_Axpyt_c_blk_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_axpyt_t,
    ) -> FLA_Error;
    pub fn FLA_Axpyt_h_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_axpyt_t,
    ) -> FLA_Error;
    pub fn FLA_Axpyt_h_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_axpyt_t,
    ) -> FLA_Error;
    pub fn FLA_Axpyt_h_blk_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_axpyt_t,
    ) -> FLA_Error;
    pub fn FLA_Axpyt_h_blk_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_axpyt_t,
    ) -> FLA_Error;
    pub fn FLA_Axpyt_internal(
        trans: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_axpyt_t,
    ) -> FLA_Error;
    pub fn FLA_Axpyt_n(alpha: FLA_Obj, A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_axpyt_t)
        -> FLA_Error;
    pub fn FLA_Axpyt_t(alpha: FLA_Obj, A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_axpyt_t)
        -> FLA_Error;
    pub fn FLA_Axpyt_c(alpha: FLA_Obj, A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_axpyt_t)
        -> FLA_Error;
    pub fn FLA_Axpyt_h(alpha: FLA_Obj, A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_axpyt_t)
        -> FLA_Error;
    pub fn FLA_Copy_blk_var1(A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_copy_t) -> FLA_Error;
    pub fn FLA_Copy_blk_var2(A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_copy_t) -> FLA_Error;
    pub fn FLA_Copy_blk_var3(A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_copy_t) -> FLA_Error;
    pub fn FLA_Copy_blk_var4(A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_copy_t) -> FLA_Error;
    pub fn FLA_Copy_internal(A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_copy_t) -> FLA_Error;
    pub fn FLA_Copyt_n_blk_var1(A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_copyt_t) -> FLA_Error;
    pub fn FLA_Copyt_n_blk_var2(A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_copyt_t) -> FLA_Error;
    pub fn FLA_Copyt_n_blk_var3(A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_copyt_t) -> FLA_Error;
    pub fn FLA_Copyt_n_blk_var4(A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_copyt_t) -> FLA_Error;
    pub fn FLA_Copyt_t_blk_var1(A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_copyt_t) -> FLA_Error;
    pub fn FLA_Copyt_t_blk_var2(A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_copyt_t) -> FLA_Error;
    pub fn FLA_Copyt_t_blk_var3(A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_copyt_t) -> FLA_Error;
    pub fn FLA_Copyt_t_blk_var4(A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_copyt_t) -> FLA_Error;
    pub fn FLA_Copyt_c_blk_var1(A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_copyt_t) -> FLA_Error;
    pub fn FLA_Copyt_c_blk_var2(A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_copyt_t) -> FLA_Error;
    pub fn FLA_Copyt_c_blk_var3(A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_copyt_t) -> FLA_Error;
    pub fn FLA_Copyt_c_blk_var4(A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_copyt_t) -> FLA_Error;
    pub fn FLA_Copyt_h_blk_var1(A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_copyt_t) -> FLA_Error;
    pub fn FLA_Copyt_h_blk_var2(A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_copyt_t) -> FLA_Error;
    pub fn FLA_Copyt_h_blk_var3(A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_copyt_t) -> FLA_Error;
    pub fn FLA_Copyt_h_blk_var4(A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_copyt_t) -> FLA_Error;
    pub fn FLA_Copyt_internal(
        trans: FLA_Trans,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_copyt_t,
    ) -> FLA_Error;
    pub fn FLA_Copyt_n(A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_copyt_t) -> FLA_Error;
    pub fn FLA_Copyt_t(A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_copyt_t) -> FLA_Error;
    pub fn FLA_Copyt_c(A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_copyt_t) -> FLA_Error;
    pub fn FLA_Copyt_h(A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_copyt_t) -> FLA_Error;
    pub fn FLA_Copyr_l_blk_var1(A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_copyr_t) -> FLA_Error;
    pub fn FLA_Copyr_l_blk_var2(A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_copyr_t) -> FLA_Error;
    pub fn FLA_Copyr_l_blk_var3(A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_copyr_t) -> FLA_Error;
    pub fn FLA_Copyr_l_blk_var4(A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_copyr_t) -> FLA_Error;
    pub fn FLA_Copyr_u_blk_var1(A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_copyr_t) -> FLA_Error;
    pub fn FLA_Copyr_u_blk_var2(A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_copyr_t) -> FLA_Error;
    pub fn FLA_Copyr_u_blk_var3(A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_copyr_t) -> FLA_Error;
    pub fn FLA_Copyr_u_blk_var4(A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_copyr_t) -> FLA_Error;
    pub fn FLASH_Copyr(uplo: FLA_Uplo, A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Copyr_internal(
        uplo: FLA_Uplo,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_copyr_t,
    ) -> FLA_Error;
    pub fn FLA_Copyr_l(A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_copyr_t) -> FLA_Error;
    pub fn FLA_Copyr_u(A: FLA_Obj, B: FLA_Obj, cntl: *mut fla_copyr_t) -> FLA_Error;
    pub fn FLA_Scal_blk_var1(alpha: FLA_Obj, A: FLA_Obj, cntl: *mut fla_scal_t) -> FLA_Error;
    pub fn FLA_Scal_blk_var2(alpha: FLA_Obj, A: FLA_Obj, cntl: *mut fla_scal_t) -> FLA_Error;
    pub fn FLA_Scal_blk_var3(alpha: FLA_Obj, A: FLA_Obj, cntl: *mut fla_scal_t) -> FLA_Error;
    pub fn FLA_Scal_blk_var4(alpha: FLA_Obj, A: FLA_Obj, cntl: *mut fla_scal_t) -> FLA_Error;
    pub fn FLA_Scal_internal(alpha: FLA_Obj, A: FLA_Obj, cntl: *mut fla_scal_t) -> FLA_Error;
    pub fn FLA_Scalr_l_blk_var1(alpha: FLA_Obj, A: FLA_Obj, cntl: *mut fla_scalr_t) -> FLA_Error;
    pub fn FLA_Scalr_l_blk_var2(alpha: FLA_Obj, A: FLA_Obj, cntl: *mut fla_scalr_t) -> FLA_Error;
    pub fn FLA_Scalr_l_blk_var3(alpha: FLA_Obj, A: FLA_Obj, cntl: *mut fla_scalr_t) -> FLA_Error;
    pub fn FLA_Scalr_l_blk_var4(alpha: FLA_Obj, A: FLA_Obj, cntl: *mut fla_scalr_t) -> FLA_Error;
    pub fn FLA_Scalr_u_blk_var1(alpha: FLA_Obj, A: FLA_Obj, cntl: *mut fla_scalr_t) -> FLA_Error;
    pub fn FLA_Scalr_u_blk_var2(alpha: FLA_Obj, A: FLA_Obj, cntl: *mut fla_scalr_t) -> FLA_Error;
    pub fn FLA_Scalr_u_blk_var3(alpha: FLA_Obj, A: FLA_Obj, cntl: *mut fla_scalr_t) -> FLA_Error;
    pub fn FLA_Scalr_u_blk_var4(alpha: FLA_Obj, A: FLA_Obj, cntl: *mut fla_scalr_t) -> FLA_Error;
    pub fn FLA_Scalr_internal(
        uplo: FLA_Uplo,
        alpha: FLA_Obj,
        A: FLA_Obj,
        cntl: *mut fla_scalr_t,
    ) -> FLA_Error;
    pub fn FLA_Scalr_l(alpha: FLA_Obj, A: FLA_Obj, cntl: *mut fla_scalr_t) -> FLA_Error;
    pub fn FLA_Scalr_u(alpha: FLA_Obj, A: FLA_Obj, cntl: *mut fla_scalr_t) -> FLA_Error;
    pub fn FLA_Gemv_h_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        x: FLA_Obj,
        beta: FLA_Obj,
        y: FLA_Obj,
        cntl: *mut fla_gemv_t,
    ) -> FLA_Error;
    pub fn FLA_Gemv_h_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        x: FLA_Obj,
        beta: FLA_Obj,
        y: FLA_Obj,
        cntl: *mut fla_gemv_t,
    ) -> FLA_Error;
    pub fn FLA_Gemv_h_blk_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        x: FLA_Obj,
        beta: FLA_Obj,
        y: FLA_Obj,
        cntl: *mut fla_gemv_t,
    ) -> FLA_Error;
    pub fn FLA_Gemv_h_blk_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        x: FLA_Obj,
        beta: FLA_Obj,
        y: FLA_Obj,
        cntl: *mut fla_gemv_t,
    ) -> FLA_Error;
    pub fn FLA_Gemv_n_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        x: FLA_Obj,
        beta: FLA_Obj,
        y: FLA_Obj,
        cntl: *mut fla_gemv_t,
    ) -> FLA_Error;
    pub fn FLA_Gemv_n_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        x: FLA_Obj,
        beta: FLA_Obj,
        y: FLA_Obj,
        cntl: *mut fla_gemv_t,
    ) -> FLA_Error;
    pub fn FLA_Gemv_n_blk_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        x: FLA_Obj,
        beta: FLA_Obj,
        y: FLA_Obj,
        cntl: *mut fla_gemv_t,
    ) -> FLA_Error;
    pub fn FLA_Gemv_n_blk_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        x: FLA_Obj,
        beta: FLA_Obj,
        y: FLA_Obj,
        cntl: *mut fla_gemv_t,
    ) -> FLA_Error;
    pub fn FLA_Gemv_t_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        x: FLA_Obj,
        beta: FLA_Obj,
        y: FLA_Obj,
        cntl: *mut fla_gemv_t,
    ) -> FLA_Error;
    pub fn FLA_Gemv_t_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        x: FLA_Obj,
        beta: FLA_Obj,
        y: FLA_Obj,
        cntl: *mut fla_gemv_t,
    ) -> FLA_Error;
    pub fn FLA_Gemv_t_blk_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        x: FLA_Obj,
        beta: FLA_Obj,
        y: FLA_Obj,
        cntl: *mut fla_gemv_t,
    ) -> FLA_Error;
    pub fn FLA_Gemv_t_blk_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        x: FLA_Obj,
        beta: FLA_Obj,
        y: FLA_Obj,
        cntl: *mut fla_gemv_t,
    ) -> FLA_Error;
    pub fn FLA_Gemv_internal(
        transa: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        x: FLA_Obj,
        beta: FLA_Obj,
        y: FLA_Obj,
        cntl: *mut fla_gemv_t,
    ) -> FLA_Error;
    pub fn FLA_Gemv_h(
        alpha: FLA_Obj,
        A: FLA_Obj,
        x: FLA_Obj,
        beta: FLA_Obj,
        y: FLA_Obj,
        cntl: *mut fla_gemv_t,
    ) -> FLA_Error;
    pub fn FLA_Gemv_n(
        alpha: FLA_Obj,
        A: FLA_Obj,
        x: FLA_Obj,
        beta: FLA_Obj,
        y: FLA_Obj,
        cntl: *mut fla_gemv_t,
    ) -> FLA_Error;
    pub fn FLA_Gemv_t(
        alpha: FLA_Obj,
        A: FLA_Obj,
        x: FLA_Obj,
        beta: FLA_Obj,
        y: FLA_Obj,
        cntl: *mut fla_gemv_t,
    ) -> FLA_Error;
    pub fn FLA_Trsv_lc_blk_var1(
        diagA: FLA_Diag,
        A: FLA_Obj,
        x: FLA_Obj,
        cntl: *mut fla_trsv_t,
    ) -> FLA_Error;
    pub fn FLA_Trsv_lc_blk_var2(
        diagA: FLA_Diag,
        A: FLA_Obj,
        x: FLA_Obj,
        cntl: *mut fla_trsv_t,
    ) -> FLA_Error;
    pub fn FLA_Trsv_ln_blk_var1(
        diagA: FLA_Diag,
        A: FLA_Obj,
        x: FLA_Obj,
        cntl: *mut fla_trsv_t,
    ) -> FLA_Error;
    pub fn FLA_Trsv_ln_blk_var2(
        diagA: FLA_Diag,
        A: FLA_Obj,
        x: FLA_Obj,
        cntl: *mut fla_trsv_t,
    ) -> FLA_Error;
    pub fn FLA_Trsv_lt_blk_var1(
        diagA: FLA_Diag,
        A: FLA_Obj,
        x: FLA_Obj,
        cntl: *mut fla_trsv_t,
    ) -> FLA_Error;
    pub fn FLA_Trsv_lt_blk_var2(
        diagA: FLA_Diag,
        A: FLA_Obj,
        x: FLA_Obj,
        cntl: *mut fla_trsv_t,
    ) -> FLA_Error;
    pub fn FLA_Trsv_uc_blk_var1(
        diagA: FLA_Diag,
        A: FLA_Obj,
        x: FLA_Obj,
        cntl: *mut fla_trsv_t,
    ) -> FLA_Error;
    pub fn FLA_Trsv_uc_blk_var2(
        diagA: FLA_Diag,
        A: FLA_Obj,
        x: FLA_Obj,
        cntl: *mut fla_trsv_t,
    ) -> FLA_Error;
    pub fn FLA_Trsv_un_blk_var1(
        diagA: FLA_Diag,
        A: FLA_Obj,
        x: FLA_Obj,
        cntl: *mut fla_trsv_t,
    ) -> FLA_Error;
    pub fn FLA_Trsv_un_blk_var2(
        diagA: FLA_Diag,
        A: FLA_Obj,
        x: FLA_Obj,
        cntl: *mut fla_trsv_t,
    ) -> FLA_Error;
    pub fn FLA_Trsv_ut_blk_var1(
        diagA: FLA_Diag,
        A: FLA_Obj,
        x: FLA_Obj,
        cntl: *mut fla_trsv_t,
    ) -> FLA_Error;
    pub fn FLA_Trsv_ut_blk_var2(
        diagA: FLA_Diag,
        A: FLA_Obj,
        x: FLA_Obj,
        cntl: *mut fla_trsv_t,
    ) -> FLA_Error;
    pub fn FLA_Trsv_internal(
        uplo: FLA_Uplo,
        transa: FLA_Trans,
        diag: FLA_Diag,
        A: FLA_Obj,
        x: FLA_Obj,
        cntl: *mut fla_trsv_t,
    ) -> FLA_Error;
    pub fn FLA_Trsv_lc(diag: FLA_Diag, A: FLA_Obj, x: FLA_Obj, cntl: *mut fla_trsv_t) -> FLA_Error;
    pub fn FLA_Trsv_ln(diag: FLA_Diag, A: FLA_Obj, x: FLA_Obj, cntl: *mut fla_trsv_t) -> FLA_Error;
    pub fn FLA_Trsv_lt(diag: FLA_Diag, A: FLA_Obj, x: FLA_Obj, cntl: *mut fla_trsv_t) -> FLA_Error;
    pub fn FLA_Trsv_uc(diag: FLA_Diag, A: FLA_Obj, x: FLA_Obj, cntl: *mut fla_trsv_t) -> FLA_Error;
    pub fn FLA_Trsv_un(diag: FLA_Diag, A: FLA_Obj, x: FLA_Obj, cntl: *mut fla_trsv_t) -> FLA_Error;
    pub fn FLA_Trsv_ut(diag: FLA_Diag, A: FLA_Obj, x: FLA_Obj, cntl: *mut fla_trsv_t) -> FLA_Error;
    pub fn FLA_Gemm_cc_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_cc_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_cc_blk_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_cc_blk_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_cc_blk_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_cc_blk_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_cc_unb_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_cc_unb_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_cc_unb_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_cc_unb_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_cc_unb_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_cc_unb_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_ch_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_ch_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_ch_blk_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_ch_blk_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_ch_blk_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_ch_blk_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_ch_unb_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_ch_unb_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_ch_unb_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_ch_unb_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_ch_unb_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_ch_unb_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_cn_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_cn_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_cn_blk_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_cn_blk_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_cn_blk_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_cn_blk_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_cn_unb_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_cn_unb_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_cn_unb_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_cn_unb_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_cn_unb_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_cn_unb_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_ct_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_ct_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_ct_blk_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_ct_blk_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_ct_blk_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_ct_blk_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_ct_unb_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_ct_unb_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_ct_unb_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_ct_unb_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_ct_unb_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_ct_unb_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_hc_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_hc_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_hc_blk_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_hc_blk_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_hc_blk_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_hc_blk_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_hc_unb_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_hc_unb_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_hc_unb_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_hc_unb_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_hc_unb_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_hc_unb_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_hh_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_hh_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_hh_blk_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_hh_blk_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_hh_blk_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_hh_blk_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_hh_unb_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_hh_unb_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_hh_unb_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_hh_unb_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_hh_unb_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_hh_unb_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_hn_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_hn_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_hn_blk_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_hn_blk_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_hn_blk_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_hn_blk_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_hn_unb_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_hn_unb_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_hn_unb_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_hn_unb_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_hn_unb_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_hn_unb_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_ht_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_ht_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_ht_blk_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_ht_blk_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_ht_blk_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_ht_blk_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_ht_unb_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_ht_unb_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_ht_unb_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_ht_unb_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_ht_unb_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_ht_unb_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nc_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nc_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nc_blk_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nc_blk_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nc_blk_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nc_blk_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nc_unb_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nc_unb_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nc_unb_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nc_unb_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nc_unb_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nc_unb_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nh_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nh_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nh_blk_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nh_blk_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nh_blk_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nh_blk_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nh_unb_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nh_unb_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nh_unb_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nh_unb_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nh_unb_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nh_unb_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nn_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nn_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nn_blk_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nn_blk_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nn_blk_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nn_blk_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nn_unb_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nn_unb_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nn_unb_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nn_unb_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nn_unb_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nn_unb_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nt_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nt_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nt_blk_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nt_blk_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nt_blk_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nt_blk_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nt_unb_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nt_unb_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nt_unb_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nt_unb_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nt_unb_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nt_unb_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_tc_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_tc_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_tc_blk_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_tc_blk_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_tc_blk_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_tc_blk_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_tc_unb_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_tc_unb_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_tc_unb_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_tc_unb_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_tc_unb_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_tc_unb_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_th_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_th_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_th_blk_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_th_blk_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_th_blk_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_th_blk_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_th_unb_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_th_unb_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_th_unb_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_th_unb_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_th_unb_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_th_unb_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_tn_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_tn_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_tn_blk_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_tn_blk_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_tn_blk_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_tn_blk_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_tn_unb_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_tn_unb_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_tn_unb_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_tn_unb_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_tn_unb_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_tn_unb_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_tt_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_tt_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_tt_blk_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_tt_blk_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_tt_blk_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_tt_blk_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_tt_unb_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_tt_unb_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_tt_unb_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_tt_unb_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_tt_unb_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_tt_unb_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Gemm_internal(
        transa: FLA_Trans,
        transb: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_cc(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_ch(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_cn(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_ct(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_hc(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_hh(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_hn(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_ht(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nc(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nh(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nn(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_nt(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_tc(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_th(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_tn(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Gemm_tt(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_ll_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_ll_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_ll_blk_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_ll_blk_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_ll_blk_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_ll_blk_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_ll_blk_var7(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_ll_blk_var8(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_ll_blk_var9(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_ll_blk_var10(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_ll_unb_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemm_ll_unb_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemm_ll_unb_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemm_ll_unb_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemm_ll_unb_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemm_ll_unb_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemm_ll_unb_var7(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemm_ll_unb_var8(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemm_ll_unb_var9(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemm_ll_unb_var10(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemm_lu_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_lu_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_lu_blk_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_lu_blk_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_lu_blk_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_lu_blk_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_lu_blk_var7(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_lu_blk_var8(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_lu_blk_var9(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_lu_blk_var10(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_lu_unb_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemm_lu_unb_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemm_lu_unb_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemm_lu_unb_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemm_lu_unb_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemm_lu_unb_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemm_lu_unb_var7(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemm_lu_unb_var8(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemm_lu_unb_var9(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemm_lu_unb_var10(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemm_rl_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_rl_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_rl_blk_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_rl_blk_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_rl_blk_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_rl_blk_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_rl_blk_var7(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_rl_blk_var8(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_rl_blk_var9(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_rl_blk_var10(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_rl_unb_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemm_rl_unb_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemm_rl_unb_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemm_rl_unb_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemm_rl_unb_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemm_rl_unb_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemm_rl_unb_var7(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemm_rl_unb_var8(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemm_rl_unb_var9(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemm_rl_unb_var10(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemm_ru_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_ru_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_ru_blk_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_ru_blk_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_ru_blk_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_ru_blk_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_ru_blk_var7(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_ru_blk_var8(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_ru_blk_var9(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_ru_blk_var10(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_ru_unb_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemm_ru_unb_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemm_ru_unb_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemm_ru_unb_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemm_ru_unb_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemm_ru_unb_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemm_ru_unb_var7(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemm_ru_unb_var8(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemm_ru_unb_var9(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemm_ru_unb_var10(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hemm_internal(
        side: FLA_Side,
        uplo: FLA_Uplo,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_ll(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_lu(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_rl(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Hemm_ru(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_hemm_t,
    ) -> FLA_Error;
    pub fn FLA_Herk_lh_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_herk_t,
    ) -> FLA_Error;
    pub fn FLA_Herk_lh_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_herk_t,
    ) -> FLA_Error;
    pub fn FLA_Herk_lh_blk_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_herk_t,
    ) -> FLA_Error;
    pub fn FLA_Herk_lh_blk_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_herk_t,
    ) -> FLA_Error;
    pub fn FLA_Herk_lh_blk_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_herk_t,
    ) -> FLA_Error;
    pub fn FLA_Herk_lh_blk_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_herk_t,
    ) -> FLA_Error;
    pub fn FLA_Herk_lh_unb_var1(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Herk_lh_unb_var2(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Herk_lh_unb_var3(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Herk_lh_unb_var4(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Herk_lh_unb_var5(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Herk_lh_unb_var6(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Herk_ln_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_herk_t,
    ) -> FLA_Error;
    pub fn FLA_Herk_ln_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_herk_t,
    ) -> FLA_Error;
    pub fn FLA_Herk_ln_blk_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_herk_t,
    ) -> FLA_Error;
    pub fn FLA_Herk_ln_blk_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_herk_t,
    ) -> FLA_Error;
    pub fn FLA_Herk_ln_blk_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_herk_t,
    ) -> FLA_Error;
    pub fn FLA_Herk_ln_blk_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_herk_t,
    ) -> FLA_Error;
    pub fn FLA_Herk_ln_unb_var1(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Herk_ln_unb_var2(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Herk_ln_unb_var3(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Herk_ln_unb_var4(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Herk_ln_unb_var5(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Herk_ln_unb_var6(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Herk_uh_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_herk_t,
    ) -> FLA_Error;
    pub fn FLA_Herk_uh_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_herk_t,
    ) -> FLA_Error;
    pub fn FLA_Herk_uh_blk_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_herk_t,
    ) -> FLA_Error;
    pub fn FLA_Herk_uh_blk_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_herk_t,
    ) -> FLA_Error;
    pub fn FLA_Herk_uh_blk_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_herk_t,
    ) -> FLA_Error;
    pub fn FLA_Herk_uh_blk_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_herk_t,
    ) -> FLA_Error;
    pub fn FLA_Herk_uh_unb_var1(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Herk_uh_unb_var2(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Herk_uh_unb_var3(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Herk_uh_unb_var4(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Herk_uh_unb_var5(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Herk_uh_unb_var6(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Herk_un_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_herk_t,
    ) -> FLA_Error;
    pub fn FLA_Herk_un_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_herk_t,
    ) -> FLA_Error;
    pub fn FLA_Herk_un_blk_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_herk_t,
    ) -> FLA_Error;
    pub fn FLA_Herk_un_blk_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_herk_t,
    ) -> FLA_Error;
    pub fn FLA_Herk_un_blk_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_herk_t,
    ) -> FLA_Error;
    pub fn FLA_Herk_un_blk_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_herk_t,
    ) -> FLA_Error;
    pub fn FLA_Herk_un_unb_var1(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Herk_un_unb_var2(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Herk_un_unb_var3(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Herk_un_unb_var4(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Herk_un_unb_var5(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Herk_un_unb_var6(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Herk_internal(
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_herk_t,
    ) -> FLA_Error;
    pub fn FLA_Herk_lh(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_herk_t,
    ) -> FLA_Error;
    pub fn FLA_Herk_ln(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_herk_t,
    ) -> FLA_Error;
    pub fn FLA_Herk_uh(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_herk_t,
    ) -> FLA_Error;
    pub fn FLA_Herk_un(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_herk_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_lh_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_lh_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_lh_blk_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_lh_blk_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_lh_blk_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_lh_blk_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_lh_blk_var7(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_lh_blk_var8(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_lh_blk_var9(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_lh_blk_var10(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_lh_unb_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2k_lh_unb_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2k_lh_unb_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2k_lh_unb_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2k_lh_unb_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2k_lh_unb_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2k_lh_unb_var7(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2k_lh_unb_var8(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2k_lh_unb_var9(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2k_lh_unb_var10(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2k_ln_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_ln_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_ln_blk_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_ln_blk_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_ln_blk_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_ln_blk_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_ln_blk_var7(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_ln_blk_var8(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_ln_blk_var9(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_ln_blk_var10(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_ln_unb_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2k_ln_unb_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2k_ln_unb_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2k_ln_unb_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2k_ln_unb_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2k_ln_unb_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2k_ln_unb_var7(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2k_ln_unb_var8(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2k_ln_unb_var9(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2k_ln_unb_var10(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2k_uh_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_uh_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_uh_blk_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_uh_blk_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_uh_blk_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_uh_blk_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_uh_blk_var7(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_uh_blk_var8(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_uh_blk_var9(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_uh_blk_var10(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_uh_unb_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2k_uh_unb_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2k_uh_unb_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2k_uh_unb_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2k_uh_unb_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2k_uh_unb_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2k_uh_unb_var7(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2k_uh_unb_var8(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2k_uh_unb_var9(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2k_uh_unb_var10(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2k_un_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_un_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_un_blk_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_un_blk_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_un_blk_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_un_blk_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_un_blk_var7(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_un_blk_var8(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_un_blk_var9(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_un_blk_var10(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_un_unb_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2k_un_unb_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2k_un_unb_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2k_un_unb_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2k_un_unb_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2k_un_unb_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2k_un_unb_var7(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2k_un_unb_var8(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2k_un_unb_var9(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2k_un_unb_var10(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Her2k_internal(
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_lh(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_ln(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_uh(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Her2k_un(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_her2k_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_ll_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_ll_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_ll_blk_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_ll_blk_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_ll_blk_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_ll_blk_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_ll_blk_var7(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_ll_blk_var8(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_ll_blk_var9(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_ll_blk_var10(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_ll_unb_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Symm_ll_unb_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Symm_ll_unb_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Symm_ll_unb_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Symm_ll_unb_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Symm_ll_unb_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Symm_ll_unb_var7(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Symm_ll_unb_var8(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Symm_ll_unb_var9(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Symm_ll_unb_var10(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Symm_lu_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_lu_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_lu_blk_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_lu_blk_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_lu_blk_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_lu_blk_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_lu_blk_var7(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_lu_blk_var8(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_lu_blk_var9(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_lu_blk_var10(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_lu_unb_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Symm_lu_unb_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Symm_lu_unb_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Symm_lu_unb_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Symm_lu_unb_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Symm_lu_unb_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Symm_lu_unb_var7(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Symm_lu_unb_var8(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Symm_lu_unb_var9(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Symm_lu_unb_var10(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Symm_rl_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_rl_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_rl_blk_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_rl_blk_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_rl_blk_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_rl_blk_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_rl_blk_var7(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_rl_blk_var8(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_rl_blk_var9(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_rl_blk_var10(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_rl_unb_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Symm_rl_unb_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Symm_rl_unb_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Symm_rl_unb_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Symm_rl_unb_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Symm_rl_unb_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Symm_rl_unb_var7(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Symm_rl_unb_var8(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Symm_rl_unb_var9(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Symm_rl_unb_var10(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Symm_ru_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_ru_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_ru_blk_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_ru_blk_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_ru_blk_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_ru_blk_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_ru_blk_var7(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_ru_blk_var8(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_ru_blk_var9(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_ru_blk_var10(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_ru_unb_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Symm_ru_unb_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Symm_ru_unb_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Symm_ru_unb_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Symm_ru_unb_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Symm_ru_unb_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Symm_ru_unb_var7(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Symm_ru_unb_var8(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Symm_ru_unb_var9(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Symm_ru_unb_var10(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Symm_internal(
        side: FLA_Side,
        uplo: FLA_Uplo,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_ll(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_lu(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_rl(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Symm_ru(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_symm_t,
    ) -> FLA_Error;
    pub fn FLA_Syrk_ln_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syrk_t,
    ) -> FLA_Error;
    pub fn FLA_Syrk_ln_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syrk_t,
    ) -> FLA_Error;
    pub fn FLA_Syrk_ln_blk_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syrk_t,
    ) -> FLA_Error;
    pub fn FLA_Syrk_ln_blk_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syrk_t,
    ) -> FLA_Error;
    pub fn FLA_Syrk_ln_blk_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syrk_t,
    ) -> FLA_Error;
    pub fn FLA_Syrk_ln_blk_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syrk_t,
    ) -> FLA_Error;
    pub fn FLA_Syrk_ln_unb_var1(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Syrk_ln_unb_var2(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Syrk_ln_unb_var3(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Syrk_ln_unb_var4(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Syrk_ln_unb_var5(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Syrk_ln_unb_var6(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Syrk_lt_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syrk_t,
    ) -> FLA_Error;
    pub fn FLA_Syrk_lt_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syrk_t,
    ) -> FLA_Error;
    pub fn FLA_Syrk_lt_blk_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syrk_t,
    ) -> FLA_Error;
    pub fn FLA_Syrk_lt_blk_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syrk_t,
    ) -> FLA_Error;
    pub fn FLA_Syrk_lt_blk_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syrk_t,
    ) -> FLA_Error;
    pub fn FLA_Syrk_lt_blk_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syrk_t,
    ) -> FLA_Error;
    pub fn FLA_Syrk_lt_unb_var1(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Syrk_lt_unb_var2(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Syrk_lt_unb_var3(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Syrk_lt_unb_var4(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Syrk_lt_unb_var5(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Syrk_lt_unb_var6(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Syrk_un_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syrk_t,
    ) -> FLA_Error;
    pub fn FLA_Syrk_un_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syrk_t,
    ) -> FLA_Error;
    pub fn FLA_Syrk_un_blk_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syrk_t,
    ) -> FLA_Error;
    pub fn FLA_Syrk_un_blk_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syrk_t,
    ) -> FLA_Error;
    pub fn FLA_Syrk_un_blk_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syrk_t,
    ) -> FLA_Error;
    pub fn FLA_Syrk_un_blk_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syrk_t,
    ) -> FLA_Error;
    pub fn FLA_Syrk_un_unb_var1(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Syrk_un_unb_var2(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Syrk_un_unb_var3(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Syrk_un_unb_var4(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Syrk_un_unb_var5(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Syrk_un_unb_var6(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Syrk_ut_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syrk_t,
    ) -> FLA_Error;
    pub fn FLA_Syrk_ut_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syrk_t,
    ) -> FLA_Error;
    pub fn FLA_Syrk_ut_blk_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syrk_t,
    ) -> FLA_Error;
    pub fn FLA_Syrk_ut_blk_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syrk_t,
    ) -> FLA_Error;
    pub fn FLA_Syrk_ut_blk_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syrk_t,
    ) -> FLA_Error;
    pub fn FLA_Syrk_ut_blk_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syrk_t,
    ) -> FLA_Error;
    pub fn FLA_Syrk_ut_unb_var1(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Syrk_ut_unb_var2(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Syrk_ut_unb_var3(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Syrk_ut_unb_var4(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Syrk_ut_unb_var5(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Syrk_ut_unb_var6(alpha: FLA_Obj, A: FLA_Obj, beta: FLA_Obj, C: FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Syrk_internal(
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syrk_t,
    ) -> FLA_Error;
    pub fn FLA_Syrk_ln(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syrk_t,
    ) -> FLA_Error;
    pub fn FLA_Syrk_lt(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syrk_t,
    ) -> FLA_Error;
    pub fn FLA_Syrk_un(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syrk_t,
    ) -> FLA_Error;
    pub fn FLA_Syrk_ut(
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syrk_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_ln_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_ln_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_ln_blk_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_ln_blk_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_ln_blk_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_ln_blk_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_ln_blk_var7(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_ln_blk_var8(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_ln_blk_var9(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_ln_blk_var10(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_ln_unb_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_ln_unb_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_ln_unb_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_ln_unb_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_ln_unb_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_ln_unb_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_ln_unb_var7(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_ln_unb_var8(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_ln_unb_var9(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_ln_unb_var10(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_lt_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_lt_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_lt_blk_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_lt_blk_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_lt_blk_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_lt_blk_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_lt_blk_var7(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_lt_blk_var8(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_lt_blk_var9(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_lt_blk_var10(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_lt_unb_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_lt_unb_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_lt_unb_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_lt_unb_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_lt_unb_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_lt_unb_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_lt_unb_var7(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_lt_unb_var8(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_lt_unb_var9(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_lt_unb_var10(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_un_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_un_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_un_blk_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_un_blk_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_un_blk_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_un_blk_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_un_blk_var7(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_un_blk_var8(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_un_blk_var9(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_un_blk_var10(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_un_unb_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_un_unb_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_un_unb_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_un_unb_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_un_unb_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_un_unb_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_un_unb_var7(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_un_unb_var8(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_un_unb_var9(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_un_unb_var10(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_ut_blk_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_ut_blk_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_ut_blk_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_ut_blk_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_ut_blk_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_ut_blk_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_ut_blk_var7(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_ut_blk_var8(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_ut_blk_var9(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_ut_blk_var10(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_ut_unb_var1(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_ut_unb_var2(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_ut_unb_var3(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_ut_unb_var4(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_ut_unb_var5(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_ut_unb_var6(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_ut_unb_var7(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_ut_unb_var8(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_ut_unb_var9(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_ut_unb_var10(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_internal(
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_ln(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_lt(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_un(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Syr2k_ut(
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
        cntl: *mut fla_syr2k_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_llc_blk_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_llc_blk_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_llc_blk_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_llc_blk_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_llc_unb_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_llc_unb_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_llc_unb_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_llc_unb_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_llh_blk_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_llh_blk_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_llh_blk_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_llh_blk_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_llh_unb_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_llh_unb_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_llh_unb_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_llh_unb_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_lln_blk_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_lln_blk_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_lln_blk_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_lln_blk_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_lln_unb_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_lln_unb_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_lln_unb_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_lln_unb_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_llt_blk_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_llt_blk_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_llt_blk_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_llt_blk_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_llt_unb_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_llt_unb_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_llt_unb_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_llt_unb_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_luc_blk_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_luc_blk_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_luc_blk_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_luc_blk_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_luc_unb_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_luc_unb_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_luc_unb_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_luc_unb_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_luh_blk_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_luh_blk_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_luh_blk_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_luh_blk_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_luh_unb_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_luh_unb_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_luh_unb_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_luh_unb_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_lun_blk_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_lun_blk_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_lun_blk_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_lun_blk_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_lun_unb_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_lun_unb_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_lun_unb_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_lun_unb_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_lut_blk_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_lut_blk_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_lut_blk_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_lut_blk_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_lut_unb_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_lut_unb_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_lut_unb_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_lut_unb_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rlc_blk_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rlc_blk_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rlc_blk_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rlc_blk_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rlc_unb_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rlc_unb_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rlc_unb_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rlc_unb_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rlh_blk_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rlh_blk_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rlh_blk_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rlh_blk_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rlh_unb_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rlh_unb_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rlh_unb_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rlh_unb_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rln_blk_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rln_blk_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rln_blk_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rln_blk_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rln_unb_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rln_unb_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rln_unb_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rln_unb_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rlt_blk_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rlt_blk_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rlt_blk_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rlt_blk_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rlt_unb_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rlt_unb_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rlt_unb_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rlt_unb_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_ruc_blk_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_ruc_blk_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_ruc_blk_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_ruc_blk_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_ruc_unb_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_ruc_unb_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_ruc_unb_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_ruc_unb_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_ruh_blk_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_ruh_blk_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_ruh_blk_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_ruh_blk_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_ruh_unb_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_ruh_unb_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_ruh_unb_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_ruh_unb_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_run_blk_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_run_blk_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_run_blk_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_run_blk_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_run_unb_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_run_unb_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_run_unb_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_run_unb_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rut_blk_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rut_blk_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rut_blk_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rut_blk_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rut_unb_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rut_unb_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rut_unb_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rut_unb_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trmm_internal(
        side: FLA_Side,
        uplo: FLA_Uplo,
        transa: FLA_Trans,
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_llc(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_llh(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_lln(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_llt(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_luc(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_luh(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_lun(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_lut(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rlc(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rlh(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rln(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rlt(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_ruc(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_ruh(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_run(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trmm_rut(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trmm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_llc_blk_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_llc_blk_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_llc_blk_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_llc_blk_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_llc_unb_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_llc_unb_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_llc_unb_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_llc_unb_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_llh_blk_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_llh_blk_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_llh_blk_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_llh_blk_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_llh_unb_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_llh_unb_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_llh_unb_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_llh_unb_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_lln_blk_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_lln_blk_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_lln_blk_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_lln_blk_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_lln_unb_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_lln_unb_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_lln_unb_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_lln_unb_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_llt_blk_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_llt_blk_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_llt_blk_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_llt_blk_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_llt_unb_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_llt_unb_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_llt_unb_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_llt_unb_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_luc_blk_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_luc_blk_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_luc_blk_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_luc_blk_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_luc_unb_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_luc_unb_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_luc_unb_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_luc_unb_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_luh_blk_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_luh_blk_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_luh_blk_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_luh_blk_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_luh_unb_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_luh_unb_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_luh_unb_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_luh_unb_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_lun_blk_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_lun_blk_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_lun_blk_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_lun_blk_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_lun_unb_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_lun_unb_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_lun_unb_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_lun_unb_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_lut_blk_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_lut_blk_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_lut_blk_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_lut_blk_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_lut_unb_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_lut_unb_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_lut_unb_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_lut_unb_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rlc_blk_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rlc_blk_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rlc_blk_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rlc_blk_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rlc_unb_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rlc_unb_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rlc_unb_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rlc_unb_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rlh_blk_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rlh_blk_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rlh_blk_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rlh_blk_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rlh_unb_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rlh_unb_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rlh_unb_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rlh_unb_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rln_blk_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rln_blk_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rln_blk_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rln_blk_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rln_unb_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rln_unb_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rln_unb_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rln_unb_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rlt_blk_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rlt_blk_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rlt_blk_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rlt_blk_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rlt_unb_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rlt_unb_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rlt_unb_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rlt_unb_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_ruc_blk_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_ruc_blk_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_ruc_blk_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_ruc_blk_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_ruc_unb_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_ruc_unb_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_ruc_unb_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_ruc_unb_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_ruh_blk_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_ruh_blk_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_ruh_blk_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_ruh_blk_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_ruh_unb_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_ruh_unb_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_ruh_unb_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_ruh_unb_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_run_blk_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_run_blk_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_run_blk_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_run_blk_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_run_unb_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_run_unb_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_run_unb_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_run_unb_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rut_blk_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rut_blk_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rut_blk_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rut_blk_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rut_unb_var1(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rut_unb_var2(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rut_unb_var3(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rut_unb_var4(
        diagA: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trsm_internal(
        side: FLA_Side,
        uplo: FLA_Uplo,
        transa: FLA_Trans,
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_llc(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_llh(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_lln(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_llt(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_luc(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_luh(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_lun(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_lut(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rlc(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rlh(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rln(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rlt(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_ruc(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_ruh(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_run(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Trsm_rut(
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_trsm_t,
    ) -> FLA_Error;
    pub fn FLA_Chol_l_blk_var1(A: FLA_Obj, cntl: *mut fla_chol_t) -> FLA_Error;
    pub fn FLA_Chol_l_blk_var2(A: FLA_Obj, cntl: *mut fla_chol_t) -> FLA_Error;
    pub fn FLA_Chol_l_blk_var3(A: FLA_Obj, cntl: *mut fla_chol_t) -> FLA_Error;
    pub fn FLA_Chol_l_unb_var1(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Chol_l_unb_var2(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Chol_l_unb_var3(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Chol_l_opt_var1(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Chol_l_ops_var1(
        mn_A: integer,
        A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Chol_l_opd_var1(
        mn_A: integer,
        A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Chol_l_opc_var1(
        mn_A: integer,
        A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Chol_l_opz_var1(
        mn_A: integer,
        A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Chol_l_opt_var2(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Chol_l_ops_var2(
        mn_A: integer,
        A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Chol_l_opd_var2(
        mn_A: integer,
        A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Chol_l_opc_var2(
        mn_A: integer,
        A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Chol_l_opz_var2(
        mn_A: integer,
        A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Chol_l_opt_var3(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Chol_l_ops_var3(
        mn_A: integer,
        A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Chol_l_opd_var3(
        mn_A: integer,
        A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Chol_l_opc_var3(
        mn_A: integer,
        A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Chol_l_opz_var3(
        mn_A: integer,
        A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Chol_u_blk_var1(A: FLA_Obj, cntl: *mut fla_chol_t) -> FLA_Error;
    pub fn FLA_Chol_u_blk_var2(A: FLA_Obj, cntl: *mut fla_chol_t) -> FLA_Error;
    pub fn FLA_Chol_u_blk_var3(A: FLA_Obj, cntl: *mut fla_chol_t) -> FLA_Error;
    pub fn FLA_Chol_u_unb_var1(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Chol_u_unb_var2(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Chol_u_unb_var3(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Chol_u_opt_var1(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Chol_u_ops_var1(
        mn_A: integer,
        A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Chol_u_opd_var1(
        mn_A: integer,
        A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Chol_u_opc_var1(
        mn_A: integer,
        A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Chol_u_opz_var1(
        mn_A: integer,
        A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Chol_u_opt_var2(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Chol_u_ops_var2(
        mn_A: integer,
        A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Chol_u_opd_var2(
        mn_A: integer,
        A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Chol_u_opc_var2(
        mn_A: integer,
        A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Chol_u_opz_var2(
        mn_A: integer,
        A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Chol_u_opt_var3(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Chol_u_ops_var3(
        mn_A: integer,
        A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Chol_u_opd_var3(
        mn_A: integer,
        A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Chol_u_opc_var3(
        mn_A: integer,
        A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Chol_u_opz_var3(
        mn_A: integer,
        A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Chol_internal(uplo: FLA_Uplo, A: FLA_Obj, cntl: *mut fla_chol_t) -> FLA_Error;
    pub fn FLA_Chol_l(A: FLA_Obj, cntl: *mut fla_chol_t) -> FLA_Error;
    pub fn FLA_Chol_u(A: FLA_Obj, cntl: *mut fla_chol_t) -> FLA_Error;
    pub fn FLA_Chol_solve(uplo: FLA_Uplo, A: FLA_Obj, B: FLA_Obj, X: FLA_Obj) -> FLA_Error;
    pub fn FLASH_Chol_solve(uplo: FLA_Uplo, A: FLA_Obj, B: FLA_Obj, X: FLA_Obj) -> FLA_Error;
    pub fn FLA_LU_nopiv_blk_var1(A: FLA_Obj, cntl: *mut fla_lu_t) -> FLA_Error;
    pub fn FLA_LU_nopiv_blk_var2(A: FLA_Obj, cntl: *mut fla_lu_t) -> FLA_Error;
    pub fn FLA_LU_nopiv_blk_var3(A: FLA_Obj, cntl: *mut fla_lu_t) -> FLA_Error;
    pub fn FLA_LU_nopiv_blk_var4(A: FLA_Obj, cntl: *mut fla_lu_t) -> FLA_Error;
    pub fn FLA_LU_nopiv_blk_var5(A: FLA_Obj, cntl: *mut fla_lu_t) -> FLA_Error;
    pub fn FLA_LU_nopiv_unb_var1(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_LU_nopiv_unb_var2(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_LU_nopiv_unb_var3(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_LU_nopiv_unb_var4(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_LU_nopiv_unb_var5(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_LU_nopiv_opt_var1(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_LU_nopiv_ops_var1(
        m_A: integer,
        n_A: integer,
        A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_LU_nopiv_opd_var1(
        m_A: integer,
        n_A: integer,
        A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_LU_nopiv_opc_var1(
        m_A: integer,
        n_A: integer,
        A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_LU_nopiv_opz_var1(
        m_A: integer,
        n_A: integer,
        A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_LU_nopiv_opt_var2(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_LU_nopiv_ops_var2(
        m_A: integer,
        n_A: integer,
        A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_LU_nopiv_opd_var2(
        m_A: integer,
        n_A: integer,
        A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_LU_nopiv_opc_var2(
        m_A: integer,
        n_A: integer,
        A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_LU_nopiv_opz_var2(
        m_A: integer,
        n_A: integer,
        A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_LU_nopiv_opt_var3(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_LU_nopiv_ops_var3(
        m_A: integer,
        n_A: integer,
        A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_LU_nopiv_opd_var3(
        m_A: integer,
        n_A: integer,
        A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_LU_nopiv_opc_var3(
        m_A: integer,
        n_A: integer,
        A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_LU_nopiv_opz_var3(
        m_A: integer,
        n_A: integer,
        A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_LU_nopiv_opt_var4(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_LU_nopiv_ops_var4(
        m_A: integer,
        n_A: integer,
        A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_LU_nopiv_opd_var4(
        m_A: integer,
        n_A: integer,
        A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_LU_nopiv_opc_var4(
        m_A: integer,
        n_A: integer,
        A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_LU_nopiv_opz_var4(
        m_A: integer,
        n_A: integer,
        A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_LU_nopiv_opt_var5(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_LU_nopiv_ops_var5(
        m_A: integer,
        n_A: integer,
        A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_LU_nopiv_opd_var5(
        m_A: integer,
        n_A: integer,
        A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_LU_nopiv_opc_var5(
        m_A: integer,
        n_A: integer,
        A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_LU_nopiv_opz_var5(
        m_A: integer,
        n_A: integer,
        A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_LU_nopiv_is_blk_var1(
        m_A: integer,
        n_A: integer,
        A: FLA_Obj,
        buff_A: *mut f32,
        nfact: integer,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_LU_nopiv_id_blk_var1(
        m_A: integer,
        n_A: integer,
        A: FLA_Obj,
        buff_A: *mut f64,
        nfact: integer,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_LU_nopiv_ic_blk_var1(
        m_A: integer,
        n_A: integer,
        A: FLA_Obj,
        buff_A: *mut scomplex,
        nfact: integer,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_LU_nopiv_iz_blk_var1(
        m_A: integer,
        n_A: integer,
        A: FLA_Obj,
        buff_A: *mut dcomplex,
        nfact: integer,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_LU_nopiv_is_unblk_var1(
        m_A: integer,
        n_A: integer,
        A: *mut f32,
        nfact: integer,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_LU_nopiv_id_unblk_var1(
        m_A: integer,
        n_A: integer,
        A: *mut f64,
        nfact: integer,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_LU_nopiv_ic_unblk_var1(
        m_A: integer,
        n_A: integer,
        A: *mut scomplex,
        nfact: integer,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_LU_nopiv_iz_unblk_var1(
        m_A: integer,
        n_A: integer,
        A: *mut dcomplex,
        nfact: integer,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_LU_nopiv_id_unblk_var2(
        m_A: integer,
        n_A: integer,
        A: *mut f64,
        nfact: integer,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_LU_nopiv_internal(A: FLA_Obj, cntl: *mut fla_lu_t) -> FLA_Error;
    pub fn FLA_LU_nopiv_solve(A: FLA_Obj, B: FLA_Obj, X: FLA_Obj) -> FLA_Error;
    pub fn FLASH_LU_nopiv_solve(A: FLA_Obj, B: FLA_Obj, X: FLA_Obj) -> FLA_Error;
    pub fn FLA_LU_piv_blk_var3(A: FLA_Obj, p: FLA_Obj, cntl: *mut fla_lu_t) -> FLA_Error;
    pub fn FLA_LU_piv_blk_var4(A: FLA_Obj, p: FLA_Obj, cntl: *mut fla_lu_t) -> FLA_Error;
    pub fn FLA_LU_piv_blk_var5(A: FLA_Obj, p: FLA_Obj, cntl: *mut fla_lu_t) -> FLA_Error;
    pub fn FLA_LU_piv_unb_var3(A: FLA_Obj, p: FLA_Obj) -> FLA_Error;
    pub fn FLA_LU_piv_unb_var3b(A: FLA_Obj, p: FLA_Obj) -> FLA_Error;
    pub fn FLA_LU_piv_unb_var4(A: FLA_Obj, p: FLA_Obj) -> FLA_Error;
    pub fn FLA_LU_piv_unb_var5(A: FLA_Obj, p: FLA_Obj) -> FLA_Error;
    pub fn FLA_LU_piv_opt_var3(A: FLA_Obj, p: FLA_Obj) -> FLA_Error;
    pub fn FLA_LU_piv_ops_var3(
        m_A: integer,
        n_A: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_p: *mut integer,
        inc_p: integer,
    ) -> FLA_Error;
    pub fn FLA_LU_piv_opd_var3(
        m_A: integer,
        n_A: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_p: *mut integer,
        inc_p: integer,
    ) -> FLA_Error;
    pub fn FLA_LU_piv_opc_var3(
        m_A: integer,
        n_A: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_p: *mut integer,
        inc_p: integer,
    ) -> FLA_Error;
    pub fn FLA_LU_piv_opz_var3(
        m_A: integer,
        n_A: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_p: *mut integer,
        inc_p: integer,
    ) -> FLA_Error;
    pub fn FLA_LU_piv_opt_var4(A: FLA_Obj, p: FLA_Obj) -> FLA_Error;
    pub fn FLA_LU_piv_ops_var4(
        m_A: integer,
        n_A: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_p: *mut integer,
        inc_p: integer,
    ) -> FLA_Error;
    pub fn FLA_LU_piv_opd_var4(
        m_A: integer,
        n_A: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_p: *mut integer,
        inc_p: integer,
    ) -> FLA_Error;
    pub fn FLA_LU_piv_opc_var4(
        m_A: integer,
        n_A: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_p: *mut integer,
        inc_p: integer,
    ) -> FLA_Error;
    pub fn FLA_LU_piv_opz_var4(
        m_A: integer,
        n_A: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_p: *mut integer,
        inc_p: integer,
    ) -> FLA_Error;
    pub fn FLA_LU_piv_opt_var5(A: FLA_Obj, p: FLA_Obj) -> FLA_Error;
    pub fn FLA_LU_piv_ops_var5(
        m_A: integer,
        n_A: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_p: *mut integer,
        inc_p: integer,
    ) -> FLA_Error;
    pub fn FLA_LU_piv_opd_var5(
        m_A: integer,
        n_A: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_p: *mut integer,
        inc_p: integer,
    ) -> FLA_Error;
    pub fn FLA_LU_piv_opc_var5(
        m_A: integer,
        n_A: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_p: *mut integer,
        inc_p: integer,
    ) -> FLA_Error;
    pub fn FLA_LU_piv_opz_var5(
        m_A: integer,
        n_A: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_p: *mut integer,
        inc_p: integer,
    ) -> FLA_Error;
    pub fn FLA_LU_piv_internal(A: FLA_Obj, p: FLA_Obj, cntl: *mut fla_lu_t) -> FLA_Error;
    pub fn FLA_LU_piv_small_s_var0(
        m: *mut integer,
        n: *mut integer,
        a: *mut real,
        lda: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    ) -> integer;
    pub fn FLA_LU_piv_small_s_var1(
        m: *mut integer,
        n: *mut integer,
        a: *mut real,
        lda: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    ) -> integer;
    pub fn FLA_LU_piv_small_d_var0(
        m: *mut integer,
        n: *mut integer,
        a: *mut doublereal,
        lda: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    ) -> integer;
    pub fn FLA_LU_piv_small_d_var1(
        m: *mut integer,
        n: *mut integer,
        a: *mut doublereal,
        lda: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    ) -> integer;
    pub fn FLA_LU_piv_small_d_var2(
        m: *mut integer,
        n: *mut integer,
        a: *mut doublereal,
        lda: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    ) -> integer;
    pub fn FLA_LU_piv_small_z_var0(
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    ) -> c_int;
    pub fn FLA_LU_piv_z_var0(
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    ) -> c_int;
    pub fn FLA_LU_piv_z_parallel(
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    ) -> c_int;
    pub fn FLA_LU_piv_z_var1_parallel(
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    ) -> c_int;
    pub fn FLA_LU_piv_d_parallel(
        m: *mut integer,
        n: *mut integer,
        a: *mut doublereal,
        lda: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    ) -> c_int;
    pub fn FLA_LU_piv_s_parallel(
        m: *mut integer,
        n: *mut integer,
        a: *mut real,
        lda: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    ) -> c_int;
    pub fn FLA_LU_piv_solve(A: FLA_Obj, p: FLA_Obj, B: FLA_Obj, X: FLA_Obj) -> FLA_Error;
    pub fn FLASH_LU_piv_solve(A: FLA_Obj, p: FLA_Obj, B: FLA_Obj, X: FLA_Obj) -> FLA_Error;
    pub fn lapack_cgetf2(
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    ) -> integer;
    pub fn lapack_cgetrf(
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    ) -> integer;
    pub fn lapack_dgetrf(
        m: *mut integer,
        n: *mut integer,
        a: *mut doublereal,
        lda: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    ) -> integer;
    pub fn lapack_sgetf2(
        m: *mut integer,
        n: *mut integer,
        a: *mut real,
        lda: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    ) -> integer;
    pub fn lapack_sgetrf(
        m: *mut integer,
        n: *mut integer,
        a: *mut real,
        lda: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    ) -> integer;
    pub fn lapack_zgetf2(
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    ) -> integer;
    pub fn lapack_zgetrf(
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    ) -> integer;
    pub fn FLA_SA_Apply_pivots(C: FLA_Obj, E: FLA_Obj, p: FLA_Obj) -> FLA_Error;
    pub fn FLA_SA_LU_blk(
        U: FLA_Obj,
        D: FLA_Obj,
        p: FLA_Obj,
        L: FLA_Obj,
        nb_alg: fla_dim_t,
    ) -> FLA_Error;
    pub fn FLA_SA_LU_unb(U: FLA_Obj, D: FLA_Obj, p: FLA_Obj, L: FLA_Obj) -> FLA_Error;
    pub fn FLA_SA_FS_blk(
        L: FLA_Obj,
        D: FLA_Obj,
        p: FLA_Obj,
        C: FLA_Obj,
        E: FLA_Obj,
        nb_alg: fla_dim_t,
    ) -> FLA_Error;
    pub fn FLASH_LU_incpiv_var1(
        A: FLA_Obj,
        p: FLA_Obj,
        L: FLA_Obj,
        nb_alg: fla_dim_t,
        cntl: *mut fla_lu_t,
    ) -> FLA_Error;
    pub fn FLASH_LU_incpiv_var2(
        A: FLA_Obj,
        p: FLA_Obj,
        L: FLA_Obj,
        U: FLA_Obj,
        nb_alg: fla_dim_t,
        cntl: *mut fla_lu_t,
    ) -> FLA_Error;
    pub fn FLASH_Trsm_piv(A: FLA_Obj, B: FLA_Obj, p: FLA_Obj, cntl: *mut fla_trsm_t) -> FLA_Error;
    pub fn FLASH_SA_LU(
        B: FLA_Obj,
        C: FLA_Obj,
        D: FLA_Obj,
        E: FLA_Obj,
        p: FLA_Obj,
        L: FLA_Obj,
        nb_alg: fla_dim_t,
        cntl: *mut fla_lu_t,
    ) -> FLA_Error;
    pub fn FLASH_SA_FS(
        L: FLA_Obj,
        D: FLA_Obj,
        p: FLA_Obj,
        C: FLA_Obj,
        E: FLA_Obj,
        nb_alg: fla_dim_t,
        cntl: *mut fla_gemm_t,
    ) -> FLA_Error;
    pub fn FLASH_FS_incpiv_aux1(
        A: FLA_Obj,
        p: FLA_Obj,
        L: FLA_Obj,
        b: FLA_Obj,
        nb_alg: fla_dim_t,
    ) -> FLA_Error;
    pub fn FLASH_FS_incpiv_aux2(
        L: FLA_Obj,
        D: FLA_Obj,
        p: FLA_Obj,
        C: FLA_Obj,
        E: FLA_Obj,
        nb_alg: fla_dim_t,
    ) -> FLA_Error;
    pub fn FLASH_LU_incpiv_create_hier_matrices(
        A_flat: FLA_Obj,
        depth: fla_dim_t,
        b_flash: *mut fla_dim_t,
        b_alg: fla_dim_t,
        A: *mut FLA_Obj,
        p: *mut FLA_Obj,
        L: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_LU_incpiv_determine_alg_blocksize(A: FLA_Obj) -> fla_dim_t;
    pub fn FLASH_LU_incpiv_noopt(A: FLA_Obj, p: FLA_Obj, L: FLA_Obj) -> FLA_Error;
    pub fn FLASH_LU_incpiv_opt1(A: FLA_Obj, p: FLA_Obj, L: FLA_Obj) -> FLA_Error;
    pub fn FLASH_LU_incpiv_solve(
        A: FLA_Obj,
        p: FLA_Obj,
        L: FLA_Obj,
        B: FLA_Obj,
        X: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_QR_UT_unb_var1(A: FLA_Obj, t: FLA_Obj) -> FLA_Error;
    pub fn FLA_QR_UT_blk_var1(A: FLA_Obj, T: FLA_Obj, cntl: *mut fla_qrut_t) -> FLA_Error;
    pub fn FLA_QR_UT_opt_var1(A: FLA_Obj, t: FLA_Obj) -> FLA_Error;
    pub fn FLA_QR_UT_ops_var1(
        m_A: integer,
        n_A: integer,
        A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        t: *mut f32,
        inc_t: integer,
    ) -> FLA_Error;
    pub fn FLA_QR_UT_opd_var1(
        m_A: integer,
        n_A: integer,
        A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        t: *mut f64,
        inc_t: integer,
    ) -> FLA_Error;
    pub fn FLA_QR_UT_opc_var1(
        m_A: integer,
        n_A: integer,
        A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        t: *mut scomplex,
        inc_t: integer,
    ) -> FLA_Error;
    pub fn FLA_QR_UT_opz_var1(
        m_A: integer,
        n_A: integer,
        A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        t: *mut dcomplex,
        inc_t: integer,
    ) -> FLA_Error;
    pub fn FLA_QR_UT_unb_var2(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_QR_UT_blk_var2(A: FLA_Obj, T: FLA_Obj, cntl: *mut fla_qrut_t) -> FLA_Error;
    pub fn FLA_QR_UT_opt_var2(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_QR_UT_ops_var2(
        m_A: integer,
        n_A: integer,
        A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        T: *mut f32,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_QR_UT_opd_var2(
        m_A: integer,
        n_A: integer,
        A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        T: *mut f64,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_QR_UT_opc_var2(
        m_A: integer,
        n_A: integer,
        A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        T: *mut scomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_QR_UT_opz_var2(
        m_A: integer,
        n_A: integer,
        A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        T: *mut dcomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_QR_UT_blk_var3(A: FLA_Obj, T: FLA_Obj, cntl: *mut fla_qrut_t) -> FLA_Error;
    pub fn FLA_QR_UT_internal(A: FLA_Obj, T: FLA_Obj, cntl: *mut fla_qrut_t) -> FLA_Error;
    pub fn FLA_QR_UT_copy_internal(
        A: FLA_Obj,
        T: FLA_Obj,
        U: FLA_Obj,
        cntl: *mut fla_qrut_t,
    ) -> FLA_Error;
    pub fn FLA_QR_UT_create_T(A: FLA_Obj, T: *mut FLA_Obj) -> FLA_Error;
    pub fn FLA_QR_UT_recover_tau(T: FLA_Obj, tau: FLA_Obj) -> FLA_Error;
    pub fn FLA_QR_UT_solve(A: FLA_Obj, T: FLA_Obj, B: FLA_Obj, X: FLA_Obj) -> FLA_Error;
    pub fn FLASH_QR_UT(A: FLA_Obj, TW: FLA_Obj) -> FLA_Error;
    pub fn FLASH_QR_UT_create_hier_matrices(
        A_flat: FLA_Obj,
        depth: fla_dim_t,
        b_flash: *mut fla_dim_t,
        A: *mut FLA_Obj,
        TW: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_QR_UT_solve(A: FLA_Obj, T: FLA_Obj, B: FLA_Obj, X: FLA_Obj) -> FLA_Error;
    pub fn FLA_QR_UT_form_Q(A: FLA_Obj, T: FLA_Obj, Q: FLA_Obj) -> FLA_Error;
    pub fn FLA_QR_UT_form_Q_blk_var1(A: FLA_Obj, T: FLA_Obj, W: FLA_Obj) -> FLA_Error;
    pub fn FLA_QR_UT_form_Q_opt_var1(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_QR_UT_form_Q_ops_var1(
        m_A: integer,
        n_AT: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut f32,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_QR_UT_form_Q_opd_var1(
        m_A: integer,
        n_AT: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut f64,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_QR_UT_form_Q_opc_var1(
        m_A: integer,
        n_AT: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut scomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_QR_UT_form_Q_opz_var1(
        m_A: integer,
        n_AT: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut dcomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_QR_UT_piv_unb_var1(A: FLA_Obj, T: FLA_Obj, w: FLA_Obj, p: FLA_Obj) -> FLA_Error;
    pub fn FLA_QR_UT_piv_blk_var1(
        A: FLA_Obj,
        T: FLA_Obj,
        w: FLA_Obj,
        p: FLA_Obj,
        cntl: *mut fla_qrut_t,
    ) -> FLA_Error;
    pub fn FLA_QR_UT_piv_unb_var2(A: FLA_Obj, T: FLA_Obj, w: FLA_Obj, p: FLA_Obj) -> FLA_Error;
    pub fn FLA_QR_UT_piv_blk_var2(
        A: FLA_Obj,
        T: FLA_Obj,
        w: FLA_Obj,
        p: FLA_Obj,
        cntl: *mut fla_qrut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_H2_UT_piv_row(
        tau: FLA_Obj,
        a1t: FLA_Obj,
        u1t: FLA_Obj,
        W: FLA_Obj,
        u2: FLA_Obj,
        A2: FLA_Obj,
        U2: FLA_Obj,
        w1t: FLA_Obj,
        vt: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_QR_UT_piv_internal(
        A: FLA_Obj,
        T: FLA_Obj,
        w: FLA_Obj,
        p: FLA_Obj,
        cntl: *mut fla_qrut_t,
    ) -> FLA_Error;
    pub fn FLA_QR_UT_piv_colnorm(alpha: FLA_Obj, A: FLA_Obj, b: FLA_Obj) -> FLA_Error;
    pub fn FLA_QR_UT_piv_check(A: FLA_Obj, T: FLA_Obj, w: FLA_Obj, p: FLA_Obj) -> FLA_Error;
    pub fn FLA_QR_UT_piv_internal_check(
        A: FLA_Obj,
        T: FLA_Obj,
        w: FLA_Obj,
        p: FLA_Obj,
        cntl: *mut fla_qrut_t,
    ) -> FLA_Error;
    pub fn FLA_QR_UT_piv_colnorm_check(alpha: FLA_Obj, A: FLA_Obj, b: FLA_Obj) -> FLA_Error;
    pub fn FLA_EXT_sgeqrf(
        m_A: integer,
        n_A: integer,
        buff_A: *mut f32,
        cs_A: integer,
        buff_t: *mut f32,
        buff_w: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    ) -> FLA_Error;
    pub fn FLA_EXT_dgeqrf(
        m_A: integer,
        n_A: integer,
        buff_A: *mut f64,
        cs_A: integer,
        buff_t: *mut f64,
        buff_w: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    ) -> FLA_Error;
    pub fn FLA_QR2_UT_blk_var1(
        U: FLA_Obj,
        D: FLA_Obj,
        T: FLA_Obj,
        cntl: *mut fla_qr2ut_t,
    ) -> FLA_Error;
    pub fn FLA_QR2_UT_blk_var2(
        U: FLA_Obj,
        D: FLA_Obj,
        T: FLA_Obj,
        cntl: *mut fla_qr2ut_t,
    ) -> FLA_Error;
    pub fn FLA_QR2_UT_unb_var1(U: FLA_Obj, D: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_QR2_UT_opt_var1(U: FLA_Obj, D: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_QR2_UT_ops_var1(
        m_UT: integer,
        m_D: integer,
        U: *mut f32,
        rs_U: integer,
        cs_U: integer,
        D: *mut f32,
        rs_D: integer,
        cs_D: integer,
        T: *mut f32,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_QR2_UT_opd_var1(
        m_UT: integer,
        m_D: integer,
        U: *mut f64,
        rs_U: integer,
        cs_U: integer,
        D: *mut f64,
        rs_D: integer,
        cs_D: integer,
        T: *mut f64,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_QR2_UT_opc_var1(
        m_UT: integer,
        m_D: integer,
        U: *mut scomplex,
        rs_U: integer,
        cs_U: integer,
        D: *mut scomplex,
        rs_D: integer,
        cs_D: integer,
        T: *mut scomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_QR2_UT_opz_var1(
        m_UT: integer,
        m_D: integer,
        U: *mut dcomplex,
        rs_U: integer,
        cs_U: integer,
        D: *mut dcomplex,
        rs_D: integer,
        cs_D: integer,
        T: *mut dcomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLASH_QR2_UT(U: FLA_Obj, D: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_QR2_UT_internal(
        U: FLA_Obj,
        D: FLA_Obj,
        T: FLA_Obj,
        cntl: *mut fla_qr2ut_t,
    ) -> FLA_Error;
    pub fn FLASH_QR_UT_inc(A: FLA_Obj, TW: FLA_Obj) -> FLA_Error;
    pub fn FLASH_QR_UT_inc_noopt(A: FLA_Obj, TW: FLA_Obj) -> FLA_Error;
    pub fn FLASH_QR_UT_inc_opt1(A: FLA_Obj, TW: FLA_Obj) -> FLA_Error;
    pub fn FLA_QR_UT_inc_blk_var1(A: FLA_Obj, TW: FLA_Obj, cntl: *mut fla_qrutinc_t) -> FLA_Error;
    pub fn FLA_QR_UT_inc_blk_var2(
        A: FLA_Obj,
        TW: FLA_Obj,
        U: FLA_Obj,
        cntl: *mut fla_qrutinc_t,
    ) -> FLA_Error;
    pub fn FLASH_QR_UT_inc_create_hier_matrices(
        A_flat: FLA_Obj,
        depth: fla_dim_t,
        b_flash: *mut fla_dim_t,
        b_alg: fla_dim_t,
        A: *mut FLA_Obj,
        TW: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_QR_UT_inc_determine_alg_blocksize(A: FLA_Obj) -> fla_dim_t;
    pub fn FLASH_QR_UT_inc_solve(A: FLA_Obj, TW: FLA_Obj, B: FLA_Obj, X: FLA_Obj) -> FLA_Error;
    pub fn FLA_LQ_UT_unb_var1(A: FLA_Obj, t: FLA_Obj) -> FLA_Error;
    pub fn FLA_LQ_UT_blk_var1(A: FLA_Obj, T: FLA_Obj, cntl: *mut fla_lqut_t) -> FLA_Error;
    pub fn FLA_LQ_UT_opt_var1(A: FLA_Obj, t: FLA_Obj) -> FLA_Error;
    pub fn FLA_LQ_UT_ops_var1(
        m_A: integer,
        n_A: integer,
        A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        t: *mut f32,
        inc_t: integer,
    ) -> FLA_Error;
    pub fn FLA_LQ_UT_opd_var1(
        m_A: integer,
        n_A: integer,
        A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        t: *mut f64,
        inc_t: integer,
    ) -> FLA_Error;
    pub fn FLA_LQ_UT_opc_var1(
        m_A: integer,
        n_A: integer,
        A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        t: *mut scomplex,
        inc_t: integer,
    ) -> FLA_Error;
    pub fn FLA_LQ_UT_opz_var1(
        m_A: integer,
        n_A: integer,
        A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        t: *mut dcomplex,
        inc_t: integer,
    ) -> FLA_Error;
    pub fn FLA_LQ_UT_unb_var2(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_LQ_UT_blk_var2(A: FLA_Obj, T: FLA_Obj, cntl: *mut fla_lqut_t) -> FLA_Error;
    pub fn FLA_LQ_UT_opt_var2(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_LQ_UT_ops_var2(
        m_A: integer,
        n_A: integer,
        A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        T: *mut f32,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_LQ_UT_opd_var2(
        m_A: integer,
        n_A: integer,
        A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        T: *mut f64,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_LQ_UT_opc_var2(
        m_A: integer,
        n_A: integer,
        A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        T: *mut scomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_LQ_UT_opz_var2(
        m_A: integer,
        n_A: integer,
        A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        T: *mut dcomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_LQ_UT_blk_var3(A: FLA_Obj, T: FLA_Obj, cntl: *mut fla_lqut_t) -> FLA_Error;
    pub fn FLA_LQ_UT_internal(A: FLA_Obj, T: FLA_Obj, cntl: *mut fla_lqut_t) -> FLA_Error;
    pub fn FLA_LQ_UT_create_T(A: FLA_Obj, T: *mut FLA_Obj) -> FLA_Error;
    pub fn FLA_LQ_UT_recover_tau(T: FLA_Obj, tau: FLA_Obj) -> FLA_Error;
    pub fn FLA_LQ_UT_solve(A: FLA_Obj, T: FLA_Obj, B: FLA_Obj, X: FLA_Obj) -> FLA_Error;
    pub fn FLASH_LQ_UT(A: FLA_Obj, TW: FLA_Obj) -> FLA_Error;
    pub fn FLASH_LQ_UT_create_hier_matrices(
        A_flat: FLA_Obj,
        depth: fla_dim_t,
        b_flash: *mut fla_dim_t,
        A: *mut FLA_Obj,
        TW: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_LQ_UT_solve(A: FLA_Obj, T: FLA_Obj, B: FLA_Obj, X: FLA_Obj) -> FLA_Error;
    pub fn FLA_LQ_UT_form_Q(A: FLA_Obj, T: FLA_Obj, Q: FLA_Obj) -> FLA_Error;
    pub fn FLA_CAQR2_UT_blk_var1(
        U: FLA_Obj,
        D: FLA_Obj,
        T: FLA_Obj,
        cntl: *mut fla_caqr2ut_t,
    ) -> FLA_Error;
    pub fn FLA_CAQR2_UT_blk_var2(
        U: FLA_Obj,
        D: FLA_Obj,
        T: FLA_Obj,
        cntl: *mut fla_caqr2ut_t,
    ) -> FLA_Error;
    pub fn FLA_CAQR2_UT_unb_var1(U: FLA_Obj, D: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_CAQR2_UT_opt_var1(U: FLA_Obj, D: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_CAQR2_UT_ops_var1(
        m_UT: integer,
        m_D: integer,
        U: *mut f32,
        rs_U: integer,
        cs_U: integer,
        D: *mut f32,
        rs_D: integer,
        cs_D: integer,
        T: *mut f32,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_CAQR2_UT_opd_var1(
        m_UT: integer,
        m_D: integer,
        U: *mut f64,
        rs_U: integer,
        cs_U: integer,
        D: *mut f64,
        rs_D: integer,
        cs_D: integer,
        T: *mut f64,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_CAQR2_UT_opc_var1(
        m_UT: integer,
        m_D: integer,
        U: *mut scomplex,
        rs_U: integer,
        cs_U: integer,
        D: *mut scomplex,
        rs_D: integer,
        cs_D: integer,
        T: *mut scomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_CAQR2_UT_opz_var1(
        m_UT: integer,
        m_D: integer,
        U: *mut dcomplex,
        rs_U: integer,
        cs_U: integer,
        D: *mut dcomplex,
        rs_D: integer,
        cs_D: integer,
        T: *mut dcomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_CAQR2_UT_internal(
        U: FLA_Obj,
        D: FLA_Obj,
        T: FLA_Obj,
        cntl: *mut fla_caqr2ut_t,
    ) -> FLA_Error;
    pub fn FLASH_CAQR_UT_inc(
        p: fla_dim_t,
        A: FLA_Obj,
        ATW: FLA_Obj,
        R: FLA_Obj,
        RTW: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_CAQR_UT_inc_noopt(
        p: fla_dim_t,
        A: FLA_Obj,
        ATW: FLA_Obj,
        R: FLA_Obj,
        RTW: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_CAQR_UT_inc_create_hier_matrices(
        p: fla_dim_t,
        A_flat: FLA_Obj,
        depth: fla_dim_t,
        b_flash: *mut fla_dim_t,
        b_alg: fla_dim_t,
        A: *mut FLA_Obj,
        ATW: *mut FLA_Obj,
        R: *mut FLA_Obj,
        RTW: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_CAQR_UT_inc_determine_alg_blocksize(A: FLA_Obj) -> fla_dim_t;
    pub fn FLASH_CAQR_UT_inc_adjust_views(A: FLA_Obj, TW: FLA_Obj) -> FLA_Error;
    pub fn FLA_CAQR_UT_inc_init_structure(p: fla_dim_t, nb_part: fla_dim_t, R: FLA_Obj);
    pub fn FLA_CAQR_UT_inc_compute_blocks_per_part(p: fla_dim_t, A: FLA_Obj) -> fla_dim_t;
    pub fn FLA_CAQR_UT_inc_factorize_panels(
        nb_part: fla_dim_t,
        A: FLA_Obj,
        ATW: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_CAQR_UT_inc_copy_triangles(nb_part: fla_dim_t, A: FLA_Obj, R: FLA_Obj) -> FLA_Error;
    pub fn FLA_CAQR_UT_inc_blk_var1(
        R: FLA_Obj,
        TW: FLA_Obj,
        cntl: *mut fla_caqrutinc_t,
    ) -> FLA_Error;
    pub fn FLASH_CAQR_UT_inc_solve(
        p: fla_dim_t,
        A: FLA_Obj,
        ATW: FLA_Obj,
        R: FLA_Obj,
        RTW: FLA_Obj,
        B: FLA_Obj,
        X: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Hevd_ln_unb_var1(A: FLA_Obj, l: FLA_Obj) -> FLA_Error;
    pub fn FLA_Hevd_lv_unb_var1(
        n_iter_max: fla_dim_t,
        A: FLA_Obj,
        l: FLA_Obj,
        k_accum: fla_dim_t,
        b_alg: fla_dim_t,
    ) -> FLA_Error;
    pub fn FLA_Hevd_lv_unb_var2(
        n_iter_max: fla_dim_t,
        A: FLA_Obj,
        l: FLA_Obj,
        k_accum: fla_dim_t,
        b_alg: fla_dim_t,
    ) -> FLA_Error;
    pub fn FLA_Hevd_compute_scaling(uplo: FLA_Uplo, A: FLA_Obj, sigma: FLA_Obj) -> FLA_Error;
    pub fn FLA_Hevd(jobz: FLA_Evd_type, uplo: FLA_Uplo, A: FLA_Obj, l: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tevd_iteracc_n_ops_var1(
        m_A: integer,
        n_G: integer,
        ijTL: integer,
        buff_d: *mut f32,
        inc_d: integer,
        buff_e: *mut f32,
        inc_e: integer,
        n_iter_perf: *mut integer,
    ) -> FLA_Error;
    pub fn FLA_Tevd_iteracc_n_opd_var1(
        m_A: integer,
        n_G: integer,
        ijTL: integer,
        buff_d: *mut f64,
        inc_d: integer,
        buff_e: *mut f64,
        inc_e: integer,
        n_iter_perf: *mut integer,
    ) -> FLA_Error;
    pub fn FLA_Tevd_eigval_n_opt_var1(
        G: FLA_Obj,
        d: FLA_Obj,
        e: FLA_Obj,
        n_iter: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Tevd_eigval_n_ops_var1(
        m_A: integer,
        n_G: integer,
        buff_d: *mut f32,
        inc_d: integer,
        buff_e: *mut f32,
        inc_e: integer,
        n_iter: *mut integer,
    ) -> FLA_Error;
    pub fn FLA_Tevd_eigval_n_opd_var1(
        m_A: integer,
        n_G: integer,
        buff_d: *mut f64,
        inc_d: integer,
        buff_e: *mut f64,
        inc_e: integer,
        n_iter: *mut integer,
    ) -> FLA_Error;
    pub fn FLA_Tevd_francis_n_opt_var1(shift: FLA_Obj, d: FLA_Obj, e: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tevd_francis_n_ops_var1(
        m_A: integer,
        buff_shift: *mut f32,
        buff_d: *mut f32,
        inc_d: integer,
        buff_e: *mut f32,
        inc_e: integer,
    ) -> FLA_Error;
    pub fn FLA_Tevd_francis_n_opd_var1(
        m_A: integer,
        buff_shift: *mut f64,
        buff_d: *mut f64,
        inc_d: integer,
        buff_e: *mut f64,
        inc_e: integer,
    ) -> FLA_Error;
    pub fn FLA_Tevd_find_submatrix_ops(
        m_A: integer,
        ij_begin: integer,
        buff_d: *mut f32,
        inc_d: integer,
        buff_e: *mut f32,
        inc_e: integer,
        ijTL: *mut integer,
        ijBR: *mut integer,
    ) -> FLA_Error;
    pub fn FLA_Tevd_find_submatrix_opd(
        m_A: integer,
        ij_begin: integer,
        buff_d: *mut f64,
        inc_d: integer,
        buff_e: *mut f64,
        inc_e: integer,
        ijTL: *mut integer,
        ijBR: *mut integer,
    ) -> FLA_Error;
    pub fn FLA_Norm1_tridiag(d: FLA_Obj, e: FLA_Obj, norm: FLA_Obj) -> FLA_Error;
    pub fn FLA_Norm1_tridiag_ops(
        m_A: integer,
        buff_d: *mut f32,
        inc_d: integer,
        buff_e: *mut f32,
        inc_e: integer,
        norm: *mut f32,
    ) -> FLA_Error;
    pub fn FLA_Norm1_tridiag_opd(
        m_A: integer,
        buff_d: *mut f64,
        inc_d: integer,
        buff_e: *mut f64,
        inc_e: integer,
        norm: *mut f64,
    ) -> FLA_Error;
    pub fn FLA_Tevd_n_opt_var1(
        n_iter_max: fla_dim_t,
        d: FLA_Obj,
        e: FLA_Obj,
        G: FLA_Obj,
        U: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Tevd_n_ops_var1(
        m_A: integer,
        m_U: integer,
        n_G: integer,
        n_iter_max: integer,
        buff_d: *mut f32,
        inc_d: integer,
        buff_e: *mut f32,
        inc_e: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
    ) -> FLA_Error;
    pub fn FLA_Tevd_n_opd_var1(
        m_A: integer,
        m_U: integer,
        n_G: integer,
        n_iter_max: integer,
        buff_d: *mut f64,
        inc_d: integer,
        buff_e: *mut f64,
        inc_e: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
    ) -> FLA_Error;
    pub fn FLA_Tevd_n_opc_var1(
        m_A: integer,
        m_U: integer,
        n_G: integer,
        n_iter_max: integer,
        buff_d: *mut f32,
        inc_d: integer,
        buff_e: *mut f32,
        inc_e: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
    ) -> FLA_Error;
    pub fn FLA_Tevd_n_opz_var1(
        m_A: integer,
        m_U: integer,
        n_G: integer,
        n_iter_max: integer,
        buff_d: *mut f64,
        inc_d: integer,
        buff_e: *mut f64,
        inc_e: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
    ) -> FLA_Error;
    pub fn FLA_Tevd_iteracc_v_ops_var1(
        m_A: integer,
        n_G: integer,
        ijTL: integer,
        buff_d: *mut f32,
        inc_d: integer,
        buff_e: *mut f32,
        inc_e: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        n_iter_perf: *mut integer,
    ) -> FLA_Error;
    pub fn FLA_Tevd_iteracc_v_opd_var1(
        m_A: integer,
        n_G: integer,
        ijTL: integer,
        buff_d: *mut f64,
        inc_d: integer,
        buff_e: *mut f64,
        inc_e: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        n_iter_perf: *mut integer,
    ) -> FLA_Error;
    pub fn FLA_Tevd_iteracc_v_ops_var3(
        m_A: integer,
        m_U: integer,
        n_G: integer,
        ijTL: integer,
        buff_d: *mut f32,
        inc_d: integer,
        buff_e: *mut f32,
        inc_e: integer,
        buff_l: *mut f32,
        inc_l: integer,
        buff_ls: *mut integer,
        inc_ls: integer,
        buff_pu: *mut f32,
        inc_pu: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        n_iter_perf: *mut integer,
    ) -> FLA_Error;
    pub fn FLA_Tevd_iteracc_v_opd_var3(
        m_A: integer,
        m_U: integer,
        n_G: integer,
        ijTL: integer,
        buff_d: *mut f64,
        inc_d: integer,
        buff_e: *mut f64,
        inc_e: integer,
        buff_l: *mut f64,
        inc_l: integer,
        buff_ls: *mut integer,
        inc_ls: integer,
        buff_pu: *mut f64,
        inc_pu: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        n_iter_perf: *mut integer,
    ) -> FLA_Error;
    pub fn FLA_Tevd_eigval_v_opt_var1(
        G: FLA_Obj,
        d: FLA_Obj,
        e: FLA_Obj,
        n_iter: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Tevd_eigval_v_ops_var1(
        m_A: integer,
        n_G: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_d: *mut f32,
        inc_d: integer,
        buff_e: *mut f32,
        inc_e: integer,
        n_iter: *mut integer,
    ) -> FLA_Error;
    pub fn FLA_Tevd_eigval_v_opd_var1(
        m_A: integer,
        n_G: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_d: *mut f64,
        inc_d: integer,
        buff_e: *mut f64,
        inc_e: integer,
        n_iter: *mut integer,
    ) -> FLA_Error;
    pub fn FLA_Tevd_eigval_v_ops_var3(
        m_A: integer,
        m_U: integer,
        n_G: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_d: *mut f32,
        inc_d: integer,
        buff_e: *mut f32,
        inc_e: integer,
        buff_l: *mut f32,
        inc_l: integer,
        buff_ls: *mut integer,
        inc_ls: integer,
        buff_pu: *mut f32,
        inc_pu: integer,
        n_iter: *mut integer,
    ) -> FLA_Error;
    pub fn FLA_Tevd_eigval_v_opd_var3(
        m_A: integer,
        m_U: integer,
        n_G: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_d: *mut f64,
        inc_d: integer,
        buff_e: *mut f64,
        inc_e: integer,
        buff_l: *mut f64,
        inc_l: integer,
        buff_ls: *mut integer,
        inc_ls: integer,
        buff_pu: *mut f64,
        inc_pu: integer,
        n_iter: *mut integer,
    ) -> FLA_Error;
    pub fn FLA_Tevd_francis_v_opt_var1(
        shift: FLA_Obj,
        g: FLA_Obj,
        d: FLA_Obj,
        e: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Tevd_francis_v_ops_var1(
        m_A: integer,
        buff_shift: *mut f32,
        buff_g: *mut scomplex,
        inc_g: integer,
        buff_d: *mut f32,
        inc_d: integer,
        buff_e: *mut f32,
        inc_e: integer,
    ) -> FLA_Error;
    pub fn FLA_Tevd_francis_v_opd_var1(
        m_A: integer,
        buff_shift: *mut f64,
        buff_g: *mut dcomplex,
        inc_g: integer,
        buff_d: *mut f64,
        inc_d: integer,
        buff_e: *mut f64,
        inc_e: integer,
    ) -> FLA_Error;
    pub fn FLA_Tevd_compute_scaling_ops(
        m_A: integer,
        buff_d: *mut f32,
        inc_d: integer,
        buff_e: *mut f32,
        inc_e: integer,
        sigma: *mut f32,
    ) -> FLA_Error;
    pub fn FLA_Tevd_compute_scaling_opd(
        m_A: integer,
        buff_d: *mut f64,
        inc_d: integer,
        buff_e: *mut f64,
        inc_e: integer,
        sigma: *mut f64,
    ) -> FLA_Error;
    pub fn FLA_Tevd_find_perfshift_ops(
        m_d: integer,
        m_l: integer,
        buff_d: *mut f32,
        inc_d: integer,
        buff_e: *mut f32,
        inc_e: integer,
        buff_l: *mut f32,
        inc_l: integer,
        buff_lstat: *mut integer,
        inc_lstat: integer,
        buff_pu: *mut f32,
        inc_pu: integer,
        ij_shift: *mut integer,
    ) -> FLA_Error;
    pub fn FLA_Tevd_find_perfshift_opd(
        m_d: integer,
        m_l: integer,
        buff_d: *mut f64,
        inc_d: integer,
        buff_e: *mut f64,
        inc_e: integer,
        buff_l: *mut f64,
        inc_l: integer,
        buff_lstat: *mut integer,
        inc_lstat: integer,
        buff_pu: *mut f64,
        inc_pu: integer,
        ij_shift: *mut integer,
    ) -> FLA_Error;
    pub fn FLA_Tevd_v_opt_var1(
        n_iter_max: fla_dim_t,
        d: FLA_Obj,
        e: FLA_Obj,
        G: FLA_Obj,
        U: FLA_Obj,
        b_alg: fla_dim_t,
    ) -> FLA_Error;
    pub fn FLA_Tevd_v_ops_var1(
        m_A: integer,
        m_U: integer,
        n_G: integer,
        n_iter_max: integer,
        buff_d: *mut f32,
        inc_d: integer,
        buff_e: *mut f32,
        inc_e: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_U: *mut f32,
        rs_U: integer,
        cs_U: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Tevd_v_opd_var1(
        m_A: integer,
        m_U: integer,
        n_G: integer,
        n_iter_max: integer,
        buff_d: *mut f64,
        inc_d: integer,
        buff_e: *mut f64,
        inc_e: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_U: *mut f64,
        rs_U: integer,
        cs_U: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Tevd_v_opc_var1(
        m_A: integer,
        m_U: integer,
        n_G: integer,
        n_iter_max: integer,
        buff_d: *mut f32,
        inc_d: integer,
        buff_e: *mut f32,
        inc_e: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_U: *mut scomplex,
        rs_U: integer,
        cs_U: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Tevd_v_opz_var1(
        m_A: integer,
        m_U: integer,
        n_G: integer,
        n_iter_max: integer,
        buff_d: *mut f64,
        inc_d: integer,
        buff_e: *mut f64,
        inc_e: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_U: *mut dcomplex,
        rs_U: integer,
        cs_U: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Tevd_v_opt_var2(
        n_iter_max: fla_dim_t,
        d: FLA_Obj,
        e: FLA_Obj,
        G: FLA_Obj,
        R: FLA_Obj,
        W: FLA_Obj,
        U: FLA_Obj,
        b_alg: fla_dim_t,
    ) -> FLA_Error;
    pub fn FLA_Tevd_v_ops_var2(
        m_A: integer,
        m_U: integer,
        n_G: integer,
        n_G_extra: integer,
        buff_d: *mut f32,
        inc_d: integer,
        buff_e: *mut f32,
        inc_e: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_R: *mut f32,
        rs_R: integer,
        cs_R: integer,
        buff_W: *mut f32,
        rs_W: integer,
        cs_W: integer,
        buff_U: *mut f32,
        rs_U: integer,
        cs_U: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Tevd_v_opd_var2(
        m_A: integer,
        m_U: integer,
        n_G: integer,
        n_G_extra: integer,
        buff_d: *mut f64,
        inc_d: integer,
        buff_e: *mut f64,
        inc_e: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_R: *mut f64,
        rs_R: integer,
        cs_R: integer,
        buff_W: *mut f64,
        rs_W: integer,
        cs_W: integer,
        buff_U: *mut f64,
        rs_U: integer,
        cs_U: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Tevd_v_opc_var2(
        m_A: integer,
        m_U: integer,
        n_G: integer,
        n_G_extra: integer,
        buff_d: *mut f32,
        inc_d: integer,
        buff_e: *mut f32,
        inc_e: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_R: *mut f32,
        rs_R: integer,
        cs_R: integer,
        buff_W: *mut scomplex,
        rs_W: integer,
        cs_W: integer,
        buff_U: *mut scomplex,
        rs_U: integer,
        cs_U: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Tevd_v_opz_var2(
        m_A: integer,
        m_U: integer,
        n_G: integer,
        n_G_extra: integer,
        buff_d: *mut f64,
        inc_d: integer,
        buff_e: *mut f64,
        inc_e: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_R: *mut f64,
        rs_R: integer,
        cs_R: integer,
        buff_W: *mut dcomplex,
        rs_W: integer,
        cs_W: integer,
        buff_U: *mut dcomplex,
        rs_U: integer,
        cs_U: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Tevd(
        jobz: FLA_Evd_type,
        U: FLA_Obj,
        d: FLA_Obj,
        e: FLA_Obj,
        l: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Svd_ext_u_unb_var1(
        jobu: FLA_Svd_type,
        jobv: FLA_Svd_type,
        n_iter_max: fla_dim_t,
        A: FLA_Obj,
        s: FLA_Obj,
        V: FLA_Obj,
        U: FLA_Obj,
        k_accum: fla_dim_t,
        b_alg: fla_dim_t,
    ) -> FLA_Error;
    pub fn lapack_dbdsqr(
        uplo: *mut c_char,
        n: *mut integer,
        ncvt: *mut integer,
        nru: *mut integer,
        ncc: *mut integer,
        d__: *mut doublereal,
        e: *mut doublereal,
        vt: *mut doublereal,
        ldvt: *mut integer,
        u: *mut doublereal,
        ldu: *mut integer,
        c__: *mut doublereal,
        ldc: *mut integer,
        work: *mut doublereal,
        info: *mut integer,
    ) -> c_int;
    pub fn lapack_dbdsqr_small(
        uplo: *mut c_char,
        n: *mut integer,
        ncvt: *mut integer,
        nru: *mut integer,
        d__: *mut doublereal,
        e: *mut doublereal,
        vt: *mut doublereal,
        ldvt: *mut integer,
        u: *mut doublereal,
        ldu: *mut integer,
        info: *mut integer,
    ) -> c_int;
    pub fn lapack_dgebd2(
        m: *mut integer,
        n: *mut integer,
        a: *mut doublereal,
        lda: *mut integer,
        d__: *mut doublereal,
        e: *mut doublereal,
        tauq: *mut doublereal,
        taup: *mut doublereal,
        work: *mut doublereal,
        info: *mut integer,
    ) -> c_int;
    pub fn lapack_dgebrd(
        m: *mut integer,
        n: *mut integer,
        a: *mut doublereal,
        lda: *mut integer,
        d__: *mut doublereal,
        e: *mut doublereal,
        tauq: *mut doublereal,
        taup: *mut doublereal,
        work: *mut doublereal,
        lwork: *mut integer,
        info: *mut integer,
    ) -> c_int;
    pub fn lapack_dgelqf(
        m: *mut integer,
        n: *mut integer,
        a: *mut doublereal,
        lda: *mut integer,
        tau: *mut doublereal,
        work: *mut doublereal,
        lwork: *mut integer,
        info: *mut integer,
    ) -> c_int;
    pub fn lapack_dgelq2(
        m: *mut integer,
        n: *mut integer,
        a: *mut doublereal,
        lda: *mut integer,
        tau: *mut doublereal,
        work: *mut doublereal,
        info: *mut integer,
    ) -> c_int;
    pub fn lapack_dgesvd(
        jobu: *mut c_char,
        jobvt: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut doublereal,
        lda: *mut integer,
        s: *mut doublereal,
        u: *mut doublereal,
        ldu: *mut integer,
        vt: *mut doublereal,
        ldvt: *mut integer,
        work: *mut doublereal,
        lwork: *mut integer,
        info: *mut integer,
    ) -> c_int;
    pub fn lapack_dorg2r(
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut doublereal,
        lda: *mut integer,
        tau: *mut doublereal,
        work: *mut doublereal,
        info: *mut integer,
    ) -> c_int;
    pub fn lapack_dorgbr(
        vect: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut doublereal,
        lda: *mut integer,
        tau: *mut doublereal,
        work: *mut doublereal,
        lwork: *mut integer,
        info: *mut integer,
    ) -> c_int;
    pub fn lapack_dorgl2(
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut doublereal,
        lda: *mut integer,
        tau: *mut doublereal,
        work: *mut doublereal,
        info: *mut integer,
    ) -> c_int;
    pub fn lapack_dorglq(
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut doublereal,
        lda: *mut integer,
        tau: *mut doublereal,
        work: *mut doublereal,
        lwork: *mut integer,
        info: *mut integer,
    ) -> c_int;
    pub fn lapack_dorgqr(
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut doublereal,
        lda: *mut integer,
        tau: *mut doublereal,
        work: *mut doublereal,
        lwork: *mut integer,
        info: *mut integer,
    ) -> c_int;
    pub fn lapack_dorm2r(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut doublereal,
        lda: *mut integer,
        tau: *mut doublereal,
        c__: *mut doublereal,
        ldc: *mut integer,
        work: *mut doublereal,
        info: *mut integer,
    ) -> c_int;
    pub fn lapack_dormbr(
        vect: *mut c_char,
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut doublereal,
        lda: *mut integer,
        tau: *mut doublereal,
        c__: *mut doublereal,
        ldc: *mut integer,
        work: *mut doublereal,
        lwork: *mut integer,
        info: *mut integer,
    ) -> c_int;
    pub fn lapack_dormlq(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut doublereal,
        lda: *mut integer,
        tau: *mut doublereal,
        c__: *mut doublereal,
        ldc: *mut integer,
        work: *mut doublereal,
        lwork: *mut integer,
        info: *mut integer,
    ) -> c_int;
    pub fn lapack_dorml2(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut doublereal,
        lda: *mut integer,
        tau: *mut doublereal,
        c__: *mut doublereal,
        ldc: *mut integer,
        work: *mut doublereal,
        info: *mut integer,
    ) -> c_int;
    pub fn lapack_dormqr(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut doublereal,
        lda: *mut integer,
        tau: *mut doublereal,
        c__: *mut doublereal,
        ldc: *mut integer,
        work: *mut doublereal,
        lwork: *mut integer,
        info: *mut integer,
    ) -> c_int;
    pub fn dgesvd2x2(
        jobu: *mut c_char,
        jobvt: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut doublereal,
        lda: *mut integer,
        s: *mut doublereal,
        u: *mut doublereal,
        ldu: *mut integer,
        vt: *mut doublereal,
        ldvt: *mut integer,
        work: *mut doublereal,
        lwork: *mut integer,
        info: *mut integer,
    ) -> c_int;
    pub fn FLA_Svd_uv_unb_var1(
        n_iter_max: fla_dim_t,
        A: FLA_Obj,
        s: FLA_Obj,
        U: FLA_Obj,
        V: FLA_Obj,
        k_accum: fla_dim_t,
        b_alg: fla_dim_t,
    ) -> FLA_Error;
    pub fn FLA_Svd_uv_unb_var2(
        n_iter_max: fla_dim_t,
        A: FLA_Obj,
        s: FLA_Obj,
        U: FLA_Obj,
        V: FLA_Obj,
        k_accum: fla_dim_t,
        b_alg: fla_dim_t,
    ) -> FLA_Error;
    pub fn FLA_Svd_compute_scaling(A: FLA_Obj, sigma: FLA_Obj) -> FLA_Error;
    pub fn FLA_Svd(
        jobu: FLA_Svd_type,
        jobv: FLA_Svd_type,
        A: FLA_Obj,
        s: FLA_Obj,
        U: FLA_Obj,
        V: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Svd_ext(
        jobu: FLA_Svd_type,
        transu: FLA_Trans,
        jobv: FLA_Svd_type,
        transv: FLA_Trans,
        A: FLA_Obj,
        s: FLA_Obj,
        U: FLA_Obj,
        V: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Bsvd_iteracc_v_ops_var1(
        m_A: integer,
        n_GH: integer,
        ijTL: integer,
        tol: f32,
        thresh: f32,
        buff_d: *mut f32,
        inc_d: integer,
        buff_e: *mut f32,
        inc_e: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_H: *mut scomplex,
        rs_H: integer,
        cs_H: integer,
        n_iter_perf: *mut integer,
    ) -> FLA_Error;
    pub fn FLA_Bsvd_iteracc_v_opd_var1(
        m_A: integer,
        n_GH: integer,
        ijTL: integer,
        tol: f64,
        thresh: f64,
        buff_d: *mut f64,
        inc_d: integer,
        buff_e: *mut f64,
        inc_e: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_H: *mut dcomplex,
        rs_H: integer,
        cs_H: integer,
        n_iter_perf: *mut integer,
    ) -> FLA_Error;
    pub fn FLA_Bsvd_sinval_v_opt_var1(
        tol: FLA_Obj,
        thresh: FLA_Obj,
        G: FLA_Obj,
        H: FLA_Obj,
        d: FLA_Obj,
        e: FLA_Obj,
        n_iter: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Bsvd_sinval_v_ops_var1(
        m_A: integer,
        n_GH: integer,
        n_iter_allowed: integer,
        tol: f32,
        thresh: f32,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_H: *mut scomplex,
        rs_H: integer,
        cs_H: integer,
        buff_d: *mut f32,
        inc_d: integer,
        buff_e: *mut f32,
        inc_e: integer,
        n_iter: *mut integer,
    ) -> FLA_Error;
    pub fn FLA_Bsvd_sinval_v_opd_var1(
        m_A: integer,
        n_GH: integer,
        n_iter_allowed: integer,
        tol: f64,
        thresh: f64,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_H: *mut dcomplex,
        rs_H: integer,
        cs_H: integer,
        buff_d: *mut f64,
        inc_d: integer,
        buff_e: *mut f64,
        inc_e: integer,
        n_iter: *mut integer,
    ) -> FLA_Error;
    pub fn FLA_Bsvd_francis_v_opt_var1(
        shift: FLA_Obj,
        g: FLA_Obj,
        h: FLA_Obj,
        d: FLA_Obj,
        e: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Bsvd_francis_v_ops_var1(
        m_A: integer,
        shift: f32,
        buff_g: *mut scomplex,
        inc_g: integer,
        buff_h: *mut scomplex,
        inc_h: integer,
        buff_d: *mut f32,
        inc_d: integer,
        buff_e: *mut f32,
        inc_e: integer,
    ) -> FLA_Error;
    pub fn FLA_Bsvd_francis_v_opd_var1(
        m_A: integer,
        shift: f64,
        buff_g: *mut dcomplex,
        inc_g: integer,
        buff_h: *mut dcomplex,
        inc_h: integer,
        buff_d: *mut f64,
        inc_d: integer,
        buff_e: *mut f64,
        inc_e: integer,
    ) -> FLA_Error;
    pub fn FLA_Bsvd_compute_shift(
        tol: FLA_Obj,
        sminl: FLA_Obj,
        smax: FLA_Obj,
        d: FLA_Obj,
        e: FLA_Obj,
        shift: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Bsvd_compute_shift_ops(
        m_A: integer,
        tol: f32,
        sminl: f32,
        smax: f32,
        buff_d: *mut f32,
        inc_d: integer,
        buff_e: *mut f32,
        inc_e: integer,
        shift: *mut f32,
    ) -> FLA_Error;
    pub fn FLA_Bsvd_compute_shift_opd(
        m_A: integer,
        tol: f64,
        sminl: f64,
        smax: f64,
        buff_d: *mut f64,
        inc_d: integer,
        buff_e: *mut f64,
        inc_e: integer,
        shift: *mut f64,
    ) -> FLA_Error;
    pub fn FLA_Bsvd_compute_tol_thresh(
        tolmul: FLA_Obj,
        maxit: FLA_Obj,
        d: FLA_Obj,
        e: FLA_Obj,
        tol: FLA_Obj,
        thresh: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Bsvd_compute_tol_thresh_ops(
        m_A: integer,
        tolmul: f32,
        maxit: f32,
        buff_d: *mut f32,
        inc_d: integer,
        buff_e: *mut f32,
        inc_e: integer,
        tol: *mut f32,
        thresh: *mut f32,
    ) -> FLA_Error;
    pub fn FLA_Bsvd_compute_tol_thresh_opd(
        m_A: integer,
        tolmul: f64,
        maxit: f64,
        buff_d: *mut f64,
        inc_d: integer,
        buff_e: *mut f64,
        inc_e: integer,
        tol: *mut f64,
        thresh: *mut f64,
    ) -> FLA_Error;
    pub fn FLA_Bsvd_find_converged(
        tol: FLA_Obj,
        d: FLA_Obj,
        e: FLA_Obj,
        sminl: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Bsvd_find_converged_ops(
        m_A: integer,
        tol: f32,
        buff_d: *mut f32,
        inc_d: integer,
        buff_e: *mut f32,
        inc_e: integer,
        sminl: *mut f32,
    ) -> FLA_Error;
    pub fn FLA_Bsvd_find_converged_opd(
        m_A: integer,
        tol: f64,
        buff_d: *mut f64,
        inc_d: integer,
        buff_e: *mut f64,
        inc_e: integer,
        sminl: *mut f64,
    ) -> FLA_Error;
    pub fn FLA_Bsvd_find_max_fla_min(
        d: FLA_Obj,
        e: FLA_Obj,
        smax: FLA_Obj,
        smin: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Bsvd_find_max_min_ops(
        m_A: integer,
        buff_d: *mut f32,
        inc_d: integer,
        buff_e: *mut f32,
        inc_e: integer,
        smax: *mut f32,
        smin: *mut f32,
    ) -> FLA_Error;
    pub fn FLA_Bsvd_find_max_min_opd(
        m_A: integer,
        buff_d: *mut f64,
        inc_d: integer,
        buff_e: *mut f64,
        inc_e: integer,
        smax: *mut f64,
        smin: *mut f64,
    ) -> FLA_Error;
    pub fn FLA_Bsvd_find_submatrix_ops(
        mn_A: integer,
        ij_begin: integer,
        buff_d: *mut f32,
        inc_d: integer,
        buff_e: *mut f32,
        inc_e: integer,
        ijTL: *mut integer,
        ijBR: *mut integer,
    ) -> FLA_Error;
    pub fn FLA_Bsvd_find_submatrix_opd(
        mn_A: integer,
        ij_begin: integer,
        buff_d: *mut f64,
        inc_d: integer,
        buff_e: *mut f64,
        inc_e: integer,
        ijTL: *mut integer,
        ijBR: *mut integer,
    ) -> FLA_Error;
    pub fn FLA_Bsvd_v_opt_var1(
        n_iter_max: fla_dim_t,
        d: FLA_Obj,
        e: FLA_Obj,
        G: FLA_Obj,
        H: FLA_Obj,
        U: FLA_Obj,
        V: FLA_Obj,
        b_alg: fla_dim_t,
    ) -> FLA_Error;
    pub fn FLA_Bsvd_v_ops_var1(
        min_m_n: integer,
        m_U: integer,
        m_V: integer,
        n_GH: integer,
        n_iter_max: integer,
        buff_d: *mut f32,
        inc_d: integer,
        buff_e: *mut f32,
        inc_e: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_H: *mut scomplex,
        rs_H: integer,
        cs_H: integer,
        buff_U: *mut f32,
        rs_U: integer,
        cs_U: integer,
        buff_V: *mut f32,
        rs_V: integer,
        cs_V: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Bsvd_v_opd_var1(
        min_m_n: integer,
        m_U: integer,
        m_V: integer,
        n_GH: integer,
        n_iter_max: integer,
        buff_d: *mut f64,
        inc_d: integer,
        buff_e: *mut f64,
        inc_e: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_H: *mut dcomplex,
        rs_H: integer,
        cs_H: integer,
        buff_U: *mut f64,
        rs_U: integer,
        cs_U: integer,
        buff_V: *mut f64,
        rs_V: integer,
        cs_V: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Bsvd_v_opc_var1(
        min_m_n: integer,
        m_U: integer,
        m_V: integer,
        n_GH: integer,
        n_iter_max: integer,
        buff_d: *mut f32,
        inc_d: integer,
        buff_e: *mut f32,
        inc_e: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_H: *mut scomplex,
        rs_H: integer,
        cs_H: integer,
        buff_U: *mut scomplex,
        rs_U: integer,
        cs_U: integer,
        buff_V: *mut scomplex,
        rs_V: integer,
        cs_V: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Bsvd_v_opz_var1(
        min_m_n: integer,
        m_U: integer,
        m_V: integer,
        n_GH: integer,
        n_iter_max: integer,
        buff_d: *mut f64,
        inc_d: integer,
        buff_e: *mut f64,
        inc_e: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_H: *mut dcomplex,
        rs_H: integer,
        cs_H: integer,
        buff_U: *mut dcomplex,
        rs_U: integer,
        cs_U: integer,
        buff_V: *mut dcomplex,
        rs_V: integer,
        cs_V: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Bsvd_v_opt_var2(
        n_iter_max: fla_dim_t,
        d: FLA_Obj,
        e: FLA_Obj,
        G: FLA_Obj,
        H: FLA_Obj,
        RG: FLA_Obj,
        RH: FLA_Obj,
        W: FLA_Obj,
        U: FLA_Obj,
        V: FLA_Obj,
        b_alg: fla_dim_t,
    ) -> FLA_Error;
    pub fn FLA_Bsvd_v_ops_var2(
        min_m_n: integer,
        m_U: integer,
        m_V: integer,
        n_GH: integer,
        n_iter_max: integer,
        buff_d: *mut f32,
        inc_d: integer,
        buff_e: *mut f32,
        inc_e: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_H: *mut scomplex,
        rs_H: integer,
        cs_H: integer,
        buff_RG: *mut f32,
        rs_RG: integer,
        cs_RG: integer,
        buff_RH: *mut f32,
        rs_RH: integer,
        cs_RH: integer,
        buff_W: *mut f32,
        rs_W: integer,
        cs_W: integer,
        buff_U: *mut f32,
        rs_U: integer,
        cs_U: integer,
        buff_V: *mut f32,
        rs_V: integer,
        cs_V: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Bsvd_v_opd_var2(
        min_m_n: integer,
        m_U: integer,
        m_V: integer,
        n_GH: integer,
        n_iter_max: integer,
        buff_d: *mut f64,
        inc_d: integer,
        buff_e: *mut f64,
        inc_e: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_H: *mut dcomplex,
        rs_H: integer,
        cs_H: integer,
        buff_RG: *mut f64,
        rs_RG: integer,
        cs_RG: integer,
        buff_RH: *mut f64,
        rs_RH: integer,
        cs_RH: integer,
        buff_W: *mut f64,
        rs_W: integer,
        cs_W: integer,
        buff_U: *mut f64,
        rs_U: integer,
        cs_U: integer,
        buff_V: *mut f64,
        rs_V: integer,
        cs_V: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Bsvd_v_opc_var2(
        min_m_n: integer,
        m_U: integer,
        m_V: integer,
        n_GH: integer,
        n_iter_max: integer,
        buff_d: *mut f32,
        inc_d: integer,
        buff_e: *mut f32,
        inc_e: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_H: *mut scomplex,
        rs_H: integer,
        cs_H: integer,
        buff_RG: *mut f32,
        rs_RG: integer,
        cs_RG: integer,
        buff_RH: *mut f32,
        rs_RH: integer,
        cs_RH: integer,
        buff_W: *mut scomplex,
        rs_W: integer,
        cs_W: integer,
        buff_U: *mut scomplex,
        rs_U: integer,
        cs_U: integer,
        buff_V: *mut scomplex,
        rs_V: integer,
        cs_V: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Bsvd_v_opz_var2(
        min_m_n: integer,
        m_U: integer,
        m_V: integer,
        n_GH: integer,
        n_iter_max: integer,
        buff_d: *mut f64,
        inc_d: integer,
        buff_e: *mut f64,
        inc_e: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_H: *mut dcomplex,
        rs_H: integer,
        cs_H: integer,
        buff_RG: *mut f64,
        rs_RG: integer,
        cs_RG: integer,
        buff_RH: *mut f64,
        rs_RH: integer,
        cs_RH: integer,
        buff_W: *mut dcomplex,
        rs_W: integer,
        cs_W: integer,
        buff_U: *mut dcomplex,
        rs_U: integer,
        cs_U: integer,
        buff_V: *mut dcomplex,
        rs_V: integer,
        cs_V: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Bsvd_ext_opt_var1(
        n_iter_max: fla_dim_t,
        d: FLA_Obj,
        e: FLA_Obj,
        G: FLA_Obj,
        H: FLA_Obj,
        jobu: FLA_Svd_type,
        U: FLA_Obj,
        jobv: FLA_Svd_type,
        V: FLA_Obj,
        apply_Uh2C: FLA_Bool,
        C: FLA_Obj,
        b_alg: fla_dim_t,
    ) -> FLA_Error;
    pub fn FLA_Bsvd_ext_ops_var1(
        m_d: integer,
        m_U: integer,
        m_V: integer,
        m_C: integer,
        n_C: integer,
        n_GH: integer,
        n_iter_max: integer,
        buff_d: *mut f32,
        inc_d: integer,
        buff_e: *mut f32,
        inc_e: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_H: *mut scomplex,
        rs_H: integer,
        cs_H: integer,
        buff_U: *mut f32,
        rs_U: integer,
        cs_U: integer,
        buff_V: *mut f32,
        rs_V: integer,
        cs_V: integer,
        buff_C: *mut f32,
        rs_C: integer,
        cs_C: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Bsvd_ext_opd_var1(
        m_d: integer,
        m_U: integer,
        m_V: integer,
        m_C: integer,
        n_C: integer,
        n_GH: integer,
        n_iter_max: integer,
        buff_d: *mut f64,
        inc_d: integer,
        buff_e: *mut f64,
        inc_e: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_H: *mut dcomplex,
        rs_H: integer,
        cs_H: integer,
        buff_U: *mut f64,
        rs_U: integer,
        cs_U: integer,
        buff_V: *mut f64,
        rs_V: integer,
        cs_V: integer,
        buff_C: *mut f64,
        rs_C: integer,
        cs_C: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Bsvd_ext_opc_var1(
        m_d: integer,
        m_U: integer,
        m_V: integer,
        m_C: integer,
        n_C: integer,
        n_GH: integer,
        n_iter_max: integer,
        buff_d: *mut f32,
        inc_d: integer,
        buff_e: *mut f32,
        inc_e: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_H: *mut scomplex,
        rs_H: integer,
        cs_H: integer,
        buff_U: *mut scomplex,
        rs_U: integer,
        cs_U: integer,
        buff_V: *mut scomplex,
        rs_V: integer,
        cs_V: integer,
        buff_C: *mut scomplex,
        rs_C: integer,
        cs_C: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Bsvd_ext_opz_var1(
        m_d: integer,
        m_U: integer,
        m_V: integer,
        m_C: integer,
        n_C: integer,
        n_GH: integer,
        n_iter_max: integer,
        buff_d: *mut f64,
        inc_d: integer,
        buff_e: *mut f64,
        inc_e: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_H: *mut dcomplex,
        rs_H: integer,
        cs_H: integer,
        buff_U: *mut dcomplex,
        rs_U: integer,
        cs_U: integer,
        buff_V: *mut dcomplex,
        rs_V: integer,
        cs_V: integer,
        buff_C: *mut dcomplex,
        rs_C: integer,
        cs_C: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Bsvd_create_workspace(d: FLA_Obj, G: *mut FLA_Obj, H: *mut FLA_Obj) -> FLA_Error;
    pub fn FLA_Bsvd(
        uplo: FLA_Uplo,
        d: FLA_Obj,
        e: FLA_Obj,
        G: FLA_Obj,
        H: FLA_Obj,
        jobu: FLA_Svd_type,
        U: FLA_Obj,
        jobv: FLA_Svd_type,
        V: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Bsvd_ext(
        uplo: FLA_Uplo,
        d: FLA_Obj,
        e: FLA_Obj,
        G: FLA_Obj,
        H: FLA_Obj,
        jobu: FLA_Svd_type,
        U: FLA_Obj,
        jobv: FLA_Svd_type,
        V: FLA_Obj,
        apply_Uh2C: FLA_Bool,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Trinv_ln_blk_var1(A: FLA_Obj, cntl: *mut fla_trinv_t) -> FLA_Error;
    pub fn FLA_Trinv_ln_blk_var2(A: FLA_Obj, cntl: *mut fla_trinv_t) -> FLA_Error;
    pub fn FLA_Trinv_ln_blk_var3(A: FLA_Obj, cntl: *mut fla_trinv_t) -> FLA_Error;
    pub fn FLA_Trinv_ln_blk_var4(A: FLA_Obj, cntl: *mut fla_trinv_t) -> FLA_Error;
    pub fn FLA_Trinv_ln_unb_var1(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Trinv_ln_unb_var2(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Trinv_ln_unb_var3(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Trinv_ln_unb_var4(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Trinv_ln_opt_var1(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Trinv_ln_ops_var1(
        mn_A: integer,
        A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_ln_opd_var1(
        mn_A: integer,
        A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_ln_opc_var1(
        mn_A: integer,
        A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_ln_opz_var1(
        mn_A: integer,
        A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_ln_opt_var2(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Trinv_ln_ops_var2(
        mn_A: integer,
        A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_ln_opd_var2(
        mn_A: integer,
        A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_ln_opc_var2(
        mn_A: integer,
        A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_ln_opz_var2(
        mn_A: integer,
        A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_ln_opt_var3(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Trinv_ln_ops_var3(
        mn_A: integer,
        A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_ln_opd_var3(
        mn_A: integer,
        A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_ln_opc_var3(
        mn_A: integer,
        A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_ln_opz_var3(
        mn_A: integer,
        A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_ln_opt_var4(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Trinv_ln_ops_var4(
        mn_A: integer,
        A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_ln_opd_var4(
        mn_A: integer,
        A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_ln_opc_var4(
        mn_A: integer,
        A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_ln_opz_var4(
        mn_A: integer,
        A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_lu_blk_var1(A: FLA_Obj, cntl: *mut fla_trinv_t) -> FLA_Error;
    pub fn FLA_Trinv_lu_blk_var2(A: FLA_Obj, cntl: *mut fla_trinv_t) -> FLA_Error;
    pub fn FLA_Trinv_lu_blk_var3(A: FLA_Obj, cntl: *mut fla_trinv_t) -> FLA_Error;
    pub fn FLA_Trinv_lu_blk_var4(A: FLA_Obj, cntl: *mut fla_trinv_t) -> FLA_Error;
    pub fn FLA_Trinv_lu_unb_var1(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Trinv_lu_unb_var2(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Trinv_lu_unb_var3(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Trinv_lu_unb_var4(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Trinv_lu_opt_var1(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Trinv_lu_ops_var1(
        mn_A: integer,
        A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_lu_opd_var1(
        mn_A: integer,
        A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_lu_opc_var1(
        mn_A: integer,
        A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_lu_opz_var1(
        mn_A: integer,
        A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_lu_opt_var2(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Trinv_lu_ops_var2(
        mn_A: integer,
        A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_lu_opd_var2(
        mn_A: integer,
        A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_lu_opc_var2(
        mn_A: integer,
        A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_lu_opz_var2(
        mn_A: integer,
        A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_lu_opt_var3(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Trinv_lu_ops_var3(
        mn_A: integer,
        A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_lu_opd_var3(
        mn_A: integer,
        A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_lu_opc_var3(
        mn_A: integer,
        A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_lu_opz_var3(
        mn_A: integer,
        A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_lu_opt_var4(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Trinv_lu_ops_var4(
        mn_A: integer,
        A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_lu_opd_var4(
        mn_A: integer,
        A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_lu_opc_var4(
        mn_A: integer,
        A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_lu_opz_var4(
        mn_A: integer,
        A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn lapack_dtrtri(
        uplo: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        a: *mut doublereal,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn lapack_dtrti2(
        uplo: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        a: *mut doublereal,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn FLA_Trinv_un_blk_var1(A: FLA_Obj, cntl: *mut fla_trinv_t) -> FLA_Error;
    pub fn FLA_Trinv_un_blk_var2(A: FLA_Obj, cntl: *mut fla_trinv_t) -> FLA_Error;
    pub fn FLA_Trinv_un_blk_var3(A: FLA_Obj, cntl: *mut fla_trinv_t) -> FLA_Error;
    pub fn FLA_Trinv_un_blk_var4(A: FLA_Obj, cntl: *mut fla_trinv_t) -> FLA_Error;
    pub fn FLA_Trinv_un_unb_var1(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Trinv_un_unb_var2(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Trinv_un_unb_var3(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Trinv_un_unb_var4(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Trinv_un_opt_var1(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Trinv_un_ops_var1(
        mn_A: integer,
        A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_un_opd_var1(
        mn_A: integer,
        A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_un_opc_var1(
        mn_A: integer,
        A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_un_opz_var1(
        mn_A: integer,
        A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_un_opt_var2(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Trinv_un_ops_var2(
        mn_A: integer,
        A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_un_opd_var2(
        mn_A: integer,
        A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_un_opc_var2(
        mn_A: integer,
        A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_un_opz_var2(
        mn_A: integer,
        A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_un_opt_var3(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Trinv_un_ops_var3(
        mn_A: integer,
        A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_un_opd_var3(
        mn_A: integer,
        A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_un_opc_var3(
        mn_A: integer,
        A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_un_opz_var3(
        mn_A: integer,
        A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_un_opt_var4(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Trinv_un_ops_var4(
        mn_A: integer,
        A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_un_opd_var4(
        mn_A: integer,
        A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_un_opc_var4(
        mn_A: integer,
        A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_un_opz_var4(
        mn_A: integer,
        A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_uu_blk_var1(A: FLA_Obj, cntl: *mut fla_trinv_t) -> FLA_Error;
    pub fn FLA_Trinv_uu_blk_var2(A: FLA_Obj, cntl: *mut fla_trinv_t) -> FLA_Error;
    pub fn FLA_Trinv_uu_blk_var3(A: FLA_Obj, cntl: *mut fla_trinv_t) -> FLA_Error;
    pub fn FLA_Trinv_uu_blk_var4(A: FLA_Obj, cntl: *mut fla_trinv_t) -> FLA_Error;
    pub fn FLA_Trinv_uu_unb_var1(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Trinv_uu_unb_var2(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Trinv_uu_unb_var3(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Trinv_uu_unb_var4(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Trinv_uu_opt_var1(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Trinv_uu_ops_var1(
        mn_A: integer,
        A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_uu_opd_var1(
        mn_A: integer,
        A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_uu_opc_var1(
        mn_A: integer,
        A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_uu_opz_var1(
        mn_A: integer,
        A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_uu_opt_var2(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Trinv_uu_ops_var2(
        mn_A: integer,
        A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_uu_opd_var2(
        mn_A: integer,
        A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_uu_opc_var2(
        mn_A: integer,
        A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_uu_opz_var2(
        mn_A: integer,
        A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_uu_opt_var3(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Trinv_uu_ops_var3(
        mn_A: integer,
        A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_uu_opd_var3(
        mn_A: integer,
        A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_uu_opc_var3(
        mn_A: integer,
        A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_uu_opz_var3(
        mn_A: integer,
        A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_uu_opt_var4(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Trinv_uu_ops_var4(
        mn_A: integer,
        A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_uu_opd_var4(
        mn_A: integer,
        A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_uu_opc_var4(
        mn_A: integer,
        A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_uu_opz_var4(
        mn_A: integer,
        A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Trinv_internal(
        uplo: FLA_Uplo,
        diag: FLA_Diag,
        A: FLA_Obj,
        cntl: *mut fla_trinv_t,
    ) -> FLA_Error;
    pub fn FLA_Trinv_ln(A: FLA_Obj, cntl: *mut fla_trinv_t) -> FLA_Error;
    pub fn FLA_Trinv_lu(A: FLA_Obj, cntl: *mut fla_trinv_t) -> FLA_Error;
    pub fn FLA_Trinv_un(A: FLA_Obj, cntl: *mut fla_trinv_t) -> FLA_Error;
    pub fn FLA_Trinv_uu(A: FLA_Obj, cntl: *mut fla_trinv_t) -> FLA_Error;
    pub fn FLA_SPDinv_internal(uplo: FLA_Uplo, A: FLA_Obj, cntl: *mut fla_spdinv_t) -> FLA_Error;
    pub fn FLA_Hess_UT_blk_var1(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Hess_UT_unb_var1(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Hess_UT_step_unb_var1(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Hess_UT_blk_var2(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Hess_UT_blf_var2(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Hess_UT_unb_var2(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Hess_UT_step_unb_var2(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Hess_UT_blk_var3(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Hess_UT_blf_var3(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Hess_UT_unb_var3(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Hess_UT_step_unb_var3(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Hess_UT_blk_var4(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Hess_UT_blf_var4(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Hess_UT_unb_var4(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Hess_UT_step_unb_var4(A: FLA_Obj, Y: FLA_Obj, Z: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Hess_UT_blk_var5(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Hess_UT_unb_var5(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Hess_UT_step_unb_var5(A: FLA_Obj, U: FLA_Obj, Z: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Hess_UT_opt_var1(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Hess_UT_step_opt_var1(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Hess_UT_step_ops_var1(
        m_A: integer,
        m_T: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut f32,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Hess_UT_step_opd_var1(
        m_A: integer,
        m_T: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut f64,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Hess_UT_step_opc_var1(
        m_A: integer,
        m_T: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut scomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Hess_UT_step_opz_var1(
        m_A: integer,
        m_T: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut dcomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Hess_UT_opt_var2(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Hess_UT_step_opt_var2(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Hess_UT_step_ops_var2(
        m_A: integer,
        m_T: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut f32,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Hess_UT_step_opd_var2(
        m_A: integer,
        m_T: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut f64,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Hess_UT_step_opc_var2(
        m_A: integer,
        m_T: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut scomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Hess_UT_step_opz_var2(
        m_A: integer,
        m_T: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut dcomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Hess_UT_opt_var3(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Hess_UT_step_opt_var3(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Hess_UT_step_ops_var3(
        m_A: integer,
        m_T: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut f32,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Hess_UT_step_opd_var3(
        m_A: integer,
        m_T: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut f64,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Hess_UT_step_opc_var3(
        m_A: integer,
        m_T: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut scomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Hess_UT_step_opz_var3(
        m_A: integer,
        m_T: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut dcomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Hess_UT_opt_var4(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Hess_UT_step_opt_var4(A: FLA_Obj, Y: FLA_Obj, Z: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Hess_UT_step_ops_var4(
        m_A: integer,
        m_T: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_Y: *mut f32,
        rs_Y: integer,
        cs_Y: integer,
        buff_Z: *mut f32,
        rs_Z: integer,
        cs_Z: integer,
        buff_T: *mut f32,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Hess_UT_step_opd_var4(
        m_A: integer,
        m_T: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_Y: *mut f64,
        rs_Y: integer,
        cs_Y: integer,
        buff_Z: *mut f64,
        rs_Z: integer,
        cs_Z: integer,
        buff_T: *mut f64,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Hess_UT_step_opc_var4(
        m_A: integer,
        m_T: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_Y: *mut scomplex,
        rs_Y: integer,
        cs_Y: integer,
        buff_Z: *mut scomplex,
        rs_Z: integer,
        cs_Z: integer,
        buff_T: *mut scomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Hess_UT_step_opz_var4(
        m_A: integer,
        m_T: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_Y: *mut dcomplex,
        rs_Y: integer,
        cs_Y: integer,
        buff_Z: *mut dcomplex,
        rs_Z: integer,
        cs_Z: integer,
        buff_T: *mut dcomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Hess_UT_opt_var5(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Hess_UT_step_opt_var5(A: FLA_Obj, U: FLA_Obj, Z: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Hess_UT_step_ops_var5(
        m_A: integer,
        m_T: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_U: *mut f32,
        rs_U: integer,
        cs_U: integer,
        buff_Z: *mut f32,
        rs_Z: integer,
        cs_Z: integer,
        buff_T: *mut f32,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Hess_UT_step_opd_var5(
        m_A: integer,
        m_T: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_U: *mut f64,
        rs_U: integer,
        cs_U: integer,
        buff_Z: *mut f64,
        rs_Z: integer,
        cs_Z: integer,
        buff_T: *mut f64,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Hess_UT_step_opc_var5(
        m_A: integer,
        m_T: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_U: *mut scomplex,
        rs_U: integer,
        cs_U: integer,
        buff_Z: *mut scomplex,
        rs_Z: integer,
        cs_Z: integer,
        buff_T: *mut scomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Hess_UT_step_opz_var5(
        m_A: integer,
        m_T: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_U: *mut dcomplex,
        rs_U: integer,
        cs_U: integer,
        buff_Z: *mut dcomplex,
        rs_Z: integer,
        cs_Z: integer,
        buff_T: *mut dcomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Hess_UT_ofu_var1(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Hess_UT_step_ofu_var1(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Hess_UT_step_ofs_var1(
        m_A: integer,
        m_T: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut f32,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Hess_UT_step_ofd_var1(
        m_A: integer,
        m_T: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut f64,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Hess_UT_step_ofc_var1(
        m_A: integer,
        m_T: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut scomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Hess_UT_step_ofz_var1(
        m_A: integer,
        m_T: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut dcomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Hess_UT_ofu_var2(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Hess_UT_step_ofu_var2(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Hess_UT_step_ofs_var2(
        m_A: integer,
        m_T: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut f32,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Hess_UT_step_ofd_var2(
        m_A: integer,
        m_T: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut f64,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Hess_UT_step_ofc_var2(
        m_A: integer,
        m_T: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut scomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Hess_UT_step_ofz_var2(
        m_A: integer,
        m_T: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut dcomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Hess_UT_ofu_var3(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Hess_UT_step_ofu_var3(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Hess_UT_step_ofs_var3(
        m_A: integer,
        m_T: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut f32,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Hess_UT_step_ofd_var3(
        m_A: integer,
        m_T: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut f64,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Hess_UT_step_ofc_var3(
        m_A: integer,
        m_T: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut scomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Hess_UT_step_ofz_var3(
        m_A: integer,
        m_T: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut dcomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Hess_UT_ofu_var4(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Hess_UT_step_ofu_var4(A: FLA_Obj, Y: FLA_Obj, Z: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Hess_UT_step_ofs_var4(
        m_A: integer,
        m_T: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_Y: *mut f32,
        rs_Y: integer,
        cs_Y: integer,
        buff_Z: *mut f32,
        rs_Z: integer,
        cs_Z: integer,
        buff_T: *mut f32,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Hess_UT_step_ofd_var4(
        m_A: integer,
        m_T: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_Y: *mut f64,
        rs_Y: integer,
        cs_Y: integer,
        buff_Z: *mut f64,
        rs_Z: integer,
        cs_Z: integer,
        buff_T: *mut f64,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Hess_UT_step_ofc_var4(
        m_A: integer,
        m_T: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_Y: *mut scomplex,
        rs_Y: integer,
        cs_Y: integer,
        buff_Z: *mut scomplex,
        rs_Z: integer,
        cs_Z: integer,
        buff_T: *mut scomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Hess_UT_step_ofz_var4(
        m_A: integer,
        m_T: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_Y: *mut dcomplex,
        rs_Y: integer,
        cs_Y: integer,
        buff_Z: *mut dcomplex,
        rs_Z: integer,
        cs_Z: integer,
        buff_T: *mut dcomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Fused_Ahx_Ax_ops_var1(
        m_A: integer,
        n_A: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_x: *mut f32,
        inc_x: integer,
        buff_v: *mut f32,
        inc_v: integer,
        buff_w: *mut f32,
        inc_w: integer,
    ) -> FLA_Error;
    pub fn FLA_Fused_Ahx_Ax_opd_var1(
        m_A: integer,
        n_A: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_x: *mut f64,
        inc_x: integer,
        buff_v: *mut f64,
        inc_v: integer,
        buff_w: *mut f64,
        inc_w: integer,
    ) -> FLA_Error;
    pub fn FLA_Fused_Ahx_Ax_opc_var1(
        m_A: integer,
        n_A: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_x: *mut scomplex,
        inc_x: integer,
        buff_v: *mut scomplex,
        inc_v: integer,
        buff_w: *mut scomplex,
        inc_w: integer,
    ) -> FLA_Error;
    pub fn FLA_Fused_Ahx_Ax_opz_var1(
        m_A: integer,
        n_A: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_x: *mut dcomplex,
        inc_x: integer,
        buff_v: *mut dcomplex,
        inc_v: integer,
        buff_w: *mut dcomplex,
        inc_w: integer,
    ) -> FLA_Error;
    pub fn FLA_Fused_Gerc2_Ahx_Ax_ops_var1(
        m_A: integer,
        n_A: integer,
        buff_alpha: *mut f32,
        buff_u: *mut f32,
        inc_u: integer,
        buff_y: *mut f32,
        inc_y: integer,
        buff_z: *mut f32,
        inc_z: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_x: *mut f32,
        inc_x: integer,
        buff_v: *mut f32,
        inc_v: integer,
        buff_w: *mut f32,
        inc_w: integer,
    ) -> FLA_Error;
    pub fn FLA_Fused_Gerc2_Ahx_Ax_opd_var1(
        m_A: integer,
        n_A: integer,
        buff_alpha: *mut f64,
        buff_u: *mut f64,
        inc_u: integer,
        buff_y: *mut f64,
        inc_y: integer,
        buff_z: *mut f64,
        inc_z: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_x: *mut f64,
        inc_x: integer,
        buff_v: *mut f64,
        inc_v: integer,
        buff_w: *mut f64,
        inc_w: integer,
    ) -> FLA_Error;
    pub fn FLA_Fused_Gerc2_Ahx_Ax_opc_var1(
        m_A: integer,
        n_A: integer,
        buff_alpha: *mut scomplex,
        buff_u: *mut scomplex,
        inc_u: integer,
        buff_y: *mut scomplex,
        inc_y: integer,
        buff_z: *mut scomplex,
        inc_z: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_x: *mut scomplex,
        inc_x: integer,
        buff_v: *mut scomplex,
        inc_v: integer,
        buff_w: *mut scomplex,
        inc_w: integer,
    ) -> FLA_Error;
    pub fn FLA_Fused_Gerc2_Ahx_Ax_opz_var1(
        m_A: integer,
        n_A: integer,
        buff_alpha: *mut dcomplex,
        buff_u: *mut dcomplex,
        inc_u: integer,
        buff_y: *mut dcomplex,
        inc_y: integer,
        buff_z: *mut dcomplex,
        inc_z: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_x: *mut dcomplex,
        inc_x: integer,
        buff_v: *mut dcomplex,
        inc_v: integer,
        buff_w: *mut dcomplex,
        inc_w: integer,
    ) -> FLA_Error;
    pub fn FLA_Fused_Uhu_Yhu_Zhu_ops_var1(
        m_U: integer,
        n_U: integer,
        buff_delta: *mut f32,
        buff_U: *mut f32,
        rs_U: integer,
        cs_U: integer,
        buff_Y: *mut f32,
        rs_Y: integer,
        cs_Y: integer,
        buff_Z: *mut f32,
        rs_Z: integer,
        cs_Z: integer,
        buff_t: *mut f32,
        inc_t: integer,
        buff_u: *mut f32,
        inc_u: integer,
        buff_y: *mut f32,
        inc_y: integer,
        buff_z: *mut f32,
        inc_z: integer,
    ) -> FLA_Error;
    pub fn FLA_Fused_Uhu_Yhu_Zhu_opd_var1(
        m_U: integer,
        n_U: integer,
        buff_delta: *mut f64,
        buff_U: *mut f64,
        rs_U: integer,
        cs_U: integer,
        buff_Y: *mut f64,
        rs_Y: integer,
        cs_Y: integer,
        buff_Z: *mut f64,
        rs_Z: integer,
        cs_Z: integer,
        buff_t: *mut f64,
        inc_t: integer,
        buff_u: *mut f64,
        inc_u: integer,
        buff_y: *mut f64,
        inc_y: integer,
        buff_z: *mut f64,
        inc_z: integer,
    ) -> FLA_Error;
    pub fn FLA_Fused_Uhu_Yhu_Zhu_opc_var1(
        m_U: integer,
        n_U: integer,
        buff_delta: *mut scomplex,
        buff_U: *mut scomplex,
        rs_U: integer,
        cs_U: integer,
        buff_Y: *mut scomplex,
        rs_Y: integer,
        cs_Y: integer,
        buff_Z: *mut scomplex,
        rs_Z: integer,
        cs_Z: integer,
        buff_t: *mut scomplex,
        inc_t: integer,
        buff_u: *mut scomplex,
        inc_u: integer,
        buff_y: *mut scomplex,
        inc_y: integer,
        buff_z: *mut scomplex,
        inc_z: integer,
    ) -> FLA_Error;
    pub fn FLA_Fused_Uhu_Yhu_Zhu_opz_var1(
        m_U: integer,
        n_U: integer,
        buff_delta: *mut dcomplex,
        buff_U: *mut dcomplex,
        rs_U: integer,
        cs_U: integer,
        buff_Y: *mut dcomplex,
        rs_Y: integer,
        cs_Y: integer,
        buff_Z: *mut dcomplex,
        rs_Z: integer,
        cs_Z: integer,
        buff_t: *mut dcomplex,
        inc_t: integer,
        buff_u: *mut dcomplex,
        inc_u: integer,
        buff_y: *mut dcomplex,
        inc_y: integer,
        buff_z: *mut dcomplex,
        inc_z: integer,
    ) -> FLA_Error;
    pub fn FLA_Hess_UT_internal(A: FLA_Obj, T: FLA_Obj, cntl: *mut fla_hessut_t) -> FLA_Error;
    pub fn FLA_Hess_UT_create_T(A: FLA_Obj, T: *mut FLA_Obj) -> FLA_Error;
    pub fn FLA_Hess_UT_recover_tau(T: FLA_Obj, t: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_blk_var1(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_unb_var1(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_step_unb_var1(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_blk_var2(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_blf_var2(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_unb_var2(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_step_unb_var2(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_blk_var3(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_blf_var3(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_unb_var3(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_step_unb_var3(A: FLA_Obj, Z: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_opt_var1(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_step_opt_var1(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_step_ops_var1(
        m_A: integer,
        m_T: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut f32,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_step_opd_var1(
        m_A: integer,
        m_T: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut f64,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_step_opc_var1(
        m_A: integer,
        m_T: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut scomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_step_opz_var1(
        m_A: integer,
        m_T: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut dcomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_opt_var2(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_step_opt_var2(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_step_ops_var2(
        m_A: integer,
        m_T: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut f32,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_step_opd_var2(
        m_A: integer,
        m_T: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut f64,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_step_opc_var2(
        m_A: integer,
        m_T: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut scomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_step_opz_var2(
        m_A: integer,
        m_T: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut dcomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_opt_var3(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_step_opt_var3(A: FLA_Obj, Z: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_step_ops_var3(
        m_A: integer,
        m_T: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_Z: *mut f32,
        rs_Z: integer,
        cs_Z: integer,
        buff_T: *mut f32,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_step_opd_var3(
        m_A: integer,
        m_T: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_Z: *mut f64,
        rs_Z: integer,
        cs_Z: integer,
        buff_T: *mut f64,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_step_opc_var3(
        m_A: integer,
        m_T: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_Z: *mut scomplex,
        rs_Z: integer,
        cs_Z: integer,
        buff_T: *mut scomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_step_opz_var3(
        m_A: integer,
        m_T: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_Z: *mut dcomplex,
        rs_Z: integer,
        cs_Z: integer,
        buff_T: *mut dcomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_ofu_var1(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_step_ofu_var1(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_step_ofs_var1(
        m_A: integer,
        m_T: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut f32,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_step_ofd_var1(
        m_A: integer,
        m_T: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut f64,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_step_ofc_var1(
        m_A: integer,
        m_T: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut scomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_step_ofz_var1(
        m_A: integer,
        m_T: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut dcomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_ofu_var2(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_step_ofu_var2(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_step_ofs_var2(
        m_A: integer,
        m_T: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut f32,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_step_ofd_var2(
        m_A: integer,
        m_T: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut f64,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_step_ofc_var2(
        m_A: integer,
        m_T: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut scomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_step_ofz_var2(
        m_A: integer,
        m_T: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut dcomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_ofu_var3(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_step_ofu_var3(A: FLA_Obj, Z: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_step_ofs_var3(
        m_A: integer,
        m_T: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_Z: *mut f32,
        rs_Z: integer,
        cs_Z: integer,
        buff_T: *mut f32,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_step_ofd_var3(
        m_A: integer,
        m_T: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_Z: *mut f64,
        rs_Z: integer,
        cs_Z: integer,
        buff_T: *mut f64,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_step_ofc_var3(
        m_A: integer,
        m_T: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_Z: *mut scomplex,
        rs_Z: integer,
        cs_Z: integer,
        buff_T: *mut scomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_step_ofz_var3(
        m_A: integer,
        m_T: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_Z: *mut dcomplex,
        rs_Z: integer,
        cs_Z: integer,
        buff_T: *mut dcomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Fused_Her2_Ax_l_opt_var1(
        alpha: FLA_Obj,
        u: FLA_Obj,
        z: FLA_Obj,
        A: FLA_Obj,
        x: FLA_Obj,
        w: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Fused_Her2_Ax_l_ops_var1(
        m_A: integer,
        buff_alpha: *mut f32,
        buff_u: *mut f32,
        inc_u: integer,
        buff_z: *mut f32,
        inc_z: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_x: *mut f32,
        inc_x: integer,
        buff_w: *mut f32,
        inc_w: integer,
    ) -> FLA_Error;
    pub fn FLA_Fused_Her2_Ax_l_opd_var1(
        m_A: integer,
        buff_alpha: *mut f64,
        buff_u: *mut f64,
        inc_u: integer,
        buff_z: *mut f64,
        inc_z: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_x: *mut f64,
        inc_x: integer,
        buff_w: *mut f64,
        inc_w: integer,
    ) -> FLA_Error;
    pub fn FLA_Fused_Her2_Ax_l_opc_var1(
        m_A: integer,
        buff_alpha: *mut scomplex,
        buff_u: *mut scomplex,
        inc_u: integer,
        buff_z: *mut scomplex,
        inc_z: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_x: *mut scomplex,
        inc_x: integer,
        buff_w: *mut scomplex,
        inc_w: integer,
    ) -> FLA_Error;
    pub fn FLA_Fused_Her2_Ax_l_opz_var1(
        m_A: integer,
        buff_alpha: *mut dcomplex,
        buff_u: *mut dcomplex,
        inc_u: integer,
        buff_z: *mut dcomplex,
        inc_z: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_x: *mut dcomplex,
        inc_x: integer,
        buff_w: *mut dcomplex,
        inc_w: integer,
    ) -> FLA_Error;
    pub fn FLA_Fused_UZhu_ZUhu_opt_var1(
        delta: FLA_Obj,
        U: FLA_Obj,
        Z: FLA_Obj,
        t: FLA_Obj,
        u: FLA_Obj,
        w: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Fused_UZhu_ZUhu_ops_var1(
        m_U: integer,
        n_U: integer,
        buff_delta: *mut f32,
        buff_U: *mut f32,
        rs_U: integer,
        cs_U: integer,
        buff_Z: *mut f32,
        rs_Z: integer,
        cs_Z: integer,
        buff_t: *mut f32,
        inc_t: integer,
        buff_u: *mut f32,
        inc_u: integer,
        buff_w: *mut f32,
        inc_w: integer,
    ) -> FLA_Error;
    pub fn FLA_Fused_UZhu_ZUhu_opd_var1(
        m_U: integer,
        n_U: integer,
        buff_delta: *mut f64,
        buff_U: *mut f64,
        rs_U: integer,
        cs_U: integer,
        buff_Z: *mut f64,
        rs_Z: integer,
        cs_Z: integer,
        buff_t: *mut f64,
        inc_t: integer,
        buff_u: *mut f64,
        inc_u: integer,
        buff_w: *mut f64,
        inc_w: integer,
    ) -> FLA_Error;
    pub fn FLA_Fused_UZhu_ZUhu_opc_var1(
        m_U: integer,
        n_U: integer,
        buff_delta: *mut scomplex,
        buff_U: *mut scomplex,
        rs_U: integer,
        cs_U: integer,
        buff_Z: *mut scomplex,
        rs_Z: integer,
        cs_Z: integer,
        buff_t: *mut scomplex,
        inc_t: integer,
        buff_u: *mut scomplex,
        inc_u: integer,
        buff_w: *mut scomplex,
        inc_w: integer,
    ) -> FLA_Error;
    pub fn FLA_Fused_UZhu_ZUhu_opz_var1(
        m_U: integer,
        n_U: integer,
        buff_delta: *mut dcomplex,
        buff_U: *mut dcomplex,
        rs_U: integer,
        cs_U: integer,
        buff_Z: *mut dcomplex,
        rs_Z: integer,
        cs_Z: integer,
        buff_t: *mut dcomplex,
        inc_t: integer,
        buff_u: *mut dcomplex,
        inc_u: integer,
        buff_w: *mut dcomplex,
        inc_w: integer,
    ) -> FLA_Error;
    pub fn FLA_Tridiag_UT(uplo: FLA_Uplo, A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_UT_internal(
        uplo: FLA_Uplo,
        A: FLA_Obj,
        T: FLA_Obj,
        cntl: *mut fla_tridiagut_t,
    ) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l(A: FLA_Obj, T: FLA_Obj, cntl: *mut fla_tridiagut_t) -> FLA_Error;
    pub fn FLA_Tridiag_UT_u(A: FLA_Obj, T: FLA_Obj, cntl: *mut fla_tridiagut_t) -> FLA_Error;
    pub fn FLA_Tridiag_UT_create_T(A: FLA_Obj, T: *mut FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_UT_recover_tau(T: FLA_Obj, t: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_UT_scale_diagonals(uplo: FLA_Uplo, alpha: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_UT_extract_diagonals(
        uplo: FLA_Uplo,
        A: FLA_Obj,
        d: FLA_Obj,
        e: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Tridiag_UT_extract_real_diagonals(
        uplo: FLA_Uplo,
        A: FLA_Obj,
        d: FLA_Obj,
        e: FLA_Obj,
    ) -> FLA_Error;
    #[doc = " FLA_Error FLA_Tridiag_UT_l_extract_diagonals( FLA_Obj A, FLA_Obj d, FLA_Obj e );\n FLA_Error FLA_Tridiag_UT_u_extract_diagonals( FLA_Obj A, FLA_Obj d, FLA_Obj e );"]
    pub fn FLA_Tridiag_UT_realify(uplo: FLA_Uplo, A: FLA_Obj, d: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_realify_unb(A: FLA_Obj, d: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_UT_l_realify_opt(A: FLA_Obj, d: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_UT_u_realify_unb(A: FLA_Obj, d: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_UT_u_realify_opt(A: FLA_Obj, d: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_UT_realify_subdiagonal(b: FLA_Obj, d: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_UT_realify_subdiagonal_opt(b: FLA_Obj, d: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_UT_shift_U(uplo: FLA_Uplo, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_UT_shift_U_l_ops(
        m_A: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Tridiag_UT_shift_U_u_ops(
        m_A: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Tridiag_UT_shift_U_l_opd(
        m_A: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Tridiag_UT_shift_U_u_opd(
        m_A: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Tridiag_UT_shift_U_l_opc(
        m_A: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Tridiag_UT_shift_U_u_opc(
        m_A: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Tridiag_UT_shift_U_l_opz(
        m_A: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Tridiag_UT_shift_U_u_opz(
        m_A: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Tridiag_UT_form_Q(uplo: FLA_Uplo, A: FLA_Obj, T: FLA_Obj, Q: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_UT_form_Q_l_blk_var1(A: FLA_Obj, T: FLA_Obj, W: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_UT_form_Q_u_blk_var1(A: FLA_Obj, T: FLA_Obj, W: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_UT_form_Q_l_opt_var1(A: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Tridiag_UT_form_Q_l_ops_var1(
        m_A: integer,
        n_AT: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut f32,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Tridiag_UT_form_Q_l_opd_var1(
        m_A: integer,
        n_AT: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut f64,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Tridiag_UT_form_Q_l_opc_var1(
        m_A: integer,
        n_AT: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut scomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Tridiag_UT_form_Q_l_opz_var1(
        m_A: integer,
        n_AT: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut dcomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_unb_var1(A: FLA_Obj, TU: FLA_Obj, TV: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_blk_var1(A: FLA_Obj, TU: FLA_Obj, TV: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_step_unb_var1(A: FLA_Obj, TU: FLA_Obj, TV: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_unb_var2(A: FLA_Obj, TU: FLA_Obj, TV: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_blk_var2(A: FLA_Obj, TU: FLA_Obj, TV: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_blf_var2(A: FLA_Obj, TU: FLA_Obj, TV: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_step_unb_var2(A: FLA_Obj, TU: FLA_Obj, TV: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_unb_var3(A: FLA_Obj, TU: FLA_Obj, TV: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_blk_var3(A: FLA_Obj, TU: FLA_Obj, TV: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_blf_var3(A: FLA_Obj, TU: FLA_Obj, TV: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_step_unb_var3(A: FLA_Obj, TU: FLA_Obj, TV: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_unb_var4(A: FLA_Obj, TU: FLA_Obj, TV: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_blk_var4(A: FLA_Obj, TU: FLA_Obj, TV: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_blf_var4(A: FLA_Obj, TU: FLA_Obj, TV: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_step_unb_var4(
        A: FLA_Obj,
        Y: FLA_Obj,
        Z: FLA_Obj,
        TU: FLA_Obj,
        TV: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_unb_var5(A: FLA_Obj, TU: FLA_Obj, TV: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_blk_var5(A: FLA_Obj, TU: FLA_Obj, TV: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_step_unb_var5(
        A: FLA_Obj,
        Y: FLA_Obj,
        Z: FLA_Obj,
        TU: FLA_Obj,
        TV: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_opt_var1(A: FLA_Obj, T: FLA_Obj, S: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_step_opt_var1(A: FLA_Obj, T: FLA_Obj, S: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_step_ops_var1(
        m_A: integer,
        n_A: integer,
        m_TS: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut f32,
        rs_T: integer,
        cs_T: integer,
        buff_S: *mut f32,
        rs_S: integer,
        cs_S: integer,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_step_opd_var1(
        m_A: integer,
        n_A: integer,
        m_TS: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut f64,
        rs_T: integer,
        cs_T: integer,
        buff_S: *mut f64,
        rs_S: integer,
        cs_S: integer,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_step_opc_var1(
        m_A: integer,
        n_A: integer,
        m_TS: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut scomplex,
        rs_T: integer,
        cs_T: integer,
        buff_S: *mut scomplex,
        rs_S: integer,
        cs_S: integer,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_step_opz_var1(
        m_A: integer,
        n_A: integer,
        m_TS: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut dcomplex,
        rs_T: integer,
        cs_T: integer,
        buff_S: *mut dcomplex,
        rs_S: integer,
        cs_S: integer,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_opt_var2(A: FLA_Obj, T: FLA_Obj, S: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_step_opt_var2(A: FLA_Obj, T: FLA_Obj, S: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_step_ops_var2(
        m_A: integer,
        n_A: integer,
        m_TS: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut f32,
        rs_T: integer,
        cs_T: integer,
        buff_S: *mut f32,
        rs_S: integer,
        cs_S: integer,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_step_opd_var2(
        m_A: integer,
        n_A: integer,
        m_TS: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut f64,
        rs_T: integer,
        cs_T: integer,
        buff_S: *mut f64,
        rs_S: integer,
        cs_S: integer,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_step_opc_var2(
        m_A: integer,
        n_A: integer,
        m_TS: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut scomplex,
        rs_T: integer,
        cs_T: integer,
        buff_S: *mut scomplex,
        rs_S: integer,
        cs_S: integer,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_step_opz_var2(
        m_A: integer,
        n_A: integer,
        m_TS: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut dcomplex,
        rs_T: integer,
        cs_T: integer,
        buff_S: *mut dcomplex,
        rs_S: integer,
        cs_S: integer,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_opt_var3(A: FLA_Obj, T: FLA_Obj, S: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_step_opt_var3(A: FLA_Obj, T: FLA_Obj, S: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_step_ops_var3(
        m_A: integer,
        n_A: integer,
        m_TS: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut f32,
        rs_T: integer,
        cs_T: integer,
        buff_S: *mut f32,
        rs_S: integer,
        cs_S: integer,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_step_opd_var3(
        m_A: integer,
        n_A: integer,
        m_TS: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut f64,
        rs_T: integer,
        cs_T: integer,
        buff_S: *mut f64,
        rs_S: integer,
        cs_S: integer,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_step_opc_var3(
        m_A: integer,
        n_A: integer,
        m_TS: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut scomplex,
        rs_T: integer,
        cs_T: integer,
        buff_S: *mut scomplex,
        rs_S: integer,
        cs_S: integer,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_step_opz_var3(
        m_A: integer,
        n_A: integer,
        m_TS: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut dcomplex,
        rs_T: integer,
        cs_T: integer,
        buff_S: *mut dcomplex,
        rs_S: integer,
        cs_S: integer,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_opt_var4(A: FLA_Obj, T: FLA_Obj, S: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_step_opt_var4(
        A: FLA_Obj,
        Y: FLA_Obj,
        Z: FLA_Obj,
        T: FLA_Obj,
        S: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_step_ops_var4(
        m_A: integer,
        n_A: integer,
        m_TS: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_Y: *mut f32,
        rs_Y: integer,
        cs_Y: integer,
        buff_Z: *mut f32,
        rs_Z: integer,
        cs_Z: integer,
        buff_T: *mut f32,
        rs_T: integer,
        cs_T: integer,
        buff_S: *mut f32,
        rs_S: integer,
        cs_S: integer,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_step_opd_var4(
        m_A: integer,
        n_A: integer,
        m_TS: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_Y: *mut f64,
        rs_Y: integer,
        cs_Y: integer,
        buff_Z: *mut f64,
        rs_Z: integer,
        cs_Z: integer,
        buff_T: *mut f64,
        rs_T: integer,
        cs_T: integer,
        buff_S: *mut f64,
        rs_S: integer,
        cs_S: integer,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_step_opc_var4(
        m_A: integer,
        n_A: integer,
        m_TS: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_Y: *mut scomplex,
        rs_Y: integer,
        cs_Y: integer,
        buff_Z: *mut scomplex,
        rs_Z: integer,
        cs_Z: integer,
        buff_T: *mut scomplex,
        rs_T: integer,
        cs_T: integer,
        buff_S: *mut scomplex,
        rs_S: integer,
        cs_S: integer,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_step_opz_var4(
        m_A: integer,
        n_A: integer,
        m_TS: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_Y: *mut dcomplex,
        rs_Y: integer,
        cs_Y: integer,
        buff_Z: *mut dcomplex,
        rs_Z: integer,
        cs_Z: integer,
        buff_T: *mut dcomplex,
        rs_T: integer,
        cs_T: integer,
        buff_S: *mut dcomplex,
        rs_S: integer,
        cs_S: integer,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_opt_var5(A: FLA_Obj, T: FLA_Obj, S: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_step_opt_var5(
        A: FLA_Obj,
        Y: FLA_Obj,
        Z: FLA_Obj,
        T: FLA_Obj,
        S: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_step_ops_var5(
        m_A: integer,
        n_A: integer,
        m_TS: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_Y: *mut f32,
        rs_Y: integer,
        cs_Y: integer,
        buff_Z: *mut f32,
        rs_Z: integer,
        cs_Z: integer,
        buff_T: *mut f32,
        rs_T: integer,
        cs_T: integer,
        buff_S: *mut f32,
        rs_S: integer,
        cs_S: integer,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_step_opd_var5(
        m_A: integer,
        n_A: integer,
        m_TS: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_Y: *mut f64,
        rs_Y: integer,
        cs_Y: integer,
        buff_Z: *mut f64,
        rs_Z: integer,
        cs_Z: integer,
        buff_T: *mut f64,
        rs_T: integer,
        cs_T: integer,
        buff_S: *mut f64,
        rs_S: integer,
        cs_S: integer,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_step_opc_var5(
        m_A: integer,
        n_A: integer,
        m_TS: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_Y: *mut scomplex,
        rs_Y: integer,
        cs_Y: integer,
        buff_Z: *mut scomplex,
        rs_Z: integer,
        cs_Z: integer,
        buff_T: *mut scomplex,
        rs_T: integer,
        cs_T: integer,
        buff_S: *mut scomplex,
        rs_S: integer,
        cs_S: integer,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_step_opz_var5(
        m_A: integer,
        n_A: integer,
        m_TS: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_Y: *mut dcomplex,
        rs_Y: integer,
        cs_Y: integer,
        buff_Z: *mut dcomplex,
        rs_Z: integer,
        cs_Z: integer,
        buff_T: *mut dcomplex,
        rs_T: integer,
        cs_T: integer,
        buff_S: *mut dcomplex,
        rs_S: integer,
        cs_S: integer,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_ofu_var2(A: FLA_Obj, T: FLA_Obj, S: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_step_ofu_var2(A: FLA_Obj, T: FLA_Obj, S: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_step_ofs_var2(
        m_A: integer,
        n_A: integer,
        m_TS: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut f32,
        rs_T: integer,
        cs_T: integer,
        buff_S: *mut f32,
        rs_S: integer,
        cs_S: integer,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_step_ofd_var2(
        m_A: integer,
        n_A: integer,
        m_TS: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut f64,
        rs_T: integer,
        cs_T: integer,
        buff_S: *mut f64,
        rs_S: integer,
        cs_S: integer,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_step_ofc_var2(
        m_A: integer,
        n_A: integer,
        m_TS: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut scomplex,
        rs_T: integer,
        cs_T: integer,
        buff_S: *mut scomplex,
        rs_S: integer,
        cs_S: integer,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_step_ofz_var2(
        m_A: integer,
        n_A: integer,
        m_TS: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut dcomplex,
        rs_T: integer,
        cs_T: integer,
        buff_S: *mut dcomplex,
        rs_S: integer,
        cs_S: integer,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_ofu_var3(A: FLA_Obj, T: FLA_Obj, S: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_step_ofu_var3(A: FLA_Obj, T: FLA_Obj, S: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_step_ofs_var3(
        m_A: integer,
        n_A: integer,
        m_TS: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut f32,
        rs_T: integer,
        cs_T: integer,
        buff_S: *mut f32,
        rs_S: integer,
        cs_S: integer,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_step_ofd_var3(
        m_A: integer,
        n_A: integer,
        m_TS: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut f64,
        rs_T: integer,
        cs_T: integer,
        buff_S: *mut f64,
        rs_S: integer,
        cs_S: integer,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_step_ofc_var3(
        m_A: integer,
        n_A: integer,
        m_TS: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut scomplex,
        rs_T: integer,
        cs_T: integer,
        buff_S: *mut scomplex,
        rs_S: integer,
        cs_S: integer,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_step_ofz_var3(
        m_A: integer,
        n_A: integer,
        m_TS: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_T: *mut dcomplex,
        rs_T: integer,
        cs_T: integer,
        buff_S: *mut dcomplex,
        rs_S: integer,
        cs_S: integer,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_ofu_var4(A: FLA_Obj, T: FLA_Obj, S: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_step_ofu_var4(
        A: FLA_Obj,
        Y: FLA_Obj,
        Z: FLA_Obj,
        T: FLA_Obj,
        S: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_step_ofs_var4(
        m_A: integer,
        n_A: integer,
        m_TS: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_Y: *mut f32,
        rs_Y: integer,
        cs_Y: integer,
        buff_Z: *mut f32,
        rs_Z: integer,
        cs_Z: integer,
        buff_T: *mut f32,
        rs_T: integer,
        cs_T: integer,
        buff_S: *mut f32,
        rs_S: integer,
        cs_S: integer,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_step_ofd_var4(
        m_A: integer,
        n_A: integer,
        m_TS: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_Y: *mut f64,
        rs_Y: integer,
        cs_Y: integer,
        buff_Z: *mut f64,
        rs_Z: integer,
        cs_Z: integer,
        buff_T: *mut f64,
        rs_T: integer,
        cs_T: integer,
        buff_S: *mut f64,
        rs_S: integer,
        cs_S: integer,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_step_ofc_var4(
        m_A: integer,
        n_A: integer,
        m_TS: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_Y: *mut scomplex,
        rs_Y: integer,
        cs_Y: integer,
        buff_Z: *mut scomplex,
        rs_Z: integer,
        cs_Z: integer,
        buff_T: *mut scomplex,
        rs_T: integer,
        cs_T: integer,
        buff_S: *mut scomplex,
        rs_S: integer,
        cs_S: integer,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_step_ofz_var4(
        m_A: integer,
        n_A: integer,
        m_TS: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_Y: *mut dcomplex,
        rs_Y: integer,
        cs_Y: integer,
        buff_Z: *mut dcomplex,
        rs_Z: integer,
        cs_Z: integer,
        buff_T: *mut dcomplex,
        rs_T: integer,
        cs_T: integer,
        buff_S: *mut dcomplex,
        rs_S: integer,
        cs_S: integer,
    ) -> FLA_Error;
    pub fn FLA_Fused_Gerc2_opt_var1(
        alpha: FLA_Obj,
        u: FLA_Obj,
        y: FLA_Obj,
        z: FLA_Obj,
        v: FLA_Obj,
        A: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Fused_Gerc2_ops_var1(
        m_A: integer,
        n_A: integer,
        buff_alpha: *mut f32,
        buff_u: *mut f32,
        inc_u: integer,
        buff_y: *mut f32,
        inc_y: integer,
        buff_z: *mut f32,
        inc_z: integer,
        buff_v: *mut f32,
        inc_v: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Fused_Gerc2_opd_var1(
        m_A: integer,
        n_A: integer,
        buff_alpha: *mut f64,
        buff_u: *mut f64,
        inc_u: integer,
        buff_y: *mut f64,
        inc_y: integer,
        buff_z: *mut f64,
        inc_z: integer,
        buff_v: *mut f64,
        inc_v: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Fused_Gerc2_opc_var1(
        m_A: integer,
        n_A: integer,
        buff_alpha: *mut scomplex,
        buff_u: *mut scomplex,
        inc_u: integer,
        buff_y: *mut scomplex,
        inc_y: integer,
        buff_z: *mut scomplex,
        inc_z: integer,
        buff_v: *mut scomplex,
        inc_v: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Fused_Gerc2_opz_var1(
        m_A: integer,
        n_A: integer,
        buff_alpha: *mut dcomplex,
        buff_u: *mut dcomplex,
        inc_u: integer,
        buff_y: *mut dcomplex,
        inc_y: integer,
        buff_z: *mut dcomplex,
        inc_z: integer,
        buff_v: *mut dcomplex,
        inc_v: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Fused_Ahx_Axpy_Ax_opt_var1(
        A: FLA_Obj,
        u: FLA_Obj,
        tau: FLA_Obj,
        a: FLA_Obj,
        beta: FLA_Obj,
        y: FLA_Obj,
        w: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Fused_Ahx_Axpy_Ax_ops_var1(
        m_A: integer,
        n_A: integer,
        buff_tau: *mut f32,
        buff_beta: *mut f32,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_u: *mut f32,
        inc_u: integer,
        buff_a: *mut f32,
        inc_a: integer,
        buff_y: *mut f32,
        inc_y: integer,
        buff_w: *mut f32,
        inc_w: integer,
    ) -> FLA_Error;
    pub fn FLA_Fused_Ahx_Axpy_Ax_opd_var1(
        m_A: integer,
        n_A: integer,
        buff_tau: *mut f64,
        buff_beta: *mut f64,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_u: *mut f64,
        inc_u: integer,
        buff_a: *mut f64,
        inc_a: integer,
        buff_y: *mut f64,
        inc_y: integer,
        buff_w: *mut f64,
        inc_w: integer,
    ) -> FLA_Error;
    pub fn FLA_Fused_Ahx_Axpy_Ax_opc_var1(
        m_A: integer,
        n_A: integer,
        buff_tau: *mut scomplex,
        buff_beta: *mut scomplex,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_u: *mut scomplex,
        inc_u: integer,
        buff_a: *mut scomplex,
        inc_a: integer,
        buff_y: *mut scomplex,
        inc_y: integer,
        buff_w: *mut scomplex,
        inc_w: integer,
    ) -> FLA_Error;
    pub fn FLA_Fused_Ahx_Axpy_Ax_opz_var1(
        m_A: integer,
        n_A: integer,
        buff_tau: *mut dcomplex,
        buff_beta: *mut dcomplex,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_u: *mut dcomplex,
        inc_u: integer,
        buff_a: *mut dcomplex,
        inc_a: integer,
        buff_y: *mut dcomplex,
        inc_y: integer,
        buff_w: *mut dcomplex,
        inc_w: integer,
    ) -> FLA_Error;
    pub fn FLA_Fused_Gerc2_Ahx_Axpy_Ax_opt_var1(
        alpha: FLA_Obj,
        tau: FLA_Obj,
        u: FLA_Obj,
        y: FLA_Obj,
        z: FLA_Obj,
        v: FLA_Obj,
        A: FLA_Obj,
        up: FLA_Obj,
        a: FLA_Obj,
        w: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Fused_Gerc2_Ahx_Axpy_Ax_ops_var1(
        m_A: integer,
        n_A: integer,
        buff_tau: *mut f32,
        buff_alpha: *mut f32,
        buff_u: *mut f32,
        inc_u: integer,
        buff_y: *mut f32,
        inc_y: integer,
        buff_z: *mut f32,
        inc_z: integer,
        buff_v: *mut f32,
        inc_v: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_up: *mut f32,
        inc_up: integer,
        buff_a: *mut f32,
        inc_a: integer,
        buff_w: *mut f32,
        inc_w: integer,
    ) -> FLA_Error;
    pub fn FLA_Fused_Gerc2_Ahx_Axpy_Ax_opd_var1(
        m_A: integer,
        n_A: integer,
        buff_tau: *mut f64,
        buff_alpha: *mut f64,
        buff_u: *mut f64,
        inc_u: integer,
        buff_y: *mut f64,
        inc_y: integer,
        buff_z: *mut f64,
        inc_z: integer,
        buff_v: *mut f64,
        inc_v: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_up: *mut f64,
        inc_up: integer,
        buff_a: *mut f64,
        inc_a: integer,
        buff_w: *mut f64,
        inc_w: integer,
    ) -> FLA_Error;
    pub fn FLA_Fused_Gerc2_Ahx_Axpy_Ax_opc_var1(
        m_A: integer,
        n_A: integer,
        buff_tau: *mut scomplex,
        buff_alpha: *mut scomplex,
        buff_u: *mut scomplex,
        inc_u: integer,
        buff_y: *mut scomplex,
        inc_y: integer,
        buff_z: *mut scomplex,
        inc_z: integer,
        buff_v: *mut scomplex,
        inc_v: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_up: *mut scomplex,
        inc_up: integer,
        buff_a: *mut scomplex,
        inc_a: integer,
        buff_w: *mut scomplex,
        inc_w: integer,
    ) -> FLA_Error;
    pub fn FLA_Fused_Gerc2_Ahx_Axpy_Ax_opz_var1(
        m_A: integer,
        n_A: integer,
        buff_tau: *mut dcomplex,
        buff_alpha: *mut dcomplex,
        buff_u: *mut dcomplex,
        inc_u: integer,
        buff_y: *mut dcomplex,
        inc_y: integer,
        buff_z: *mut dcomplex,
        inc_z: integer,
        buff_v: *mut dcomplex,
        inc_v: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_up: *mut dcomplex,
        inc_up: integer,
        buff_a: *mut dcomplex,
        inc_a: integer,
        buff_w: *mut dcomplex,
        inc_w: integer,
    ) -> FLA_Error;
    pub fn FLA_Fused_UYx_ZVx_opt_var1(
        delta: FLA_Obj,
        a: FLA_Obj,
        U: FLA_Obj,
        Y: FLA_Obj,
        Z: FLA_Obj,
        V: FLA_Obj,
        A: FLA_Obj,
        temp: FLA_Obj,
        t: FLA_Obj,
        w: FLA_Obj,
        al: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Fused_UYx_ZVx_ops_var1(
        m_U: integer,
        n_U: integer,
        m_V: integer,
        n_V: integer,
        buff_delta: *mut f32,
        buff_U: *mut f32,
        rs_U: integer,
        cs_U: integer,
        buff_Y: *mut f32,
        rs_Y: integer,
        cs_Y: integer,
        buff_Z: *mut f32,
        rs_Z: integer,
        cs_Z: integer,
        buff_V: *mut f32,
        rs_V: integer,
        cs_V: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_temp: *mut f32,
        inc_temp: integer,
        buff_t: *mut f32,
        inc_t: integer,
        buff_a: *mut f32,
        inc_a: integer,
        buff_w: *mut f32,
        inc_w: integer,
        buff_al: *mut f32,
        inc_al: integer,
    ) -> FLA_Error;
    pub fn FLA_Fused_UYx_ZVx_opd_var1(
        m_U: integer,
        n_U: integer,
        m_V: integer,
        n_V: integer,
        buff_delta: *mut f64,
        buff_U: *mut f64,
        rs_U: integer,
        cs_U: integer,
        buff_Y: *mut f64,
        rs_Y: integer,
        cs_Y: integer,
        buff_Z: *mut f64,
        rs_Z: integer,
        cs_Z: integer,
        buff_V: *mut f64,
        rs_V: integer,
        cs_V: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_temp: *mut f64,
        inc_temp: integer,
        buff_t: *mut f64,
        inc_t: integer,
        buff_a: *mut f64,
        inc_a: integer,
        buff_w: *mut f64,
        inc_w: integer,
        buff_al: *mut f64,
        inc_al: integer,
    ) -> FLA_Error;
    pub fn FLA_Fused_UYx_ZVx_opc_var1(
        m_U: integer,
        n_U: integer,
        m_V: integer,
        n_V: integer,
        buff_delta: *mut scomplex,
        buff_U: *mut scomplex,
        rs_U: integer,
        cs_U: integer,
        buff_Y: *mut scomplex,
        rs_Y: integer,
        cs_Y: integer,
        buff_Z: *mut scomplex,
        rs_Z: integer,
        cs_Z: integer,
        buff_V: *mut scomplex,
        rs_V: integer,
        cs_V: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_temp: *mut scomplex,
        inc_temp: integer,
        buff_t: *mut scomplex,
        inc_t: integer,
        buff_a: *mut scomplex,
        inc_a: integer,
        buff_w: *mut scomplex,
        inc_w: integer,
        buff_al: *mut scomplex,
        inc_al: integer,
    ) -> FLA_Error;
    pub fn FLA_Fused_UYx_ZVx_opz_var1(
        m_U: integer,
        n_U: integer,
        m_V: integer,
        n_V: integer,
        buff_delta: *mut dcomplex,
        buff_U: *mut dcomplex,
        rs_U: integer,
        cs_U: integer,
        buff_Y: *mut dcomplex,
        rs_Y: integer,
        cs_Y: integer,
        buff_Z: *mut dcomplex,
        rs_Z: integer,
        cs_Z: integer,
        buff_V: *mut dcomplex,
        rs_V: integer,
        cs_V: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_temp: *mut dcomplex,
        inc_temp: integer,
        buff_t: *mut dcomplex,
        inc_t: integer,
        buff_a: *mut dcomplex,
        inc_a: integer,
        buff_w: *mut dcomplex,
        inc_w: integer,
        buff_al: *mut dcomplex,
        inc_al: integer,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT(A: FLA_Obj, TU: FLA_Obj, TV: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_internal(
        A: FLA_Obj,
        TU: FLA_Obj,
        TV: FLA_Obj,
        cntl: *mut fla_bidiagut_t,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_l(
        A: FLA_Obj,
        TU: FLA_Obj,
        TV: FLA_Obj,
        cntl: *mut fla_bidiagut_t,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u(
        A: FLA_Obj,
        TU: FLA_Obj,
        TV: FLA_Obj,
        cntl: *mut fla_bidiagut_t,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_create_T(A: FLA_Obj, TU: *mut FLA_Obj, TV: *mut FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_recover_tau(
        TU: FLA_Obj,
        TV: FLA_Obj,
        tu: FLA_Obj,
        tv: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_extract_diagonals(A: FLA_Obj, d: FLA_Obj, e: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_extract_diagonals(A: FLA_Obj, d: FLA_Obj, e: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_l_extract_diagonals(A: FLA_Obj, d: FLA_Obj, e: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_extract_real_diagonals(A: FLA_Obj, d: FLA_Obj, e: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_extract_real_diagonals(A: FLA_Obj, d: FLA_Obj, e: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_l_extract_real_diagonals(A: FLA_Obj, d: FLA_Obj, e: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_scale_diagonals(alpha: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_scale_diagonals(alpha: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_l_scale_diagonals(alpha: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_realify(A: FLA_Obj, d: FLA_Obj, e: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_l_realify_unb(A: FLA_Obj, d: FLA_Obj, e: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_l_realify_opt(A: FLA_Obj, d: FLA_Obj, e: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_realify_unb(A: FLA_Obj, d: FLA_Obj, e: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_u_realify_opt(A: FLA_Obj, d: FLA_Obj, e: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_realify_diagonals(
        uplo: FLA_Uplo,
        a: FLA_Obj,
        b: FLA_Obj,
        d: FLA_Obj,
        e: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_realify_diagonals_opt(
        a: FLA_Obj,
        b: FLA_Obj,
        d: FLA_Obj,
        e: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_form_U(A: FLA_Obj, T: FLA_Obj, U: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_form_V(A: FLA_Obj, S: FLA_Obj, V: FLA_Obj) -> FLA_Error;
    pub fn FLA_Bidiag_UT_form_U_ext(
        uplo: FLA_Uplo,
        A: FLA_Obj,
        T: FLA_Obj,
        transu: FLA_Trans,
        U: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Bidiag_UT_form_V_ext(
        uplo: FLA_Uplo,
        A: FLA_Obj,
        S: FLA_Obj,
        transv: FLA_Trans,
        V: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Lyap_n_unb_var1(isgn: FLA_Obj, A: FLA_Obj, C: FLA_Obj) -> FLA_Error;
    pub fn FLA_Lyap_n_unb_var2(isgn: FLA_Obj, A: FLA_Obj, C: FLA_Obj) -> FLA_Error;
    pub fn FLA_Lyap_n_unb_var3(isgn: FLA_Obj, A: FLA_Obj, C: FLA_Obj) -> FLA_Error;
    pub fn FLA_Lyap_n_unb_var4(isgn: FLA_Obj, A: FLA_Obj, C: FLA_Obj) -> FLA_Error;
    pub fn FLA_Lyap_n_blk_var1(
        isgn: FLA_Obj,
        A: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_lyap_t,
    ) -> FLA_Error;
    pub fn FLA_Lyap_n_blk_var2(
        isgn: FLA_Obj,
        A: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_lyap_t,
    ) -> FLA_Error;
    pub fn FLA_Lyap_n_blk_var3(
        isgn: FLA_Obj,
        A: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_lyap_t,
    ) -> FLA_Error;
    pub fn FLA_Lyap_n_blk_var4(
        isgn: FLA_Obj,
        A: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_lyap_t,
    ) -> FLA_Error;
    pub fn FLA_Lyap_n_opt_var1(isgn: FLA_Obj, A: FLA_Obj, C: FLA_Obj) -> FLA_Error;
    pub fn FLA_Lyap_n_ops_var1(
        m_AC: integer,
        buff_sgn: *mut f32,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_W: *mut f32,
        rs_W: integer,
        cs_W: integer,
        buff_C: *mut f32,
        rs_C: integer,
        cs_C: integer,
    ) -> FLA_Error;
    pub fn FLA_Lyap_n_opd_var1(
        m_AC: integer,
        buff_sgn: *mut f64,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_W: *mut f64,
        rs_W: integer,
        cs_W: integer,
        buff_C: *mut f64,
        rs_C: integer,
        cs_C: integer,
    ) -> FLA_Error;
    pub fn FLA_Lyap_n_opc_var1(
        m_AC: integer,
        buff_sgn: *mut scomplex,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_W: *mut scomplex,
        rs_W: integer,
        cs_W: integer,
        buff_C: *mut scomplex,
        rs_C: integer,
        cs_C: integer,
    ) -> FLA_Error;
    pub fn FLA_Lyap_n_opz_var1(
        m_AC: integer,
        buff_sgn: *mut dcomplex,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_W: *mut dcomplex,
        rs_W: integer,
        cs_W: integer,
        buff_C: *mut dcomplex,
        rs_C: integer,
        cs_C: integer,
    ) -> FLA_Error;
    pub fn FLA_Lyap_n_opt_var2(isgn: FLA_Obj, A: FLA_Obj, C: FLA_Obj) -> FLA_Error;
    pub fn FLA_Lyap_n_ops_var2(
        m_AC: integer,
        buff_sgn: *mut f32,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_W: *mut f32,
        rs_W: integer,
        cs_W: integer,
        buff_C: *mut f32,
        rs_C: integer,
        cs_C: integer,
    ) -> FLA_Error;
    pub fn FLA_Lyap_n_opd_var2(
        m_AC: integer,
        buff_sgn: *mut f64,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_W: *mut f64,
        rs_W: integer,
        cs_W: integer,
        buff_C: *mut f64,
        rs_C: integer,
        cs_C: integer,
    ) -> FLA_Error;
    pub fn FLA_Lyap_n_opc_var2(
        m_AC: integer,
        buff_sgn: *mut scomplex,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_W: *mut scomplex,
        rs_W: integer,
        cs_W: integer,
        buff_C: *mut scomplex,
        rs_C: integer,
        cs_C: integer,
    ) -> FLA_Error;
    pub fn FLA_Lyap_n_opz_var2(
        m_AC: integer,
        buff_sgn: *mut dcomplex,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_W: *mut dcomplex,
        rs_W: integer,
        cs_W: integer,
        buff_C: *mut dcomplex,
        rs_C: integer,
        cs_C: integer,
    ) -> FLA_Error;
    pub fn FLA_Lyap_n_opt_var3(isgn: FLA_Obj, A: FLA_Obj, C: FLA_Obj) -> FLA_Error;
    pub fn FLA_Lyap_n_ops_var3(
        m_AC: integer,
        buff_sgn: *mut f32,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_W: *mut f32,
        rs_W: integer,
        cs_W: integer,
        buff_C: *mut f32,
        rs_C: integer,
        cs_C: integer,
    ) -> FLA_Error;
    pub fn FLA_Lyap_n_opd_var3(
        m_AC: integer,
        buff_sgn: *mut f64,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_W: *mut f64,
        rs_W: integer,
        cs_W: integer,
        buff_C: *mut f64,
        rs_C: integer,
        cs_C: integer,
    ) -> FLA_Error;
    pub fn FLA_Lyap_n_opc_var3(
        m_AC: integer,
        buff_sgn: *mut scomplex,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_W: *mut scomplex,
        rs_W: integer,
        cs_W: integer,
        buff_C: *mut scomplex,
        rs_C: integer,
        cs_C: integer,
    ) -> FLA_Error;
    pub fn FLA_Lyap_n_opz_var3(
        m_AC: integer,
        buff_sgn: *mut dcomplex,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_W: *mut dcomplex,
        rs_W: integer,
        cs_W: integer,
        buff_C: *mut dcomplex,
        rs_C: integer,
        cs_C: integer,
    ) -> FLA_Error;
    pub fn FLA_Lyap_n_opt_var4(isgn: FLA_Obj, A: FLA_Obj, C: FLA_Obj) -> FLA_Error;
    pub fn FLA_Lyap_n_ops_var4(
        m_AC: integer,
        buff_sgn: *mut f32,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_W: *mut f32,
        rs_W: integer,
        cs_W: integer,
        buff_C: *mut f32,
        rs_C: integer,
        cs_C: integer,
    ) -> FLA_Error;
    pub fn FLA_Lyap_n_opd_var4(
        m_AC: integer,
        buff_sgn: *mut f64,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_W: *mut f64,
        rs_W: integer,
        cs_W: integer,
        buff_C: *mut f64,
        rs_C: integer,
        cs_C: integer,
    ) -> FLA_Error;
    pub fn FLA_Lyap_n_opc_var4(
        m_AC: integer,
        buff_sgn: *mut scomplex,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_W: *mut scomplex,
        rs_W: integer,
        cs_W: integer,
        buff_C: *mut scomplex,
        rs_C: integer,
        cs_C: integer,
    ) -> FLA_Error;
    pub fn FLA_Lyap_n_opz_var4(
        m_AC: integer,
        buff_sgn: *mut dcomplex,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_W: *mut dcomplex,
        rs_W: integer,
        cs_W: integer,
        buff_C: *mut dcomplex,
        rs_C: integer,
        cs_C: integer,
    ) -> FLA_Error;
    pub fn FLA_Lyap_h_unb_var1(isgn: FLA_Obj, A: FLA_Obj, C: FLA_Obj) -> FLA_Error;
    pub fn FLA_Lyap_h_unb_var2(isgn: FLA_Obj, A: FLA_Obj, C: FLA_Obj) -> FLA_Error;
    pub fn FLA_Lyap_h_unb_var3(isgn: FLA_Obj, A: FLA_Obj, C: FLA_Obj) -> FLA_Error;
    pub fn FLA_Lyap_h_unb_var4(isgn: FLA_Obj, A: FLA_Obj, C: FLA_Obj) -> FLA_Error;
    pub fn FLA_Lyap_h_blk_var1(
        isgn: FLA_Obj,
        A: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_lyap_t,
    ) -> FLA_Error;
    pub fn FLA_Lyap_h_blk_var2(
        isgn: FLA_Obj,
        A: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_lyap_t,
    ) -> FLA_Error;
    pub fn FLA_Lyap_h_blk_var3(
        isgn: FLA_Obj,
        A: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_lyap_t,
    ) -> FLA_Error;
    pub fn FLA_Lyap_h_blk_var4(
        isgn: FLA_Obj,
        A: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_lyap_t,
    ) -> FLA_Error;
    pub fn FLA_Lyap_h_opt_var1(isgn: FLA_Obj, A: FLA_Obj, C: FLA_Obj) -> FLA_Error;
    pub fn FLA_Lyap_h_ops_var1(
        m_AC: integer,
        buff_sgn: *mut f32,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_W: *mut f32,
        rs_W: integer,
        cs_W: integer,
        buff_C: *mut f32,
        rs_C: integer,
        cs_C: integer,
    ) -> FLA_Error;
    pub fn FLA_Lyap_h_opd_var1(
        m_AC: integer,
        buff_sgn: *mut f64,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_W: *mut f64,
        rs_W: integer,
        cs_W: integer,
        buff_C: *mut f64,
        rs_C: integer,
        cs_C: integer,
    ) -> FLA_Error;
    pub fn FLA_Lyap_h_opc_var1(
        m_AC: integer,
        buff_sgn: *mut scomplex,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_W: *mut scomplex,
        rs_W: integer,
        cs_W: integer,
        buff_C: *mut scomplex,
        rs_C: integer,
        cs_C: integer,
    ) -> FLA_Error;
    pub fn FLA_Lyap_h_opz_var1(
        m_AC: integer,
        buff_sgn: *mut dcomplex,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_W: *mut dcomplex,
        rs_W: integer,
        cs_W: integer,
        buff_C: *mut dcomplex,
        rs_C: integer,
        cs_C: integer,
    ) -> FLA_Error;
    pub fn FLA_Lyap_h_opt_var2(isgn: FLA_Obj, A: FLA_Obj, C: FLA_Obj) -> FLA_Error;
    pub fn FLA_Lyap_h_ops_var2(
        m_AC: integer,
        buff_sgn: *mut f32,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_W: *mut f32,
        rs_W: integer,
        cs_W: integer,
        buff_C: *mut f32,
        rs_C: integer,
        cs_C: integer,
    ) -> FLA_Error;
    pub fn FLA_Lyap_h_opd_var2(
        m_AC: integer,
        buff_sgn: *mut f64,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_W: *mut f64,
        rs_W: integer,
        cs_W: integer,
        buff_C: *mut f64,
        rs_C: integer,
        cs_C: integer,
    ) -> FLA_Error;
    pub fn FLA_Lyap_h_opc_var2(
        m_AC: integer,
        buff_sgn: *mut scomplex,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_W: *mut scomplex,
        rs_W: integer,
        cs_W: integer,
        buff_C: *mut scomplex,
        rs_C: integer,
        cs_C: integer,
    ) -> FLA_Error;
    pub fn FLA_Lyap_h_opz_var2(
        m_AC: integer,
        buff_sgn: *mut dcomplex,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_W: *mut dcomplex,
        rs_W: integer,
        cs_W: integer,
        buff_C: *mut dcomplex,
        rs_C: integer,
        cs_C: integer,
    ) -> FLA_Error;
    pub fn FLA_Lyap_h_opt_var3(isgn: FLA_Obj, A: FLA_Obj, C: FLA_Obj) -> FLA_Error;
    pub fn FLA_Lyap_h_ops_var3(
        m_AC: integer,
        buff_sgn: *mut f32,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_W: *mut f32,
        rs_W: integer,
        cs_W: integer,
        buff_C: *mut f32,
        rs_C: integer,
        cs_C: integer,
    ) -> FLA_Error;
    pub fn FLA_Lyap_h_opd_var3(
        m_AC: integer,
        buff_sgn: *mut f64,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_W: *mut f64,
        rs_W: integer,
        cs_W: integer,
        buff_C: *mut f64,
        rs_C: integer,
        cs_C: integer,
    ) -> FLA_Error;
    pub fn FLA_Lyap_h_opc_var3(
        m_AC: integer,
        buff_sgn: *mut scomplex,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_W: *mut scomplex,
        rs_W: integer,
        cs_W: integer,
        buff_C: *mut scomplex,
        rs_C: integer,
        cs_C: integer,
    ) -> FLA_Error;
    pub fn FLA_Lyap_h_opz_var3(
        m_AC: integer,
        buff_sgn: *mut dcomplex,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_W: *mut dcomplex,
        rs_W: integer,
        cs_W: integer,
        buff_C: *mut dcomplex,
        rs_C: integer,
        cs_C: integer,
    ) -> FLA_Error;
    pub fn FLA_Lyap_h_opt_var4(isgn: FLA_Obj, A: FLA_Obj, C: FLA_Obj) -> FLA_Error;
    pub fn FLA_Lyap_h_ops_var4(
        m_AC: integer,
        buff_sgn: *mut f32,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_W: *mut f32,
        rs_W: integer,
        cs_W: integer,
        buff_C: *mut f32,
        rs_C: integer,
        cs_C: integer,
    ) -> FLA_Error;
    pub fn FLA_Lyap_h_opd_var4(
        m_AC: integer,
        buff_sgn: *mut f64,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_W: *mut f64,
        rs_W: integer,
        cs_W: integer,
        buff_C: *mut f64,
        rs_C: integer,
        cs_C: integer,
    ) -> FLA_Error;
    pub fn FLA_Lyap_h_opc_var4(
        m_AC: integer,
        buff_sgn: *mut scomplex,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_W: *mut scomplex,
        rs_W: integer,
        cs_W: integer,
        buff_C: *mut scomplex,
        rs_C: integer,
        cs_C: integer,
    ) -> FLA_Error;
    pub fn FLA_Lyap_h_opz_var4(
        m_AC: integer,
        buff_sgn: *mut dcomplex,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_W: *mut dcomplex,
        rs_W: integer,
        cs_W: integer,
        buff_C: *mut dcomplex,
        rs_C: integer,
        cs_C: integer,
    ) -> FLA_Error;
    pub fn FLASH_Lyap(
        trans: FLA_Trans,
        isgn: FLA_Obj,
        A: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Lyap(
        trans: FLA_Trans,
        isgn: FLA_Obj,
        A: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Lyap_internal(
        trans: FLA_Trans,
        isgn: FLA_Obj,
        A: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_lyap_t,
    ) -> FLA_Error;
    pub fn FLA_Lyap_n(
        isgn: FLA_Obj,
        A: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_lyap_t,
    ) -> FLA_Error;
    pub fn FLA_Lyap_h(
        isgn: FLA_Obj,
        A: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_lyap_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nn_blk_var1(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nn_blk_var2(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nn_blk_var3(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nn_blk_var4(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nn_blk_var5(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nn_blk_var6(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nn_blk_var7(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nn_blk_var8(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nn_blk_var9(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nn_blk_var10(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nn_blk_var11(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nn_blk_var12(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nn_blk_var13(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nn_blk_var14(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nn_blk_var15(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nn_blk_var16(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nn_blk_var17(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nn_blk_var18(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nn_opt_var1(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nn_opt_var2(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nn_opt_var3(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nn_opt_var4(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nn_opt_var5(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nn_opt_var6(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nn_opt_var7(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nn_opt_var8(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nn_opt_var9(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nn_opt_var10(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nn_opt_var11(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nn_opt_var12(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nn_opt_var13(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nn_opt_var14(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nn_opt_var15(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nn_opt_var16(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nn_opt_var17(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nn_opt_var18(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nn_ops_var1(
        sgn: f32,
        m_C: integer,
        n_C: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_B: *mut f32,
        rs_B: integer,
        cs_B: integer,
        buff_C: *mut f32,
        rs_C: integer,
        cs_C: integer,
        buff_scale: *mut f32,
        info: *mut integer,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nn_opd_var1(
        sgn: f64,
        m_C: integer,
        n_C: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_B: *mut f64,
        rs_B: integer,
        cs_B: integer,
        buff_C: *mut f64,
        rs_C: integer,
        cs_C: integer,
        buff_scale: *mut f64,
        info: *mut integer,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nn_opc_var1(
        sgn: f32,
        m_C: integer,
        n_C: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_B: *mut scomplex,
        rs_B: integer,
        cs_B: integer,
        buff_C: *mut scomplex,
        rs_C: integer,
        cs_C: integer,
        buff_scale: *mut scomplex,
        info: *mut integer,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nn_opz_var1(
        sgn: f64,
        m_C: integer,
        n_C: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_B: *mut dcomplex,
        rs_B: integer,
        cs_B: integer,
        buff_C: *mut dcomplex,
        rs_C: integer,
        cs_C: integer,
        buff_scale: *mut dcomplex,
        info: *mut integer,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nh_blk_var1(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nh_blk_var2(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nh_blk_var3(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nh_blk_var4(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nh_blk_var5(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nh_blk_var6(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nh_blk_var7(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nh_blk_var8(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nh_blk_var9(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nh_blk_var10(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nh_blk_var11(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nh_blk_var12(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nh_blk_var13(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nh_blk_var14(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nh_blk_var15(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nh_blk_var16(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nh_blk_var17(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nh_blk_var18(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nh_opt_var1(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nh_opt_var2(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nh_opt_var3(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nh_opt_var4(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nh_opt_var5(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nh_opt_var6(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nh_opt_var7(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nh_opt_var8(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nh_opt_var9(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nh_opt_var10(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nh_opt_var11(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nh_opt_var12(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nh_opt_var13(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nh_opt_var14(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nh_opt_var15(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nh_opt_var16(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nh_opt_var17(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nh_opt_var18(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nh_ops_var1(
        sgn: f32,
        m_C: integer,
        n_C: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_B: *mut f32,
        rs_B: integer,
        cs_B: integer,
        buff_C: *mut f32,
        rs_C: integer,
        cs_C: integer,
        buff_scale: *mut f32,
        info: *mut integer,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nh_opd_var1(
        sgn: f64,
        m_C: integer,
        n_C: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_B: *mut f64,
        rs_B: integer,
        cs_B: integer,
        buff_C: *mut f64,
        rs_C: integer,
        cs_C: integer,
        buff_scale: *mut f64,
        info: *mut integer,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nh_opc_var1(
        sgn: f32,
        m_C: integer,
        n_C: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_B: *mut scomplex,
        rs_B: integer,
        cs_B: integer,
        buff_C: *mut scomplex,
        rs_C: integer,
        cs_C: integer,
        buff_scale: *mut scomplex,
        info: *mut integer,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nh_opz_var1(
        sgn: f64,
        m_C: integer,
        n_C: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_B: *mut dcomplex,
        rs_B: integer,
        cs_B: integer,
        buff_C: *mut dcomplex,
        rs_C: integer,
        cs_C: integer,
        buff_scale: *mut dcomplex,
        info: *mut integer,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hn_blk_var1(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hn_blk_var2(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hn_blk_var3(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hn_blk_var4(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hn_blk_var5(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hn_blk_var6(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hn_blk_var7(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hn_blk_var8(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hn_blk_var9(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hn_blk_var10(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hn_blk_var11(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hn_blk_var12(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hn_blk_var13(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hn_blk_var14(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hn_blk_var15(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hn_blk_var16(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hn_blk_var17(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hn_blk_var18(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hn_opt_var1(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hn_opt_var2(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hn_opt_var3(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hn_opt_var4(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hn_opt_var5(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hn_opt_var6(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hn_opt_var7(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hn_opt_var8(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hn_opt_var9(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hn_opt_var10(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hn_opt_var11(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hn_opt_var12(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hn_opt_var13(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hn_opt_var14(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hn_opt_var15(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hn_opt_var16(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hn_opt_var17(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hn_opt_var18(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hn_ops_var1(
        sgn: f32,
        m_C: integer,
        n_C: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_B: *mut f32,
        rs_B: integer,
        cs_B: integer,
        buff_C: *mut f32,
        rs_C: integer,
        cs_C: integer,
        buff_scale: *mut f32,
        info: *mut integer,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hn_opd_var1(
        sgn: f64,
        m_C: integer,
        n_C: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_B: *mut f64,
        rs_B: integer,
        cs_B: integer,
        buff_C: *mut f64,
        rs_C: integer,
        cs_C: integer,
        buff_scale: *mut f64,
        info: *mut integer,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hn_opc_var1(
        sgn: f32,
        m_C: integer,
        n_C: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_B: *mut scomplex,
        rs_B: integer,
        cs_B: integer,
        buff_C: *mut scomplex,
        rs_C: integer,
        cs_C: integer,
        buff_scale: *mut scomplex,
        info: *mut integer,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hn_opz_var1(
        sgn: f64,
        m_C: integer,
        n_C: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_B: *mut dcomplex,
        rs_B: integer,
        cs_B: integer,
        buff_C: *mut dcomplex,
        rs_C: integer,
        cs_C: integer,
        buff_scale: *mut dcomplex,
        info: *mut integer,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hh_blk_var1(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hh_blk_var2(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hh_blk_var3(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hh_blk_var4(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hh_blk_var5(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hh_blk_var6(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hh_blk_var7(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hh_blk_var8(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hh_blk_var9(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hh_blk_var10(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hh_blk_var11(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hh_blk_var12(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hh_blk_var13(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hh_blk_var14(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hh_blk_var15(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hh_blk_var16(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hh_blk_var17(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hh_blk_var18(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hh_opt_var1(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hh_opt_var2(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hh_opt_var3(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hh_opt_var4(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hh_opt_var5(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hh_opt_var6(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hh_opt_var7(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hh_opt_var8(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hh_opt_var9(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hh_opt_var10(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hh_opt_var11(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hh_opt_var12(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hh_opt_var13(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hh_opt_var14(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hh_opt_var15(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hh_opt_var16(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hh_opt_var17(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hh_opt_var18(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hh_ops_var1(
        sgn: f32,
        m_C: integer,
        n_C: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_B: *mut f32,
        rs_B: integer,
        cs_B: integer,
        buff_C: *mut f32,
        rs_C: integer,
        cs_C: integer,
        buff_scale: *mut f32,
        info: *mut integer,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hh_opd_var1(
        sgn: f64,
        m_C: integer,
        n_C: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_B: *mut f64,
        rs_B: integer,
        cs_B: integer,
        buff_C: *mut f64,
        rs_C: integer,
        cs_C: integer,
        buff_scale: *mut f64,
        info: *mut integer,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hh_opc_var1(
        sgn: f32,
        m_C: integer,
        n_C: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_B: *mut scomplex,
        rs_B: integer,
        cs_B: integer,
        buff_C: *mut scomplex,
        rs_C: integer,
        cs_C: integer,
        buff_scale: *mut scomplex,
        info: *mut integer,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hh_opz_var1(
        sgn: f64,
        m_C: integer,
        n_C: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_B: *mut dcomplex,
        rs_B: integer,
        cs_B: integer,
        buff_C: *mut dcomplex,
        rs_C: integer,
        cs_C: integer,
        buff_scale: *mut dcomplex,
        info: *mut integer,
    ) -> FLA_Error;
    pub fn FLA_Sylv_internal(
        transa: FLA_Trans,
        transb: FLA_Trans,
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nn(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_nh(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hn(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Sylv_hh(
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
        cntl: *mut fla_sylv_t,
    ) -> FLA_Error;
    pub fn FLA_Ttmm_l_blk_var1(A: FLA_Obj, cntl: *mut fla_ttmm_t) -> FLA_Error;
    pub fn FLA_Ttmm_l_blk_var2(A: FLA_Obj, cntl: *mut fla_ttmm_t) -> FLA_Error;
    pub fn FLA_Ttmm_l_blk_var3(A: FLA_Obj, cntl: *mut fla_ttmm_t) -> FLA_Error;
    pub fn FLA_Ttmm_l_unb_var1(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Ttmm_l_unb_var2(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Ttmm_l_unb_var3(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Ttmm_l_opt_var1(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Ttmm_l_ops_var1(
        mn_A: integer,
        A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Ttmm_l_opd_var1(
        mn_A: integer,
        A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Ttmm_l_opc_var1(
        mn_A: integer,
        A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Ttmm_l_opz_var1(
        mn_A: integer,
        A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Ttmm_l_opt_var2(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Ttmm_l_ops_var2(
        mn_A: integer,
        A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Ttmm_l_opd_var2(
        mn_A: integer,
        A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Ttmm_l_opc_var2(
        mn_A: integer,
        A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Ttmm_l_opz_var2(
        mn_A: integer,
        A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Ttmm_l_opt_var3(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Ttmm_l_ops_var3(
        mn_A: integer,
        A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Ttmm_l_opd_var3(
        mn_A: integer,
        A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Ttmm_l_opc_var3(
        mn_A: integer,
        A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Ttmm_l_opz_var3(
        mn_A: integer,
        A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Ttmm_u_blk_var1(A: FLA_Obj, cntl: *mut fla_ttmm_t) -> FLA_Error;
    pub fn FLA_Ttmm_u_blk_var2(A: FLA_Obj, cntl: *mut fla_ttmm_t) -> FLA_Error;
    pub fn FLA_Ttmm_u_blk_var3(A: FLA_Obj, cntl: *mut fla_ttmm_t) -> FLA_Error;
    pub fn FLA_Ttmm_u_unb_var1(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Ttmm_u_unb_var2(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Ttmm_u_unb_var3(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Ttmm_u_opt_var1(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Ttmm_u_ops_var1(
        mn_A: integer,
        A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Ttmm_u_opd_var1(
        mn_A: integer,
        A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Ttmm_u_opc_var1(
        mn_A: integer,
        A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Ttmm_u_opz_var1(
        mn_A: integer,
        A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Ttmm_u_opt_var2(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Ttmm_u_ops_var2(
        mn_A: integer,
        A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Ttmm_u_opd_var2(
        mn_A: integer,
        A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Ttmm_u_opc_var2(
        mn_A: integer,
        A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Ttmm_u_opz_var2(
        mn_A: integer,
        A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Ttmm_u_opt_var3(A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Ttmm_u_ops_var3(
        mn_A: integer,
        A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Ttmm_u_opd_var3(
        mn_A: integer,
        A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Ttmm_u_opc_var3(
        mn_A: integer,
        A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Ttmm_u_opz_var3(
        mn_A: integer,
        A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Ttmm_internal(uplo: FLA_Uplo, A: FLA_Obj, cntl: *mut fla_ttmm_t) -> FLA_Error;
    pub fn FLA_Ttmm_l(A: FLA_Obj, cntl: *mut fla_ttmm_t) -> FLA_Error;
    pub fn FLA_Ttmm_u(A: FLA_Obj, cntl: *mut fla_ttmm_t) -> FLA_Error;
    pub fn FLA_UDdate_UT_blk_var1(
        R: FLA_Obj,
        C: FLA_Obj,
        D: FLA_Obj,
        T: FLA_Obj,
        cntl: *mut fla_uddateut_t,
    ) -> FLA_Error;
    pub fn FLA_UDdate_UT_blk_var2(
        R: FLA_Obj,
        C: FLA_Obj,
        D: FLA_Obj,
        T: FLA_Obj,
        cntl: *mut fla_uddateut_t,
    ) -> FLA_Error;
    pub fn FLA_UDdate_UT_unb_var1(R: FLA_Obj, C: FLA_Obj, D: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_UDdate_UT_opt_var1(R: FLA_Obj, C: FLA_Obj, D: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_UDdate_UT_ops_var1(
        mn_RT: integer,
        m_C: integer,
        m_D: integer,
        R: *mut f32,
        rs_R: integer,
        cs_R: integer,
        C: *mut f32,
        rs_C: integer,
        cs_C: integer,
        D: *mut f32,
        rs_D: integer,
        cs_D: integer,
        T: *mut f32,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_UDdate_UT_opd_var1(
        mn_RT: integer,
        m_C: integer,
        m_D: integer,
        R: *mut f64,
        rs_R: integer,
        cs_R: integer,
        C: *mut f64,
        rs_C: integer,
        cs_C: integer,
        D: *mut f64,
        rs_D: integer,
        cs_D: integer,
        T: *mut f64,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_UDdate_UT_opc_var1(
        mn_RT: integer,
        m_C: integer,
        m_D: integer,
        R: *mut scomplex,
        rs_R: integer,
        cs_R: integer,
        C: *mut scomplex,
        rs_C: integer,
        cs_C: integer,
        D: *mut scomplex,
        rs_D: integer,
        cs_D: integer,
        T: *mut scomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_UDdate_UT_opz_var1(
        mn_RT: integer,
        m_C: integer,
        m_D: integer,
        R: *mut dcomplex,
        rs_R: integer,
        cs_R: integer,
        C: *mut dcomplex,
        rs_C: integer,
        cs_C: integer,
        D: *mut dcomplex,
        rs_D: integer,
        cs_D: integer,
        T: *mut dcomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_UDdate_UT(R: FLA_Obj, C: FLA_Obj, D: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_UDdate_UT_internal(
        R: FLA_Obj,
        C: FLA_Obj,
        D: FLA_Obj,
        T: FLA_Obj,
        cntl: *mut fla_uddateut_t,
    ) -> FLA_Error;
    pub fn FLA_UDdate_UT_create_T(R: FLA_Obj, T: *mut FLA_Obj) -> FLA_Error;
    pub fn FLA_UDdate_UT_update_rhs(
        T: FLA_Obj,
        bR: FLA_Obj,
        C: FLA_Obj,
        bC: FLA_Obj,
        D: FLA_Obj,
        bD: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_UDdate_UT_solve(R: FLA_Obj, bR: FLA_Obj, x: FLA_Obj) -> FLA_Error;
    pub fn FLASH_UDdate_UT_inc(
        R: FLA_Obj,
        C: FLA_Obj,
        D: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_UDdate_UT_inc_blk_var1(
        R: FLA_Obj,
        C: FLA_Obj,
        D: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        cntl: *mut fla_uddateutinc_t,
    ) -> FLA_Error;
    pub fn FLASH_UDdate_UT_inc_create_hier_matrices(
        R_flat: FLA_Obj,
        C_flat: FLA_Obj,
        D_flat: FLA_Obj,
        depth: fla_dim_t,
        b_flash: *mut fla_dim_t,
        b_alg: fla_dim_t,
        R: *mut FLA_Obj,
        C: *mut FLA_Obj,
        D: *mut FLA_Obj,
        T: *mut FLA_Obj,
        W: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_UDdate_UT_inc_determine_alg_blocksize(R: FLA_Obj) -> fla_dim_t;
    pub fn FLASH_UDdate_UT_inc_update_rhs(
        T: FLA_Obj,
        bR: FLA_Obj,
        C: FLA_Obj,
        bC: FLA_Obj,
        D: FLA_Obj,
        bD: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_UDdate_UT_inc_solve(R: FLA_Obj, bR: FLA_Obj, x: FLA_Obj) -> FLA_Error;
    pub fn fla_idamax(n: *mut integer, dx: *mut doublereal, incx: *mut integer) -> integer;
    pub fn fla_idamax_small(n: *mut integer, dx: *mut doublereal, incx: *mut integer) -> integer;
    pub fn FLA_Accum_T_UT_fc_unb_var1(A: FLA_Obj, t: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Accum_T_UT_fc_blk_var2(A: FLA_Obj, t: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Accum_T_UT_fc_opt_var1(A: FLA_Obj, t: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Accum_T_UT_fc_ops_var1(
        m_A: integer,
        n_AT: integer,
        A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        m_t: integer,
        t: *mut f32,
        inc_t: integer,
        T: *mut f32,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Accum_T_UT_fc_opd_var1(
        m_A: integer,
        n_AT: integer,
        A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        m_t: integer,
        t: *mut f64,
        inc_t: integer,
        T: *mut f64,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Accum_T_UT_fc_opc_var1(
        m_A: integer,
        n_AT: integer,
        A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        m_t: integer,
        t: *mut scomplex,
        inc_t: integer,
        T: *mut scomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Accum_T_UT_fc_opz_var1(
        m_A: integer,
        n_AT: integer,
        A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        m_t: integer,
        t: *mut dcomplex,
        inc_t: integer,
        T: *mut dcomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Accum_T_UT_fr_unb_var1(A: FLA_Obj, t: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Accum_T_UT_fr_blk_var2(A: FLA_Obj, t: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Accum_T_UT_fr_opt_var1(A: FLA_Obj, t: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLA_Accum_T_UT_fr_ops_var1(
        m_A: integer,
        n_A: integer,
        A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        m_t: integer,
        t: *mut f32,
        inc_t: integer,
        T: *mut f32,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Accum_T_UT_fr_opd_var1(
        m_A: integer,
        n_A: integer,
        A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        m_t: integer,
        t: *mut f64,
        inc_t: integer,
        T: *mut f64,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Accum_T_UT_fr_opc_var1(
        m_A: integer,
        n_A: integer,
        A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        m_t: integer,
        t: *mut scomplex,
        inc_t: integer,
        T: *mut scomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Accum_T_UT_fr_opz_var1(
        m_A: integer,
        n_A: integer,
        A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        m_t: integer,
        t: *mut dcomplex,
        inc_t: integer,
        T: *mut dcomplex,
        rs_T: integer,
        cs_T: integer,
    ) -> FLA_Error;
    pub fn FLA_Accum_T_UT_internal(
        direct: FLA_Direct,
        storev: FLA_Store,
        A: FLA_Obj,
        tau: FLA_Obj,
        T: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_lf_opt_var1(G: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Apply_G_lf_blk_var3(G: FLA_Obj, A: FLA_Obj, b_alg: fla_dim_t) -> FLA_Error;
    pub fn FLA_Apply_G_lb_opt_var1(c: FLA_Obj, s: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Apply_G_lb_ops_var1(
        m_A: integer,
        n_A: integer,
        buff_c: *mut f32,
        inc_c: integer,
        buff_s: *mut f32,
        inc_s: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_lb_opd_var1(
        m_A: integer,
        n_A: integer,
        buff_c: *mut f64,
        inc_c: integer,
        buff_s: *mut f64,
        inc_s: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_lb_opc_var1(
        m_A: integer,
        n_A: integer,
        buff_c: *mut f32,
        inc_c: integer,
        buff_s: *mut f32,
        inc_s: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_lb_opz_var1(
        m_A: integer,
        n_A: integer,
        buff_c: *mut f64,
        inc_c: integer,
        buff_s: *mut f64,
        inc_s: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_opt_var1(G: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Apply_G_rf_ops_var1(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_opd_var1(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_opc_var1(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_opz_var1(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asm_var1(G: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Apply_G_rf_ass_var1(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asd_var1(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asc_var1(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asz_var1(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_blk_var1(G: FLA_Obj, A: FLA_Obj, b_alg: fla_dim_t) -> FLA_Error;
    pub fn FLA_Apply_G_rf_bls_var1(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_bld_var1(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_blc_var1(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_blz_var1(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_opt_var2(G: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Apply_G_rf_ops_var2(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_opd_var2(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_opc_var2(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_opz_var2(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asm_var2(G: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Apply_G_rf_ass_var2(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asd_var2(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asc_var2(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asz_var2(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_blk_var2(G: FLA_Obj, A: FLA_Obj, b_alg: fla_dim_t) -> FLA_Error;
    pub fn FLA_Apply_G_rf_bls_var2(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_bld_var2(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_blc_var2(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_blz_var2(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_opt_var3(G: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Apply_G_rf_ops_var3(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_opd_var3(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_opc_var3(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_opz_var3(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asm_var3(G: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Apply_G_rf_ass_var3(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asd_var3(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asc_var3(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asz_var3(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_blk_var3(G: FLA_Obj, A: FLA_Obj, b_alg: fla_dim_t) -> FLA_Error;
    pub fn FLA_Apply_G_rf_bls_var3(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_bld_var3(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_blc_var3(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_blz_var3(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_opt_var4(G: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Apply_G_rf_ops_var4(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_opd_var4(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_opc_var4(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_opz_var4(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asm_var4(G: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Apply_G_rf_ass_var4(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asd_var4(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asc_var4(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asz_var4(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_blk_var4(G: FLA_Obj, A: FLA_Obj, b_alg: fla_dim_t) -> FLA_Error;
    pub fn FLA_Apply_G_rf_bls_var4(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_bld_var4(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_blc_var4(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_blz_var4(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_opt_var5(G: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Apply_G_rf_ops_var5(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_opd_var5(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_opc_var5(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_opz_var5(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asm_var5(G: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Apply_G_rf_ass_var5(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asd_var5(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asc_var5(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asz_var5(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_blk_var5(G: FLA_Obj, A: FLA_Obj, b_alg: fla_dim_t) -> FLA_Error;
    pub fn FLA_Apply_G_rf_bls_var5(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_bld_var5(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_blc_var5(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_blz_var5(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_opt_var6(G: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Apply_G_rf_ops_var6(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_opd_var6(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_opc_var6(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_opz_var6(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asm_var6(G: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Apply_G_rf_ass_var6(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asd_var6(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asc_var6(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asz_var6(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_blk_var6(G: FLA_Obj, A: FLA_Obj, b_alg: fla_dim_t) -> FLA_Error;
    pub fn FLA_Apply_G_rf_bls_var6(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_bld_var6(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_blc_var6(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_blz_var6(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_opt_var7(G: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Apply_G_rf_ops_var7(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_opd_var7(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_opc_var7(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_opz_var7(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asm_var7(G: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Apply_G_rf_ass_var7(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asd_var7(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asc_var7(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asz_var7(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_blk_var7(G: FLA_Obj, A: FLA_Obj, b_alg: fla_dim_t) -> FLA_Error;
    pub fn FLA_Apply_G_rf_bls_var7(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_bld_var7(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_blc_var7(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_blz_var7(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_opt_var8(G: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Apply_G_rf_ops_var8(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_opd_var8(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_opc_var8(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_opz_var8(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asm_var8(G: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Apply_G_rf_ass_var8(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asd_var8(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asc_var8(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asz_var8(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_blk_var8(G: FLA_Obj, A: FLA_Obj, b_alg: fla_dim_t) -> FLA_Error;
    pub fn FLA_Apply_G_rf_bls_var8(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_bld_var8(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_blc_var8(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_blz_var8(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_opt_var9(G: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Apply_G_rf_ops_var9(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_opd_var9(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_opc_var9(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_opz_var9(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asm_var9(G: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Apply_G_rf_ass_var9(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asd_var9(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asc_var9(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asz_var9(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_blk_var9(G: FLA_Obj, A: FLA_Obj, b_alg: fla_dim_t) -> FLA_Error;
    pub fn FLA_Apply_G_rf_bls_var9(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_bld_var9(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_blc_var9(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_blz_var9(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asm_var3b(G: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Apply_G_rf_ass_var3b(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        i_k: integer,
        iTL: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asd_var3b(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        i_k: integer,
        iTL: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asc_var3b(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        i_k: integer,
        iTL: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asz_var3b(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        i_k: integer,
        iTL: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_blk_var3b(G: FLA_Obj, A: FLA_Obj, b_alg: fla_dim_t) -> FLA_Error;
    pub fn FLA_Apply_G_rf_bls_var3b(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        i_k: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_bld_var3b(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        i_k: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_blc_var3b(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        i_k: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_blz_var3b(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        i_k: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asm_var5b(G: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Apply_G_rf_ass_var5b(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        i_k: integer,
        iTL: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asd_var5b(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        i_k: integer,
        iTL: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asc_var5b(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        i_k: integer,
        iTL: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asz_var5b(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        i_k: integer,
        iTL: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_blk_var5b(G: FLA_Obj, A: FLA_Obj, b_alg: fla_dim_t) -> FLA_Error;
    pub fn FLA_Apply_G_rf_bls_var5b(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        i_k: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_bld_var5b(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        i_k: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_blc_var5b(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        i_k: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_blz_var5b(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        i_k: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asm_var6b(G: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Apply_G_rf_ass_var6b(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        i_k: integer,
        iTL: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asd_var6b(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        i_k: integer,
        iTL: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asc_var6b(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        i_k: integer,
        iTL: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asz_var6b(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        i_k: integer,
        iTL: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_blk_var6b(G: FLA_Obj, A: FLA_Obj, b_alg: fla_dim_t) -> FLA_Error;
    pub fn FLA_Apply_G_rf_bls_var6b(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        i_k: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_bld_var6b(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        i_k: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_blc_var6b(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        i_k: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_blz_var6b(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        i_k: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asm_var8b(G: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Apply_G_rf_ass_var8b(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        i_k: integer,
        iTL: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asd_var8b(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        i_k: integer,
        iTL: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asc_var8b(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        i_k: integer,
        iTL: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asz_var8b(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        i_k: integer,
        iTL: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_blk_var8b(G: FLA_Obj, A: FLA_Obj, b_alg: fla_dim_t) -> FLA_Error;
    pub fn FLA_Apply_G_rf_bls_var8b(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        i_k: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_bld_var8b(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        i_k: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_blc_var8b(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        i_k: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_blz_var8b(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        i_k: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_bhs_var3(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_bhd_var3(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_bhc_var3(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_bhz_var3(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut FLA_Obj,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asm_var9b(G: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Apply_G_rf_ass_var9b(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        i_k: integer,
        iTL: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asd_var9b(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        i_k: integer,
        iTL: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asc_var9b(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        i_k: integer,
        iTL: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_asz_var9b(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        i_k: integer,
        iTL: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_blk_var9b(G: FLA_Obj, A: FLA_Obj, b_alg: fla_dim_t) -> FLA_Error;
    pub fn FLA_Apply_G_rf_bls_var9b(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        i_k: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_bld_var9b(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        i_k: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_blc_var9b(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        i_k: integer,
        buff_G: *mut scomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rf_blz_var9b(
        k_G: integer,
        m_A: integer,
        n_A: integer,
        i_k: integer,
        buff_G: *mut dcomplex,
        rs_G: integer,
        cs_G: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        b_alg: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rb_opt_var1(c: FLA_Obj, s: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Apply_G_rb_ops_var1(
        m_A: integer,
        n_A: integer,
        buff_c: *mut f32,
        inc_c: integer,
        buff_s: *mut f32,
        inc_s: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rb_opd_var1(
        m_A: integer,
        n_A: integer,
        buff_c: *mut f64,
        inc_c: integer,
        buff_s: *mut f64,
        inc_s: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rb_opc_var1(
        m_A: integer,
        n_A: integer,
        buff_c: *mut f32,
        inc_c: integer,
        buff_s: *mut f32,
        inc_s: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G_rb_opz_var1(
        m_A: integer,
        n_A: integer,
        buff_c: *mut f64,
        inc_c: integer,
        buff_s: *mut f64,
        inc_s: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_G(side: FLA_Side, direct: FLA_Direct, G: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Apply_G_internal(
        side: FLA_Side,
        direct: FLA_Direct,
        G: FLA_Obj,
        A: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Givens2(
        chi_1: FLA_Obj,
        chi_2: FLA_Obj,
        gamma: FLA_Obj,
        sigma: FLA_Obj,
        chi_1_new: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Givens2_ops(
        chi_1: *mut f32,
        chi_2: *mut f32,
        gamma: *mut f32,
        sigma: *mut f32,
        chi_1_new: *mut f32,
    ) -> FLA_Error;
    pub fn FLA_Givens2_opd(
        chi_1: *mut f64,
        chi_2: *mut f64,
        gamma: *mut f64,
        sigma: *mut f64,
        chi_1_new: *mut f64,
    ) -> FLA_Error;
    pub fn FLA_Apply_GTG(
        gamma: FLA_Obj,
        sigma: FLA_Obj,
        delta1: FLA_Obj,
        epsilon1: FLA_Obj,
        delta2: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Apply_GTG_ops(
        gamma: *mut f32,
        sigma: *mut f32,
        delta1: *mut f32,
        epsilon1: *mut f32,
        delta2: *mut f32,
    ) -> FLA_Error;
    pub fn FLA_Apply_GTG_opd(
        gamma: *mut f64,
        sigma: *mut f64,
        delta1: *mut f64,
        epsilon1: *mut f64,
        delta2: *mut f64,
    ) -> FLA_Error;
    pub fn FLA_Apply_H2_UT_l_unb_var1(
        tau: FLA_Obj,
        u2: FLA_Obj,
        a1t: FLA_Obj,
        A2: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Apply_H2_UT_l_opt_var1(
        tau: FLA_Obj,
        u2: FLA_Obj,
        a1t: FLA_Obj,
        A2: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Apply_H2_UT_l_ops_var1(
        m_u2_A2: integer,
        n_a1t: integer,
        tau: *mut f32,
        u2: *mut f32,
        inc_u2: integer,
        a1t: *mut f32,
        inc_a1t: integer,
        A2: *mut f32,
        rs_A2: integer,
        cs_A2: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_H2_UT_l_opd_var1(
        m_u2_A2: integer,
        n_a1t: integer,
        tau: *mut f64,
        u2: *mut f64,
        inc_u2: integer,
        a1t: *mut f64,
        inc_a1t: integer,
        A2: *mut f64,
        rs_A2: integer,
        cs_A2: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_H2_UT_l_opc_var1(
        m_u2_A2: integer,
        n_a1t: integer,
        tau: *mut scomplex,
        u2: *mut scomplex,
        inc_u2: integer,
        a1t: *mut scomplex,
        inc_a1t: integer,
        A2: *mut scomplex,
        rs_A2: integer,
        cs_A2: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_H2_UT_l_opz_var1(
        m_u2_A2: integer,
        n_a1t: integer,
        tau: *mut dcomplex,
        u2: *mut dcomplex,
        inc_u2: integer,
        a1t: *mut dcomplex,
        inc_a1t: integer,
        A2: *mut dcomplex,
        rs_A2: integer,
        cs_A2: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_H2_UT_r_unb_var1(
        tau: FLA_Obj,
        u2h: FLA_Obj,
        a1: FLA_Obj,
        A2: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Apply_H2_UT_r_opt_var1(
        tau: FLA_Obj,
        u2h: FLA_Obj,
        a1: FLA_Obj,
        A2: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Apply_H2_UT_r_ops_var1(
        n_u2h_A2: integer,
        m_a1: integer,
        tau: *mut f32,
        u2h: *mut f32,
        inc_u2h: integer,
        a1: *mut f32,
        inc_a1: integer,
        A2: *mut f32,
        rs_A2: integer,
        cs_A2: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_H2_UT_r_opd_var1(
        n_u2h_A2: integer,
        m_a1: integer,
        tau: *mut f64,
        u2h: *mut f64,
        inc_u2h: integer,
        a1: *mut f64,
        inc_a1: integer,
        A2: *mut f64,
        rs_A2: integer,
        cs_A2: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_H2_UT_r_opc_var1(
        n_u2h_A2: integer,
        m_a1: integer,
        tau: *mut scomplex,
        u2h: *mut scomplex,
        inc_u2h: integer,
        a1: *mut scomplex,
        inc_a1: integer,
        A2: *mut scomplex,
        rs_A2: integer,
        cs_A2: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_H2_UT_r_opz_var1(
        n_u2h_A2: integer,
        m_a1: integer,
        tau: *mut dcomplex,
        u2h: *mut dcomplex,
        inc_u2h: integer,
        a1: *mut dcomplex,
        inc_a1: integer,
        A2: *mut dcomplex,
        rs_A2: integer,
        cs_A2: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_H2_UT_internal(
        side: FLA_Side,
        tau: FLA_Obj,
        u2: FLA_Obj,
        a1: FLA_Obj,
        A2: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Apply_HUD_UT_l_unb_var1(
        tau: FLA_Obj,
        w12t: FLA_Obj,
        r12t: FLA_Obj,
        u1: FLA_Obj,
        C2: FLA_Obj,
        v1: FLA_Obj,
        D2: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Apply_HUD_UT_l_opt_var1(
        tau: FLA_Obj,
        w12t: FLA_Obj,
        r12t: FLA_Obj,
        u1: FLA_Obj,
        C2: FLA_Obj,
        v1: FLA_Obj,
        D2: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Apply_HUD_UT_l_ops_var1(
        m_u1_C2: integer,
        m_v1_D2: integer,
        n_r12t: integer,
        tau: *mut f32,
        w12t: *mut f32,
        inc_w12t: integer,
        r12t: *mut f32,
        inc_r12t: integer,
        u1: *mut f32,
        inc_u1: integer,
        C2: *mut f32,
        rs_C2: integer,
        cs_C2: integer,
        v1: *mut f32,
        inc_v1: integer,
        D2: *mut f32,
        rs_D2: integer,
        cs_D2: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_HUD_UT_l_opd_var1(
        m_u1_C2: integer,
        m_v1_D2: integer,
        n_r12t: integer,
        tau: *mut f64,
        w12t: *mut f64,
        inc_w12t: integer,
        r12t: *mut f64,
        inc_r12t: integer,
        u1: *mut f64,
        inc_u1: integer,
        C2: *mut f64,
        rs_C2: integer,
        cs_C2: integer,
        v1: *mut f64,
        inc_v1: integer,
        D2: *mut f64,
        rs_D2: integer,
        cs_D2: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_HUD_UT_l_opc_var1(
        m_u1_C2: integer,
        m_v1_D2: integer,
        n_r12t: integer,
        tau: *mut scomplex,
        w12t: *mut scomplex,
        inc_w12t: integer,
        r12t: *mut scomplex,
        inc_r12t: integer,
        u1: *mut scomplex,
        inc_u1: integer,
        C2: *mut scomplex,
        rs_C2: integer,
        cs_C2: integer,
        v1: *mut scomplex,
        inc_v1: integer,
        D2: *mut scomplex,
        rs_D2: integer,
        cs_D2: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_HUD_UT_l_opz_var1(
        m_u1_C2: integer,
        m_v1_D2: integer,
        n_r12t: integer,
        tau: *mut dcomplex,
        w12t: *mut dcomplex,
        inc_w12t: integer,
        r12t: *mut dcomplex,
        inc_r12t: integer,
        u1: *mut dcomplex,
        inc_u1: integer,
        C2: *mut dcomplex,
        rs_C2: integer,
        cs_C2: integer,
        v1: *mut dcomplex,
        inc_v1: integer,
        D2: *mut dcomplex,
        rs_D2: integer,
        cs_D2: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_HUD_UT_internal(
        side: FLA_Side,
        tau: FLA_Obj,
        w12t: FLA_Obj,
        r12t: FLA_Obj,
        u1: FLA_Obj,
        C2: FLA_Obj,
        v1: FLA_Obj,
        D2: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_lnfc_blk_var1(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_lnfc_blk_var2(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_lnfc_blk_var3(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_lnfr_blk_var1(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_lnfr_blk_var2(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_lnfr_blk_var3(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_lnbc_blk_var1(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_lnbc_blk_var2(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_lnbc_blk_var3(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_lnbr_blk_var1(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_lnbr_blk_var2(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_lnbr_blk_var3(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_lhfc_blk_var1(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_lhfc_blk_var2(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_lhfc_blk_var3(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_lhfr_blk_var1(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_lhfr_blk_var2(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_lhfr_blk_var3(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_lhbc_blk_var1(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_lhbc_blk_var2(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_lhbc_blk_var3(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_lhbr_blk_var1(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_lhbr_blk_var2(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_lhbr_blk_var3(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_rhbc_blk_var1(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_rhbc_blk_var2(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_rhbc_blk_var3(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_rhbr_blk_var1(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_rhbr_blk_var2(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_rhbr_blk_var3(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_rhfc_blk_var1(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_rhfc_blk_var2(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_rhfc_blk_var3(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_rhfr_blk_var1(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_rhfr_blk_var2(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_rhfr_blk_var3(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_rnbc_blk_var1(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_rnbc_blk_var2(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_rnbc_blk_var3(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_rnbr_blk_var1(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_rnbr_blk_var2(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_rnbr_blk_var3(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_rnfc_blk_var1(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_rnfc_blk_var2(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_rnfc_blk_var3(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_rnfr_blk_var1(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_rnfr_blk_var2(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_rnfr_blk_var3(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_internal(
        side: FLA_Side,
        trans: FLA_Trans,
        direct: FLA_Direct,
        storev: FLA_Store,
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_lnfc(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_lnfr(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_lnbc(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_lnbr(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_lhfc(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_lhfr(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_lhbc(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_lhbr(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_rhbc(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_rhbr(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_rhfc(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_rhfr(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_rnbc(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_rnbr(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_rnfc(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_rnfr(
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_create_workspace(T: FLA_Obj, B: FLA_Obj, W: *mut FLA_Obj) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_create_workspace_side(
        side: FLA_Side,
        T: FLA_Obj,
        B: FLA_Obj,
        W: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_Apply_Q_UT(
        side: FLA_Side,
        trans: FLA_Trans,
        direct: FLA_Direct,
        storev: FLA_Store,
        A: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_Apply_Q_UT_create_workspace(TW: FLA_Obj, B: FLA_Obj, W: *mut FLA_Obj)
        -> FLA_Error;
    pub fn FLA_Apply_Q2_UT_lhfc_blk_var1(
        D: FLA_Obj,
        T: FLA_Obj,
        W1: FLA_Obj,
        C: FLA_Obj,
        E: FLA_Obj,
        cntl: *mut fla_apq2ut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q2_UT_lhfc_blk_var2(
        D: FLA_Obj,
        T: FLA_Obj,
        W1: FLA_Obj,
        C: FLA_Obj,
        E: FLA_Obj,
        cntl: *mut fla_apq2ut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q2_UT_lhfc_blk_var3(
        D: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        C: FLA_Obj,
        E: FLA_Obj,
        cntl: *mut fla_apq2ut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q2_UT_lnfc_blk_var1(
        D: FLA_Obj,
        T: FLA_Obj,
        W1: FLA_Obj,
        C: FLA_Obj,
        E: FLA_Obj,
        cntl: *mut fla_apq2ut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q2_UT_lnfc_blk_var2(
        D: FLA_Obj,
        T: FLA_Obj,
        W1: FLA_Obj,
        C: FLA_Obj,
        E: FLA_Obj,
        cntl: *mut fla_apq2ut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q2_UT_lnfc_blk_var3(
        D: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        C: FLA_Obj,
        E: FLA_Obj,
        cntl: *mut fla_apq2ut_t,
    ) -> FLA_Error;
    pub fn FLASH_Apply_Q2_UT(
        side: FLA_Side,
        trans: FLA_Trans,
        direct: FLA_Direct,
        storev: FLA_Store,
        D: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        C: FLA_Obj,
        E: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q2_UT_internal(
        side: FLA_Side,
        trans: FLA_Trans,
        direct: FLA_Direct,
        storev: FLA_Store,
        D: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        C: FLA_Obj,
        E: FLA_Obj,
        cntl: *mut fla_apq2ut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q2_UT_lhfc(
        D: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        C: FLA_Obj,
        E: FLA_Obj,
        cntl: *mut fla_apq2ut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q2_UT_lnfc(
        D: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        C: FLA_Obj,
        E: FLA_Obj,
        cntl: *mut fla_apq2ut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_CAQ2_UT_lhfc_blk_var1(
        D: FLA_Obj,
        T: FLA_Obj,
        W1: FLA_Obj,
        C: FLA_Obj,
        E: FLA_Obj,
        cntl: *mut fla_apcaq2ut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_CAQ2_UT_lhfc_blk_var2(
        D: FLA_Obj,
        T: FLA_Obj,
        W1: FLA_Obj,
        C: FLA_Obj,
        E: FLA_Obj,
        cntl: *mut fla_apcaq2ut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_CAQ2_UT_lhfc_blk_var3(
        D: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        C: FLA_Obj,
        E: FLA_Obj,
        cntl: *mut fla_apcaq2ut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_CAQ2_UT_internal(
        side: FLA_Side,
        trans: FLA_Trans,
        direct: FLA_Direct,
        storev: FLA_Store,
        D: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        C: FLA_Obj,
        E: FLA_Obj,
        cntl: *mut fla_apcaq2ut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_CAQ2_UT_lhfc(
        D: FLA_Obj,
        T: FLA_Obj,
        W: FLA_Obj,
        C: FLA_Obj,
        E: FLA_Obj,
        cntl: *mut fla_apcaq2ut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_QUD_UT_lhfc_blk_var1(
        T: FLA_Obj,
        W: FLA_Obj,
        R: FLA_Obj,
        U: FLA_Obj,
        C: FLA_Obj,
        V: FLA_Obj,
        D: FLA_Obj,
        cntl: *mut fla_apqudut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_QUD_UT_lhfc_blk_var2(
        T: FLA_Obj,
        W: FLA_Obj,
        R: FLA_Obj,
        U: FLA_Obj,
        C: FLA_Obj,
        V: FLA_Obj,
        D: FLA_Obj,
        cntl: *mut fla_apqudut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_QUD_UT_lhfc_blk_var3(
        T: FLA_Obj,
        W: FLA_Obj,
        R: FLA_Obj,
        U: FLA_Obj,
        C: FLA_Obj,
        V: FLA_Obj,
        D: FLA_Obj,
        cntl: *mut fla_apqudut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_QUD_UT(
        side: FLA_Side,
        trans: FLA_Trans,
        direct: FLA_Direct,
        storev: FLA_Store,
        T: FLA_Obj,
        W: FLA_Obj,
        R: FLA_Obj,
        U: FLA_Obj,
        C: FLA_Obj,
        V: FLA_Obj,
        D: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Apply_QUD_UT_internal(
        side: FLA_Side,
        trans: FLA_Trans,
        direct: FLA_Direct,
        storev: FLA_Store,
        T: FLA_Obj,
        W: FLA_Obj,
        R: FLA_Obj,
        U: FLA_Obj,
        C: FLA_Obj,
        V: FLA_Obj,
        D: FLA_Obj,
        cntl: *mut fla_apqudut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_QUD_UT_lhfc(
        T: FLA_Obj,
        W: FLA_Obj,
        R: FLA_Obj,
        U: FLA_Obj,
        C: FLA_Obj,
        V: FLA_Obj,
        D: FLA_Obj,
        cntl: *mut fla_apqudut_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_QUD_UT_create_workspace(T: FLA_Obj, R: FLA_Obj, W: *mut FLA_Obj) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_inc_lhfc_blk_var1(
        A: FLA_Obj,
        TW: FLA_Obj,
        W1: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqutinc_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_inc_lnfc_blk_var1(
        A: FLA_Obj,
        TW: FLA_Obj,
        W1: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqutinc_t,
    ) -> FLA_Error;
    pub fn FLASH_Apply_Q_UT_inc(
        side: FLA_Side,
        trans: FLA_Trans,
        direct: FLA_Direct,
        storev: FLA_Store,
        A: FLA_Obj,
        TW: FLA_Obj,
        W1: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_Apply_Q_UT_inc_create_workspace(
        TW: FLA_Obj,
        B: FLA_Obj,
        W: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_inc_internal(
        side: FLA_Side,
        trans: FLA_Trans,
        direct: FLA_Direct,
        storev: FLA_Store,
        A: FLA_Obj,
        TW: FLA_Obj,
        W1: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqutinc_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_inc_lhfc(
        A: FLA_Obj,
        TW: FLA_Obj,
        W1: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqutinc_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_Q_UT_inc_lnfc(
        A: FLA_Obj,
        TW: FLA_Obj,
        W1: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apqutinc_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_CAQ_UT_inc_lhfc_blk_var1(
        R: FLA_Obj,
        TW: FLA_Obj,
        W1: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apcaqutinc_t,
    ) -> FLA_Error;
    pub fn FLASH_Apply_CAQ_UT_inc(
        p: fla_dim_t,
        side: FLA_Side,
        trans: FLA_Trans,
        direct: FLA_Direct,
        storev: FLA_Store,
        A: FLA_Obj,
        ATW: FLA_Obj,
        R: FLA_Obj,
        RTW: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Apply_CAQ_UT_inc_apply_panels(
        nb_part: fla_dim_t,
        A: FLA_Obj,
        ATW: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_Apply_CAQ_UT_inc_create_workspace(
        p: fla_dim_t,
        TW: FLA_Obj,
        B: FLA_Obj,
        W: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Apply_CAQ_UT_inc_internal(
        side: FLA_Side,
        trans: FLA_Trans,
        direct: FLA_Direct,
        storev: FLA_Store,
        R: FLA_Obj,
        TW: FLA_Obj,
        W1: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apcaqutinc_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_CAQ_UT_inc_lhfc(
        R: FLA_Obj,
        TW: FLA_Obj,
        W1: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_apcaqutinc_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_QUD_UT_inc_lhfc_blk_var1(
        T: FLA_Obj,
        W: FLA_Obj,
        B: FLA_Obj,
        U: FLA_Obj,
        C: FLA_Obj,
        V: FLA_Obj,
        D: FLA_Obj,
        cntl: *mut fla_apqudutinc_t,
    ) -> FLA_Error;
    pub fn FLASH_Apply_QUD_UT_inc(
        side: FLA_Side,
        trans: FLA_Trans,
        direct: FLA_Direct,
        storev: FLA_Store,
        T: FLA_Obj,
        W: FLA_Obj,
        R: FLA_Obj,
        U: FLA_Obj,
        C: FLA_Obj,
        V: FLA_Obj,
        D: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Apply_QUD_UT_inc_internal(
        side: FLA_Side,
        trans: FLA_Trans,
        direct: FLA_Direct,
        storev: FLA_Store,
        T: FLA_Obj,
        W: FLA_Obj,
        R: FLA_Obj,
        U: FLA_Obj,
        C: FLA_Obj,
        V: FLA_Obj,
        D: FLA_Obj,
        cntl: *mut fla_apqudutinc_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_QUD_UT_inc_lhfc(
        T: FLA_Obj,
        W: FLA_Obj,
        R: FLA_Obj,
        U: FLA_Obj,
        C: FLA_Obj,
        V: FLA_Obj,
        D: FLA_Obj,
        cntl: *mut fla_apqudutinc_t,
    ) -> FLA_Error;
    pub fn FLASH_Apply_QUD_UT_inc_create_workspace(
        T: FLA_Obj,
        R: FLA_Obj,
        W: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLA_Apply_pivots_ln_blk_var1(
        p: FLA_Obj,
        A: FLA_Obj,
        cntl: *mut fla_appiv_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_pivots_ln_blk_var2(
        p: FLA_Obj,
        A: FLA_Obj,
        cntl: *mut fla_appiv_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_pivots_ln_opt_var1(p: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Apply_pivots_ln_opi_var1(
        n: integer,
        a: *mut integer,
        a_rs: integer,
        a_cs: integer,
        k1: integer,
        k2: integer,
        p: *mut integer,
        incp: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_pivots_ln_ops_var1(
        n: integer,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
        k1: integer,
        k2: integer,
        p: *mut integer,
        incp: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_pivots_ln_opd_var1(
        n: integer,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
        k1: integer,
        k2: integer,
        p: *mut integer,
        incp: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_pivots_ln_opc_var1(
        n: integer,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
        k1: integer,
        k2: integer,
        p: *mut integer,
        incp: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_pivots_ln_opz_var1(
        n: integer,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
        k1: integer,
        k2: integer,
        p: *mut integer,
        incp: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_pivots_lt_opt_var1(p: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Apply_pivots_rn_opt_var1(p: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Apply_pivots_rn_ops_var1(
        n: integer,
        a: *mut f32,
        a_rs: integer,
        a_cs: integer,
        k1: integer,
        k2: integer,
        p: *mut integer,
        incp: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_pivots_rn_opd_var1(
        n: integer,
        a: *mut f64,
        a_rs: integer,
        a_cs: integer,
        k1: integer,
        k2: integer,
        p: *mut integer,
        incp: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_pivots_rn_opc_var1(
        n: integer,
        a: *mut scomplex,
        a_rs: integer,
        a_cs: integer,
        k1: integer,
        k2: integer,
        p: *mut integer,
        incp: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_pivots_rn_opz_var1(
        n: integer,
        a: *mut dcomplex,
        a_rs: integer,
        a_cs: integer,
        k1: integer,
        k2: integer,
        p: *mut integer,
        incp: integer,
    ) -> FLA_Error;
    pub fn FLA_Apply_pivots_rt_opt_var1(p: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLA_Apply_pivots_internal(
        side: FLA_Side,
        trans: FLA_Trans,
        p: FLA_Obj,
        A: FLA_Obj,
        cntl: *mut fla_appiv_t,
    ) -> FLA_Error;
    pub fn FLA_Apply_pivots_ln(p: FLA_Obj, A: FLA_Obj, cntl: *mut fla_appiv_t) -> FLA_Error;
    pub fn FLA_Apply_pivots_lt(p: FLA_Obj, A: FLA_Obj, cntl: *mut fla_appiv_t) -> FLA_Error;
    pub fn FLA_Apply_pivots_rn(p: FLA_Obj, A: FLA_Obj, cntl: *mut fla_appiv_t) -> FLA_Error;
    pub fn FLA_Apply_pivots_rt(p: FLA_Obj, A: FLA_Obj, cntl: *mut fla_appiv_t) -> FLA_Error;
    pub fn FLA_Eig_gest_il_blk_var1(
        A: FLA_Obj,
        Y: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_eig_gest_t,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_il_blk_var2(
        A: FLA_Obj,
        Y: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_eig_gest_t,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_il_blk_var3(
        A: FLA_Obj,
        Y: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_eig_gest_t,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_il_blk_var4(
        A: FLA_Obj,
        Y: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_eig_gest_t,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_il_blk_var5(
        A: FLA_Obj,
        Y: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_eig_gest_t,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_il_unb_var1(A: FLA_Obj, Y: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_il_unb_var2(A: FLA_Obj, Y: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_il_unb_var3(A: FLA_Obj, Y: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_il_unb_var4(A: FLA_Obj, Y: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_il_unb_var5(A: FLA_Obj, Y: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_il_opt_var1(A: FLA_Obj, Y: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_il_ops_var1(
        m_AB: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut f32,
        inc_y: integer,
        buff_B: *mut f32,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_il_opd_var1(
        m_AB: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut f64,
        inc_y: integer,
        buff_B: *mut f64,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_il_opc_var1(
        m_AB: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut scomplex,
        inc_y: integer,
        buff_B: *mut scomplex,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_il_opz_var1(
        m_AB: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut dcomplex,
        inc_y: integer,
        buff_B: *mut dcomplex,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_il_opt_var2(A: FLA_Obj, Y: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_il_ops_var2(
        m_AB: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut f32,
        inc_y: integer,
        buff_B: *mut f32,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_il_opd_var2(
        m_AB: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut f64,
        inc_y: integer,
        buff_B: *mut f64,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_il_opc_var2(
        m_AB: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut scomplex,
        inc_y: integer,
        buff_B: *mut scomplex,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_il_opz_var2(
        m_AB: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut dcomplex,
        inc_y: integer,
        buff_B: *mut dcomplex,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_il_opt_var3(A: FLA_Obj, Y: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_il_ops_var3(
        m_AB: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_Y: *mut f32,
        rs_Y: integer,
        cs_Y: integer,
        buff_B: *mut f32,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_il_opd_var3(
        m_AB: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_Y: *mut f64,
        rs_Y: integer,
        cs_Y: integer,
        buff_B: *mut f64,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_il_opc_var3(
        m_AB: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_Y: *mut scomplex,
        rs_Y: integer,
        cs_Y: integer,
        buff_B: *mut scomplex,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_il_opz_var3(
        m_AB: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_Y: *mut dcomplex,
        rs_Y: integer,
        cs_Y: integer,
        buff_B: *mut dcomplex,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_il_opt_var4(A: FLA_Obj, Y: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_il_ops_var4(
        m_AB: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut f32,
        inc_y: integer,
        buff_B: *mut f32,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_il_opd_var4(
        m_AB: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut f64,
        inc_y: integer,
        buff_B: *mut f64,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_il_opc_var4(
        m_AB: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut scomplex,
        inc_y: integer,
        buff_B: *mut scomplex,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_il_opz_var4(
        m_AB: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut dcomplex,
        inc_y: integer,
        buff_B: *mut dcomplex,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_il_opt_var5(A: FLA_Obj, Y: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_il_ops_var5(
        m_AB: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut f32,
        inc_y: integer,
        buff_B: *mut f32,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_il_opd_var5(
        m_AB: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut f64,
        inc_y: integer,
        buff_B: *mut f64,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_il_opc_var5(
        m_AB: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut scomplex,
        inc_y: integer,
        buff_B: *mut scomplex,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_il_opz_var5(
        m_AB: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut dcomplex,
        inc_y: integer,
        buff_B: *mut dcomplex,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_iu_blk_var1(
        A: FLA_Obj,
        Y: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_eig_gest_t,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_iu_blk_var2(
        A: FLA_Obj,
        Y: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_eig_gest_t,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_iu_blk_var3(
        A: FLA_Obj,
        Y: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_eig_gest_t,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_iu_blk_var4(
        A: FLA_Obj,
        Y: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_eig_gest_t,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_iu_blk_var5(
        A: FLA_Obj,
        Y: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_eig_gest_t,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_iu_unb_var1(A: FLA_Obj, Y: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_iu_unb_var2(A: FLA_Obj, Y: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_iu_unb_var3(A: FLA_Obj, Y: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_iu_unb_var4(A: FLA_Obj, Y: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_iu_unb_var5(A: FLA_Obj, Y: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_iu_opt_var1(A: FLA_Obj, Y: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_iu_ops_var1(
        m_AB: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut f32,
        inc_y: integer,
        buff_B: *mut f32,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_iu_opd_var1(
        m_AB: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut f64,
        inc_y: integer,
        buff_B: *mut f64,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_iu_opc_var1(
        m_AB: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut scomplex,
        inc_y: integer,
        buff_B: *mut scomplex,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_iu_opz_var1(
        m_AB: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut dcomplex,
        inc_y: integer,
        buff_B: *mut dcomplex,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_iu_opt_var2(A: FLA_Obj, Y: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_iu_ops_var2(
        m_AB: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut f32,
        inc_y: integer,
        buff_B: *mut f32,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_iu_opd_var2(
        m_AB: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut f64,
        inc_y: integer,
        buff_B: *mut f64,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_iu_opc_var2(
        m_AB: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut scomplex,
        inc_y: integer,
        buff_B: *mut scomplex,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_iu_opz_var2(
        m_AB: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut dcomplex,
        inc_y: integer,
        buff_B: *mut dcomplex,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_iu_opt_var3(A: FLA_Obj, Y: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_iu_ops_var3(
        m_AB: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_Y: *mut f32,
        rs_Y: integer,
        cs_Y: integer,
        buff_B: *mut f32,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_iu_opd_var3(
        m_AB: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_Y: *mut f64,
        rs_Y: integer,
        cs_Y: integer,
        buff_B: *mut f64,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_iu_opc_var3(
        m_AB: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_Y: *mut scomplex,
        rs_Y: integer,
        cs_Y: integer,
        buff_B: *mut scomplex,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_iu_opz_var3(
        m_AB: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_Y: *mut dcomplex,
        rs_Y: integer,
        cs_Y: integer,
        buff_B: *mut dcomplex,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_iu_opt_var4(A: FLA_Obj, Y: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_iu_ops_var4(
        m_AB: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut f32,
        inc_y: integer,
        buff_B: *mut f32,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_iu_opd_var4(
        m_AB: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut f64,
        inc_y: integer,
        buff_B: *mut f64,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_iu_opc_var4(
        m_AB: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut scomplex,
        inc_y: integer,
        buff_B: *mut scomplex,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_iu_opz_var4(
        m_AB: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut dcomplex,
        inc_y: integer,
        buff_B: *mut dcomplex,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_iu_opt_var5(A: FLA_Obj, Y: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_iu_ops_var5(
        m_AB: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut f32,
        inc_y: integer,
        buff_B: *mut f32,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_iu_opd_var5(
        m_AB: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut f64,
        inc_y: integer,
        buff_B: *mut f64,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_iu_opc_var5(
        m_AB: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut scomplex,
        inc_y: integer,
        buff_B: *mut scomplex,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_iu_opz_var5(
        m_AB: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut dcomplex,
        inc_y: integer,
        buff_B: *mut dcomplex,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nl_blk_var1(
        A: FLA_Obj,
        Y: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_eig_gest_t,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nl_blk_var2(
        A: FLA_Obj,
        Y: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_eig_gest_t,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nl_blk_var3(
        A: FLA_Obj,
        Y: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_eig_gest_t,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nl_blk_var4(
        A: FLA_Obj,
        Y: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_eig_gest_t,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nl_blk_var5(
        A: FLA_Obj,
        Y: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_eig_gest_t,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nl_unb_var1(A: FLA_Obj, Y: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_nl_unb_var2(A: FLA_Obj, Y: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_nl_unb_var3(A: FLA_Obj, Y: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_nl_unb_var4(A: FLA_Obj, Y: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_nl_unb_var5(A: FLA_Obj, Y: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_nl_opt_var1(A: FLA_Obj, Y: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_nl_ops_var1(
        m_AB: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut f32,
        inc_y: integer,
        buff_B: *mut f32,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nl_opd_var1(
        m_AB: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut f64,
        inc_y: integer,
        buff_B: *mut f64,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nl_opc_var1(
        m_AB: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut scomplex,
        inc_y: integer,
        buff_B: *mut scomplex,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nl_opz_var1(
        m_AB: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut dcomplex,
        inc_y: integer,
        buff_B: *mut dcomplex,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nl_opt_var2(A: FLA_Obj, Y: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_nl_ops_var2(
        m_AB: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut f32,
        inc_y: integer,
        buff_B: *mut f32,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nl_opd_var2(
        m_AB: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut f64,
        inc_y: integer,
        buff_B: *mut f64,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nl_opc_var2(
        m_AB: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut scomplex,
        inc_y: integer,
        buff_B: *mut scomplex,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nl_opz_var2(
        m_AB: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut dcomplex,
        inc_y: integer,
        buff_B: *mut dcomplex,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nl_opt_var3(A: FLA_Obj, Y: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_nl_ops_var3(
        m_AB: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut f32,
        inc_y: integer,
        buff_B: *mut f32,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nl_opd_var3(
        m_AB: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut f64,
        inc_y: integer,
        buff_B: *mut f64,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nl_opc_var3(
        m_AB: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut scomplex,
        inc_y: integer,
        buff_B: *mut scomplex,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nl_opz_var3(
        m_AB: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut dcomplex,
        inc_y: integer,
        buff_B: *mut dcomplex,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nl_opt_var4(A: FLA_Obj, Y: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_nl_ops_var4(
        m_AB: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut f32,
        inc_y: integer,
        buff_B: *mut f32,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nl_opd_var4(
        m_AB: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut f64,
        inc_y: integer,
        buff_B: *mut f64,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nl_opc_var4(
        m_AB: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut scomplex,
        inc_y: integer,
        buff_B: *mut scomplex,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nl_opz_var4(
        m_AB: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut dcomplex,
        inc_y: integer,
        buff_B: *mut dcomplex,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nl_opt_var5(A: FLA_Obj, Y: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_nl_ops_var5(
        m_AB: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut f32,
        inc_y: integer,
        buff_B: *mut f32,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nl_opd_var5(
        m_AB: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut f64,
        inc_y: integer,
        buff_B: *mut f64,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nl_opc_var5(
        m_AB: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut scomplex,
        inc_y: integer,
        buff_B: *mut scomplex,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nl_opz_var5(
        m_AB: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut dcomplex,
        inc_y: integer,
        buff_B: *mut dcomplex,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nu_blk_var1(
        A: FLA_Obj,
        Y: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_eig_gest_t,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nu_blk_var2(
        A: FLA_Obj,
        Y: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_eig_gest_t,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nu_blk_var3(
        A: FLA_Obj,
        Y: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_eig_gest_t,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nu_blk_var4(
        A: FLA_Obj,
        Y: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_eig_gest_t,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nu_blk_var5(
        A: FLA_Obj,
        Y: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_eig_gest_t,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nu_unb_var1(A: FLA_Obj, Y: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_nu_unb_var2(A: FLA_Obj, Y: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_nu_unb_var3(A: FLA_Obj, Y: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_nu_unb_var4(A: FLA_Obj, Y: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_nu_unb_var5(A: FLA_Obj, Y: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_nu_opt_var1(A: FLA_Obj, Y: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_nu_ops_var1(
        m_AB: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut f32,
        inc_y: integer,
        buff_B: *mut f32,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nu_opd_var1(
        m_AB: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut f64,
        inc_y: integer,
        buff_B: *mut f64,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nu_opc_var1(
        m_AB: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut scomplex,
        inc_y: integer,
        buff_B: *mut scomplex,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nu_opz_var1(
        m_AB: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut dcomplex,
        inc_y: integer,
        buff_B: *mut dcomplex,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nu_opt_var2(A: FLA_Obj, Y: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_nu_ops_var2(
        m_AB: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut f32,
        inc_y: integer,
        buff_B: *mut f32,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nu_opd_var2(
        m_AB: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut f64,
        inc_y: integer,
        buff_B: *mut f64,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nu_opc_var2(
        m_AB: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut scomplex,
        inc_y: integer,
        buff_B: *mut scomplex,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nu_opz_var2(
        m_AB: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut dcomplex,
        inc_y: integer,
        buff_B: *mut dcomplex,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nu_opt_var3(A: FLA_Obj, Y: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_nu_ops_var3(
        m_AB: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut f32,
        inc_y: integer,
        buff_B: *mut f32,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nu_opd_var3(
        m_AB: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut f64,
        inc_y: integer,
        buff_B: *mut f64,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nu_opc_var3(
        m_AB: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut scomplex,
        inc_y: integer,
        buff_B: *mut scomplex,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nu_opz_var3(
        m_AB: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut dcomplex,
        inc_y: integer,
        buff_B: *mut dcomplex,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nu_opt_var4(A: FLA_Obj, Y: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_nu_ops_var4(
        m_AB: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut f32,
        inc_y: integer,
        buff_B: *mut f32,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nu_opd_var4(
        m_AB: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut f64,
        inc_y: integer,
        buff_B: *mut f64,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nu_opc_var4(
        m_AB: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut scomplex,
        inc_y: integer,
        buff_B: *mut scomplex,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nu_opz_var4(
        m_AB: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut dcomplex,
        inc_y: integer,
        buff_B: *mut dcomplex,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nu_opt_var5(A: FLA_Obj, Y: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLA_Eig_gest_nu_ops_var5(
        m_AB: integer,
        buff_A: *mut f32,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut f32,
        inc_y: integer,
        buff_B: *mut f32,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nu_opd_var5(
        m_AB: integer,
        buff_A: *mut f64,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut f64,
        inc_y: integer,
        buff_B: *mut f64,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nu_opc_var5(
        m_AB: integer,
        buff_A: *mut scomplex,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut scomplex,
        inc_y: integer,
        buff_B: *mut scomplex,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nu_opz_var5(
        m_AB: integer,
        buff_A: *mut dcomplex,
        rs_A: integer,
        cs_A: integer,
        buff_y: *mut dcomplex,
        inc_y: integer,
        buff_B: *mut dcomplex,
        rs_B: integer,
        cs_B: integer,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_internal(
        inv: FLA_Inv,
        uplo: FLA_Uplo,
        A: FLA_Obj,
        Y: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_eig_gest_t,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_il(
        A: FLA_Obj,
        Y: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_eig_gest_t,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_iu(
        A: FLA_Obj,
        Y: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_eig_gest_t,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nl(
        A: FLA_Obj,
        Y: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_eig_gest_t,
    ) -> FLA_Error;
    pub fn FLA_Eig_gest_nu(
        A: FLA_Obj,
        Y: FLA_Obj,
        B: FLA_Obj,
        cntl: *mut fla_eig_gest_t,
    ) -> FLA_Error;
    pub fn FLASH_Obj_blocksizes_check(
        H: FLA_Obj,
        b_m: *mut fla_dim_t,
        b_n: *mut fla_dim_t,
    ) -> FLA_Error;
    pub fn FLASH_Obj_create_helper_check(
        without_buffer: FLA_Bool,
        datatype: FLA_Datatype,
        m: fla_dim_t,
        n: fla_dim_t,
        depth: fla_dim_t,
        b_m: *mut fla_dim_t,
        b_n: *mut fla_dim_t,
        H: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_Obj_create_hierarchy_check(
        datatype: FLA_Datatype,
        m: fla_dim_t,
        n: fla_dim_t,
        depth: fla_dim_t,
        elem_sizes_m: *mut fla_dim_t,
        elem_sizes_n: *mut fla_dim_t,
        flat_matrix: FLA_Obj,
        H: *mut FLA_Obj,
        id: c_ulong,
        depth_overall: fla_dim_t,
        depth_sizes_m: *mut fla_dim_t,
        depth_sizes_n: *mut fla_dim_t,
        m_offsets: *mut fla_dim_t,
        n_offsets: *mut fla_dim_t,
    ) -> FLA_Error;
    pub fn FLASH_Obj_create_conf_to_check(
        trans: FLA_Trans,
        H_cur: FLA_Obj,
        H_new: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_Obj_create_hier_conf_to_flat_check(
        trans: FLA_Trans,
        F: FLA_Obj,
        depth: fla_dim_t,
        b_mn: *mut fla_dim_t,
        H: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_Obj_create_hier_conf_to_flat_ext_check(
        trans: FLA_Trans,
        F: FLA_Obj,
        depth: fla_dim_t,
        b_m: *mut fla_dim_t,
        b_n: *mut fla_dim_t,
        H: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_Obj_create_flat_conf_to_hier_check(
        trans: FLA_Trans,
        H: FLA_Obj,
        F: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_Obj_create_hier_copy_of_flat_check(
        F: FLA_Obj,
        depth: fla_dim_t,
        b_mn: *mut fla_dim_t,
        H: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_Obj_create_hier_copy_of_flat_ext_check(
        F: FLA_Obj,
        depth: fla_dim_t,
        b_m: *mut fla_dim_t,
        b_n: *mut fla_dim_t,
        H: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_Obj_create_flat_copy_of_hier_check(H: FLA_Obj, F: *mut FLA_Obj) -> FLA_Error;
    pub fn FLASH_Obj_free_check(H: *mut FLA_Obj) -> FLA_Error;
    pub fn FLASH_Obj_free_without_buffer_check(H: *mut FLA_Obj) -> FLA_Error;
    pub fn FLASH_Obj_free_hierarchy_check(H: *mut FLA_Obj) -> FLA_Error;
    pub fn FLASH_Obj_attach_buffer_check(
        buffer: *mut c_void,
        rs: fla_dim_t,
        cs: fla_dim_t,
        H: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_Obj_attach_buffer_hierarchy_check(F: FLA_Obj, H: *mut FLA_Obj) -> FLA_Error;
    pub fn FLASH_Part_create_2x1(
        A: FLA_Obj,
        AT: *mut FLA_Obj,
        AB: *mut FLA_Obj,
        n_rows: fla_dim_t,
        side: FLA_Side,
    ) -> FLA_Error;
    pub fn FLASH_Part_create_1x2(
        A: FLA_Obj,
        AL: *mut FLA_Obj,
        AR: *mut FLA_Obj,
        n_cols: fla_dim_t,
        side: FLA_Side,
    ) -> FLA_Error;
    pub fn FLASH_Part_create_2x2(
        A: FLA_Obj,
        ATL: *mut FLA_Obj,
        ATR: *mut FLA_Obj,
        ABL: *mut FLA_Obj,
        ABR: *mut FLA_Obj,
        n_rows: fla_dim_t,
        n_cols: fla_dim_t,
        side: FLA_Side,
    ) -> FLA_Error;
    pub fn FLASH_Part_free_2x1(AT: *mut FLA_Obj, AB: *mut FLA_Obj) -> FLA_Error;
    pub fn FLASH_Part_free_1x2(AL: *mut FLA_Obj, AR: *mut FLA_Obj) -> FLA_Error;
    pub fn FLASH_Part_free_2x2(
        ATL: *mut FLA_Obj,
        ATR: *mut FLA_Obj,
        ABL: *mut FLA_Obj,
        ABR: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_Obj_adjust_views(
        attach_buffer: FLA_Bool,
        offm: fla_dim_t,
        offn: fla_dim_t,
        m: fla_dim_t,
        n: fla_dim_t,
        A: FLA_Obj,
        S: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_Obj_adjust_views_hierarchy(
        attach_buffer: FLA_Bool,
        offm: fla_dim_t,
        offn: fla_dim_t,
        m: fla_dim_t,
        n: fla_dim_t,
        A: FLA_Obj,
        S: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_Obj_scalar_length(H: FLA_Obj) -> fla_dim_t;
    pub fn FLASH_Obj_scalar_width(H: FLA_Obj) -> fla_dim_t;
    pub fn FLASH_Obj_scalar_min_dim(H: FLA_Obj) -> fla_dim_t;
    pub fn FLASH_Obj_scalar_max_dim(H: FLA_Obj) -> fla_dim_t;
    pub fn FLASH_Obj_scalar_vector_dim(H: FLA_Obj) -> fla_dim_t;
    pub fn FLASH_Obj_scalar_row_offset(H: FLA_Obj) -> fla_dim_t;
    pub fn FLASH_Obj_scalar_col_offset(H: FLA_Obj) -> fla_dim_t;
    pub fn FLASH_Obj_scalar_length_tl(H: FLA_Obj) -> fla_dim_t;
    pub fn FLASH_Obj_scalar_width_tl(H: FLA_Obj) -> fla_dim_t;
    pub fn FLASH_Obj_base_scalar_length(H: FLA_Obj) -> fla_dim_t;
    pub fn FLASH_Obj_base_scalar_width(H: FLA_Obj) -> fla_dim_t;
    pub fn FLASH_Obj_show(
        header: *mut c_char,
        H: FLA_Obj,
        elem_format: *mut c_char,
        footer: *mut c_char,
    ) -> FLA_Error;
    pub fn FLASH_Obj_show_hierarchy(
        H: FLA_Obj,
        i: fla_dim_t,
        elem_format: *mut c_char,
    ) -> FLA_Error;
    pub fn FLASH_Axpy_buffer_to_hier(
        alpha: FLA_Obj,
        m: fla_dim_t,
        n: fla_dim_t,
        buffer: *mut c_void,
        rs: fla_dim_t,
        cs: fla_dim_t,
        i: fla_dim_t,
        j: fla_dim_t,
        H: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_Axpy_hier_to_buffer(
        alpha: FLA_Obj,
        i: fla_dim_t,
        j: fla_dim_t,
        H: FLA_Obj,
        m: fla_dim_t,
        n: fla_dim_t,
        buffer: *mut c_void,
        rs: fla_dim_t,
        cs: fla_dim_t,
    ) -> FLA_Error;
    pub fn FLASH_Axpy_flat_to_hier(
        alpha: FLA_Obj,
        F: FLA_Obj,
        i: fla_dim_t,
        j: fla_dim_t,
        H: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_Axpy_hier_to_flat(
        alpha: FLA_Obj,
        i: fla_dim_t,
        j: fla_dim_t,
        H: FLA_Obj,
        F: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_Axpy_hierarchy(
        direction: c_int,
        alpha: FLA_Obj,
        F: FLA_Obj,
        H: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_Copy_buffer_to_hier(
        m: fla_dim_t,
        n: fla_dim_t,
        buffer: *mut c_void,
        rs: fla_dim_t,
        cs: fla_dim_t,
        i: fla_dim_t,
        j: fla_dim_t,
        H: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_Copy_hier_to_buffer(
        i: fla_dim_t,
        j: fla_dim_t,
        H: FLA_Obj,
        m: fla_dim_t,
        n: fla_dim_t,
        buffer: *mut c_void,
        rs: fla_dim_t,
        cs: fla_dim_t,
    ) -> FLA_Error;
    pub fn FLASH_Copy_flat_to_hier(F: FLA_Obj, i: fla_dim_t, j: fla_dim_t, H: FLA_Obj)
        -> FLA_Error;
    pub fn FLASH_Copy_hier_to_flat(i: fla_dim_t, j: fla_dim_t, H: FLA_Obj, F: FLA_Obj)
        -> FLA_Error;
    pub fn FLASH_Copy_hierarchy(
        direction: c_int,
        F: FLA_Obj,
        H: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_Obj_datatype(H: FLA_Obj) -> FLA_Datatype;
    pub fn FLASH_Obj_depth(H: FLA_Obj) -> fla_dim_t;
    pub fn FLASH_Obj_blocksizes(H: FLA_Obj, b_m: *mut fla_dim_t, b_n: *mut fla_dim_t) -> fla_dim_t;
    pub fn FLASH_Obj_create(
        datatype: FLA_Datatype,
        m: fla_dim_t,
        n: fla_dim_t,
        depth: fla_dim_t,
        b_mn: *mut fla_dim_t,
        H: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_Obj_create_ext(
        datatype: FLA_Datatype,
        m: fla_dim_t,
        n: fla_dim_t,
        depth: fla_dim_t,
        b_m: *mut fla_dim_t,
        b_n: *mut fla_dim_t,
        H: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_Obj_create_without_buffer(
        datatype: FLA_Datatype,
        m: fla_dim_t,
        n: fla_dim_t,
        depth: fla_dim_t,
        b_mn: *mut fla_dim_t,
        H: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_Obj_create_without_buffer_ext(
        datatype: FLA_Datatype,
        m: fla_dim_t,
        n: fla_dim_t,
        depth: fla_dim_t,
        b_m: *mut fla_dim_t,
        b_n: *mut fla_dim_t,
        H: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_Obj_create_helper(
        without_buffer: FLA_Bool,
        datatype: FLA_Datatype,
        m: fla_dim_t,
        n: fla_dim_t,
        depth: fla_dim_t,
        b_m: *mut fla_dim_t,
        b_n: *mut fla_dim_t,
        H: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_Obj_create_hierarchy(
        datatype: FLA_Datatype,
        m: fla_dim_t,
        n: fla_dim_t,
        depth: fla_dim_t,
        elem_sizes_m: *mut fla_dim_t,
        elem_sizes_n: *mut fla_dim_t,
        flat_matrix: FLA_Obj,
        H: *mut FLA_Obj,
        id: c_ulong,
        depth_overall: fla_dim_t,
        depth_sizes_m: *mut fla_dim_t,
        depth_sizes_n: *mut fla_dim_t,
        m_offsets: *mut fla_dim_t,
        n_offsets: *mut fla_dim_t,
    ) -> FLA_Error;
    pub fn FLASH_Obj_create_conf_to(
        trans: FLA_Trans,
        H_cur: FLA_Obj,
        H_new: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_Obj_create_hier_conf_to_flat(
        trans: FLA_Trans,
        F: FLA_Obj,
        depth: fla_dim_t,
        b_mn: *mut fla_dim_t,
        H: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_Obj_create_hier_conf_to_flat_ext(
        trans: FLA_Trans,
        F: FLA_Obj,
        depth: fla_dim_t,
        b_m: *mut fla_dim_t,
        b_n: *mut fla_dim_t,
        H: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_Obj_create_flat_conf_to_hier(
        trans: FLA_Trans,
        H: FLA_Obj,
        F: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_Obj_create_copy_of(
        trans: FLA_Trans,
        H_cur: FLA_Obj,
        H_new: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_Obj_create_hier_copy_of_flat(
        F: FLA_Obj,
        depth: fla_dim_t,
        b_mn: *mut fla_dim_t,
        H: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_Obj_create_hier_copy_of_flat_ext(
        F: FLA_Obj,
        depth: fla_dim_t,
        b_m: *mut fla_dim_t,
        b_n: *mut fla_dim_t,
        H: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_Obj_create_flat_copy_of_hier(H: FLA_Obj, F: *mut FLA_Obj) -> FLA_Error;
    pub fn FLASH_Obj_free(H: *mut FLA_Obj);
    pub fn FLASH_Obj_free_hierarchy(H: *mut FLA_Obj);
    pub fn FLASH_Obj_free_without_buffer(H: *mut FLA_Obj);
    pub fn FLASH_Obj_attach_buffer(
        buffer: *mut c_void,
        rs: fla_dim_t,
        cs: fla_dim_t,
        H: *mut FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_Obj_attach_buffer_hierarchy(F: FLA_Obj, H: *mut FLA_Obj) -> FLA_Error;
    pub fn FLASH_Obj_flatten(H: FLA_Obj, F: FLA_Obj) -> FLA_Error;
    pub fn FLASH_Obj_hierarchify(F: FLA_Obj, H: FLA_Obj) -> FLA_Error;
    pub fn FLASH_Obj_extract_buffer(H: FLA_Obj) -> *mut c_void;
    pub fn FLASH_print_struct(H: FLA_Obj);
    pub fn FLASH_print_struct_helper(H: FLA_Obj, indent: c_int);
    pub fn FLASH_Max_elemwise_diff(A: FLA_Obj, B: FLA_Obj) -> f64;
    pub fn FLASH_Random_matrix(H: FLA_Obj) -> FLA_Error;
    pub fn FLASH_Random_spd_matrix(uplo: FLA_Uplo, H: FLA_Obj) -> FLA_Error;
    pub fn FLASH_Norm1(H: FLA_Obj, norm: FLA_Obj) -> FLA_Error;
    pub fn FLASH_Obj_shift_diagonal(conj: FLA_Conj, sigma: FLA_Obj, H: FLA_Obj) -> FLA_Error;
    pub fn FLASH_Set(alpha: FLA_Obj, H: FLA_Obj) -> FLA_Error;
    pub fn FLASH_Obj_create_diag_panel(A: FLA_Obj, U: *mut FLA_Obj) -> FLA_Error;
    pub fn FLASH_LU_find_zero_on_diagonal(A: FLA_Obj) -> FLA_Error;
    pub fn FLASH_Triangularize(uplo: FLA_Uplo, diag: FLA_Diag, A: FLA_Obj) -> FLA_Error;
    pub fn FLASH_Hermitianize(uplo: FLA_Uplo, A: FLA_Obj) -> FLA_Error;
    pub fn FLASH_LU_find_zero_on_diagonal_check(A: FLA_Obj) -> FLA_Error;
    pub fn FLASH_Axpy(alpha: FLA_Obj, A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLASH_Axpyt(trans: FLA_Trans, alpha: FLA_Obj, A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLASH_Copy(A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLASH_Copyt(trans: FLA_Trans, A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLASH_Scal(alpha: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLASH_Scalr(uplo: FLA_Uplo, alpha: FLA_Obj, A: FLA_Obj) -> FLA_Error;
    pub fn FLASH_Gemv(
        transa: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        x: FLA_Obj,
        beta: FLA_Obj,
        y: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_Trsv(
        uplo: FLA_Uplo,
        transa: FLA_Trans,
        diag: FLA_Diag,
        A: FLA_Obj,
        x: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_Gemm(
        transa: FLA_Trans,
        transb: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_Hemm(
        side: FLA_Side,
        uplo: FLA_Uplo,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_Herk(
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_Her2k(
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_Symm(
        side: FLA_Side,
        uplo: FLA_Uplo,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_Syrk(
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_Syr2k(
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        beta: FLA_Obj,
        C: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_Trmm(
        side: FLA_Side,
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_Trsm(
        side: FLA_Side,
        uplo: FLA_Uplo,
        trans: FLA_Trans,
        diag: FLA_Diag,
        alpha: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_Chol(uplo: FLA_Uplo, A: FLA_Obj) -> FLA_Error;
    pub fn FLASH_LU_nopiv(A: FLA_Obj) -> FLA_Error;
    pub fn FLASH_LU_piv(A: FLA_Obj, p: FLA_Obj) -> FLA_Error;
    pub fn FLASH_LU_incpiv(A: FLA_Obj, p: FLA_Obj, L: FLA_Obj) -> FLA_Error;
    pub fn FLASH_FS_incpiv(A: FLA_Obj, p: FLA_Obj, L: FLA_Obj, b: FLA_Obj) -> FLA_Error;
    pub fn FLASH_Trinv(uplo: FLA_Uplo, diag: FLA_Diag, A: FLA_Obj) -> FLA_Error;
    pub fn FLASH_Ttmm(uplo: FLA_Uplo, A: FLA_Obj) -> FLA_Error;
    pub fn FLASH_SPDinv(uplo: FLA_Uplo, A: FLA_Obj) -> FLA_Error;
    pub fn FLASH_Sylv(
        transa: FLA_Trans,
        transb: FLA_Trans,
        isgn: FLA_Obj,
        A: FLA_Obj,
        B: FLA_Obj,
        C: FLA_Obj,
        scale: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_Apply_pivots(
        side: FLA_Side,
        trans: FLA_Trans,
        p: FLA_Obj,
        A: FLA_Obj,
    ) -> FLA_Error;
    pub fn FLASH_Eig_gest(inv: FLA_Inv, uplo: FLA_Uplo, A: FLA_Obj, B: FLA_Obj) -> FLA_Error;
    pub fn FLASH_LQ_UT_inv(A: FLA_Obj, TW: FLA_Obj) -> FLA_Error;
    pub fn FLASH_LQ2_UT(B: FLA_Obj, C: FLA_Obj, T: FLA_Obj) -> FLA_Error;
    pub fn FLASH_Queue_begin();
    pub fn FLASH_Queue_end();
    pub fn FLASH_Queue_stack_depth() -> uinteger;
    pub fn FLASH_Queue_enable() -> FLA_Error;
    pub fn FLASH_Queue_disable() -> FLA_Error;
    pub fn FLASH_Queue_get_enabled() -> FLA_Bool;
    pub fn FLASH_Queue_set_num_threads(n_threads: uinteger);
    pub fn FLASH_Queue_get_num_threads() -> uinteger;
    pub fn cgelst_(
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn clatrs3_(
        uplo: *mut c_char,
        trans: *mut c_char,
        diag: *mut c_char,
        normin: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        x: *mut scomplex,
        ldx: *mut integer,
        scale: *mut real,
        cnorm: *mut real,
        work: *mut real,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn ctrsyl3_(
        trana: *mut c_char,
        tranb: *mut c_char,
        isgn: *mut integer,
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        c__: *mut scomplex,
        ldc: *mut integer,
        scale: *mut real,
        swork: *mut real,
        ldswork: *mut integer,
        info: *mut integer,
    );
    pub fn dgelst_(
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut doublereal,
        lda: *mut integer,
        b: *mut doublereal,
        ldb: *mut integer,
        work: *mut doublereal,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dlarmm_(
        anorm: *mut doublereal,
        bnorm: *mut doublereal,
        cnorm: *mut doublereal,
    ) -> doublereal;
    pub fn dlatrs3_(
        uplo: *mut c_char,
        trans: *mut c_char,
        diag: *mut c_char,
        normin: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut doublereal,
        lda: *mut integer,
        x: *mut doublereal,
        ldx: *mut integer,
        scale: *mut doublereal,
        cnorm: *mut doublereal,
        work: *mut doublereal,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dtrsyl3_(
        trana: *mut c_char,
        tranb: *mut c_char,
        isgn: *mut integer,
        m: *mut integer,
        n: *mut integer,
        a: *mut doublereal,
        lda: *mut integer,
        b: *mut doublereal,
        ldb: *mut integer,
        c__: *mut doublereal,
        ldc: *mut integer,
        scale: *mut doublereal,
        iwork: *mut integer,
        liwork: *mut integer,
        swork: *mut doublereal,
        ldswork: *mut integer,
        info: *mut integer,
    );
    pub fn sgelst_(
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut real,
        lda: *mut integer,
        b: *mut real,
        ldb: *mut integer,
        work: *mut real,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn slarmm_(anorm: *mut real, bnorm: *mut real, cnorm: *mut real) -> real;
    pub fn slatrs3_(
        uplo: *mut c_char,
        trans: *mut c_char,
        diag: *mut c_char,
        normin: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut real,
        lda: *mut integer,
        x: *mut real,
        ldx: *mut integer,
        scale: *mut real,
        cnorm: *mut real,
        work: *mut real,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn strsyl3_(
        trana: *mut c_char,
        tranb: *mut c_char,
        isgn: *mut integer,
        m: *mut integer,
        n: *mut integer,
        a: *mut real,
        lda: *mut integer,
        b: *mut real,
        ldb: *mut integer,
        c__: *mut real,
        ldc: *mut integer,
        scale: *mut real,
        iwork: *mut integer,
        liwork: *mut integer,
        swork: *mut real,
        ldswork: *mut integer,
        info: *mut integer,
    );
    pub fn zgelst_(
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zlatrs3_(
        uplo: *mut c_char,
        trans: *mut c_char,
        diag: *mut c_char,
        normin: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        x: *mut dcomplex,
        ldx: *mut integer,
        scale: *mut doublereal,
        cnorm: *mut doublereal,
        work: *mut doublereal,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn ztrsyl3_(
        trana: *mut c_char,
        tranb: *mut c_char,
        isgn: *mut integer,
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        c__: *mut dcomplex,
        ldc: *mut integer,
        scale: *mut doublereal,
        swork: *mut doublereal,
        ldswork: *mut integer,
        info: *mut integer,
    );
    pub fn dlamch_(cmach: *mut c_char) -> f64;
    pub fn dlamc3_(a: *mut f64, b: *mut f64) -> f64;
    pub fn dladiv2_(
        a: *mut doublereal,
        b: *mut doublereal,
        c__: *mut doublereal,
        d__: *mut doublereal,
        r__: *mut doublereal,
        t: *mut doublereal,
    ) -> doublereal;
    pub fn dladiv1_(
        a: *mut doublereal,
        b: *mut doublereal,
        c__: *mut doublereal,
        d__: *mut doublereal,
        p: *mut doublereal,
        q: *mut doublereal,
    );
    pub fn sladiv2_(b: *mut f32, c: *mut f32, d: *mut f32, r: *mut f32, t: *mut f32) -> f64;
    pub fn sladiv1_(a: *mut f32, b: *mut f32, c: *mut f32, d: *mut f32, p: *mut f32, q: *mut f32);
    pub fn iparmq_(
        ispec: *mut integer,
        name: *mut c_char,
        opts: *mut c_char,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        lwork: *mut integer,
    ) -> integer;
    pub fn ilaenv_(
        ispec: *mut integer,
        name: *mut c_char,
        opts: *mut c_char,
        n1: *mut integer,
        n2: *mut integer,
        n3: *mut integer,
        n4: *mut integer,
    ) -> integer;
    pub fn ieeeck_(ispec: *mut integer, zero: *mut f32, one: *mut f32) -> integer;
    pub fn lsamen_(
        n: *const integer,
        ca: *const c_char,
        cb: *const c_char,
        ca_len: integer,
        cb_len: integer,
    ) -> logical;
    pub fn slamc3_(a: *mut f32, b: *mut f32) -> f32;
    pub fn slamch_(cmach: *mut c_char) -> f32;
    pub fn cgetsqrhrt_(
        m: *mut integer,
        n: *mut integer,
        mb1: *mut integer,
        nb1: *mut integer,
        nb2: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        t: *mut scomplex,
        ldt: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn claqz0_(
        wants: *mut c_char,
        wantq: *mut c_char,
        wantz: *mut c_char,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        alpha: *mut scomplex,
        beta: *mut scomplex,
        q: *mut scomplex,
        ldq: *mut integer,
        z__: *mut scomplex,
        ldz: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut real,
        rec: *mut integer,
        info: *mut integer,
    );
    pub fn claqz1_(
        ilq: *mut logical,
        ilz: *mut logical,
        k: *mut integer,
        istartm: *mut integer,
        istopm: *mut integer,
        ihi: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        nq: *mut integer,
        qstart: *mut integer,
        q: *mut scomplex,
        ldq: *mut integer,
        nz: *mut integer,
        zstart: *mut integer,
        z__: *mut scomplex,
        ldz: *mut integer,
    );
    pub fn claqz2_(
        ilschur: *mut logical,
        ilq: *mut logical,
        ilz: *mut logical,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        nw: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        q: *mut scomplex,
        ldq: *mut integer,
        z__: *mut scomplex,
        ldz: *mut integer,
        ns: *mut integer,
        nd: *mut integer,
        alpha: *mut scomplex,
        beta: *mut scomplex,
        qc: *mut scomplex,
        ldqc: *mut integer,
        zc: *mut scomplex,
        ldzc: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut real,
        rec: *mut integer,
        info: *mut integer,
    );
    pub fn claqz3_(
        ilschur: *mut logical,
        ilq: *mut logical,
        ilz: *mut logical,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        nshifts: *mut integer,
        nblock_desired__: *mut integer,
        alpha: *mut scomplex,
        beta: *mut scomplex,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        q: *mut scomplex,
        ldq: *mut integer,
        z__: *mut scomplex,
        ldz: *mut integer,
        qc: *mut scomplex,
        ldqc: *mut integer,
        zc: *mut scomplex,
        ldzc: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn clarfb_gett_(
        ident: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        t: *mut scomplex,
        ldt: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        work: *mut scomplex,
        ldwork: *mut integer,
    );
    pub fn cungtsqr_row_(
        m: *mut integer,
        n: *mut integer,
        mb: *mut integer,
        nb: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        t: *mut scomplex,
        ldt: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dgetsqrhrt_(
        m: *mut integer,
        n: *mut integer,
        mb1: *mut integer,
        nb1: *mut integer,
        nb2: *mut integer,
        a: *mut doublereal,
        lda: *mut integer,
        t: *mut doublereal,
        ldt: *mut integer,
        work: *mut doublereal,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dlaqz0_(
        wants: *mut c_char,
        wantq: *mut c_char,
        wantz: *mut c_char,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        a: *mut doublereal,
        lda: *mut integer,
        b: *mut doublereal,
        ldb: *mut integer,
        alphar: *mut doublereal,
        alphai: *mut doublereal,
        beta: *mut doublereal,
        q: *mut doublereal,
        ldq: *mut integer,
        z__: *mut doublereal,
        ldz: *mut integer,
        work: *mut doublereal,
        lwork: *mut integer,
        rec: *mut integer,
        info: *mut integer,
    );
    pub fn dlaqz1_(
        a: *mut doublereal,
        lda: *mut integer,
        b: *mut doublereal,
        ldb: *mut integer,
        sr1: *mut doublereal,
        sr2: *mut doublereal,
        si: *mut doublereal,
        beta1: *mut doublereal,
        beta2: *mut doublereal,
        v: *mut doublereal,
    );
    pub fn dlaqz2_(
        ilq: *mut logical,
        ilz: *mut logical,
        k: *mut integer,
        istartm: *mut integer,
        istopm: *mut integer,
        ihi: *mut integer,
        a: *mut doublereal,
        lda: *mut integer,
        b: *mut doublereal,
        ldb: *mut integer,
        nq: *mut integer,
        qstart: *mut integer,
        q: *mut doublereal,
        ldq: *mut integer,
        nz: *mut integer,
        zstart: *mut integer,
        z__: *mut doublereal,
        ldz: *mut integer,
    );
    pub fn dlaqz3_(
        ilschur: *mut logical,
        ilq: *mut logical,
        ilz: *mut logical,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        nw: *mut integer,
        a: *mut doublereal,
        lda: *mut integer,
        b: *mut doublereal,
        ldb: *mut integer,
        q: *mut doublereal,
        ldq: *mut integer,
        z__: *mut doublereal,
        ldz: *mut integer,
        ns: *mut integer,
        nd: *mut integer,
        alphar: *mut doublereal,
        alphai: *mut doublereal,
        beta: *mut doublereal,
        qc: *mut doublereal,
        ldqc: *mut integer,
        zc: *mut doublereal,
        ldzc: *mut integer,
        work: *mut doublereal,
        lwork: *mut integer,
        rec: *mut integer,
        info: *mut integer,
    );
    pub fn dlaqz4_(
        ilschur: *mut logical,
        ilq: *mut logical,
        ilz: *mut logical,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        nshifts: *mut integer,
        nblock_desired__: *mut integer,
        sr: *mut doublereal,
        si: *mut doublereal,
        ss: *mut doublereal,
        a: *mut doublereal,
        lda: *mut integer,
        b: *mut doublereal,
        ldb: *mut integer,
        q: *mut doublereal,
        ldq: *mut integer,
        z__: *mut doublereal,
        ldz: *mut integer,
        qc: *mut doublereal,
        ldqc: *mut integer,
        zc: *mut doublereal,
        ldzc: *mut integer,
        work: *mut doublereal,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dlarfb_gett_(
        ident: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        t: *mut doublereal,
        ldt: *mut integer,
        a: *mut doublereal,
        lda: *mut integer,
        b: *mut doublereal,
        ldb: *mut integer,
        work: *mut doublereal,
        ldwork: *mut integer,
    );
    pub fn dorgtsqr_row_(
        m: *mut integer,
        n: *mut integer,
        mb: *mut integer,
        nb: *mut integer,
        a: *mut doublereal,
        lda: *mut integer,
        t: *mut doublereal,
        ldt: *mut integer,
        work: *mut doublereal,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sgetsqrhrt_(
        m: *mut integer,
        n: *mut integer,
        mb1: *mut integer,
        nb1: *mut integer,
        nb2: *mut integer,
        a: *mut real,
        lda: *mut integer,
        t: *mut real,
        ldt: *mut integer,
        work: *mut real,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn slaqz0_(
        wants: *mut c_char,
        wantq: *mut c_char,
        wantz: *mut c_char,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        a: *mut real,
        lda: *mut integer,
        b: *mut real,
        ldb: *mut integer,
        alphar: *mut real,
        alphai: *mut real,
        beta: *mut real,
        q: *mut real,
        ldq: *mut integer,
        z__: *mut real,
        ldz: *mut integer,
        work: *mut real,
        lwork: *mut integer,
        rec: *mut integer,
        info: *mut integer,
    );
    pub fn slaqz1_(
        a: *mut real,
        lda: *mut integer,
        b: *mut real,
        ldb: *mut integer,
        sr1: *mut real,
        sr2: *mut real,
        si: *mut real,
        beta1: *mut real,
        beta2: *mut real,
        v: *mut real,
    );
    pub fn slaqz2_(
        ilq: *mut logical,
        ilz: *mut logical,
        k: *mut integer,
        istartm: *mut integer,
        istopm: *mut integer,
        ihi: *mut integer,
        a: *mut real,
        lda: *mut integer,
        b: *mut real,
        ldb: *mut integer,
        nq: *mut integer,
        qstart: *mut integer,
        q: *mut real,
        ldq: *mut integer,
        nz: *mut integer,
        zstart: *mut integer,
        z__: *mut real,
        ldz: *mut integer,
    );
    pub fn slaqz3_(
        ilschur: *mut logical,
        ilq: *mut logical,
        ilz: *mut logical,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        nw: *mut integer,
        a: *mut real,
        lda: *mut integer,
        b: *mut real,
        ldb: *mut integer,
        q: *mut real,
        ldq: *mut integer,
        z__: *mut real,
        ldz: *mut integer,
        ns: *mut integer,
        nd: *mut integer,
        alphar: *mut real,
        alphai: *mut real,
        beta: *mut real,
        qc: *mut real,
        ldqc: *mut integer,
        zc: *mut real,
        ldzc: *mut integer,
        work: *mut real,
        lwork: *mut integer,
        rec: *mut integer,
        info: *mut integer,
    );
    pub fn slaqz4_(
        ilschur: *mut logical,
        ilq: *mut logical,
        ilz: *mut logical,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        nshifts: *mut integer,
        nblock_desired__: *mut integer,
        sr: *mut real,
        si: *mut real,
        ss: *mut real,
        a: *mut real,
        lda: *mut integer,
        b: *mut real,
        ldb: *mut integer,
        q: *mut real,
        ldq: *mut integer,
        z__: *mut real,
        ldz: *mut integer,
        qc: *mut real,
        ldqc: *mut integer,
        zc: *mut real,
        ldzc: *mut integer,
        work: *mut real,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn slarfb_gett_(
        ident: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        t: *mut real,
        ldt: *mut integer,
        a: *mut real,
        lda: *mut integer,
        b: *mut real,
        ldb: *mut integer,
        work: *mut real,
        ldwork: *mut integer,
    );
    pub fn sorgtsqr_row_(
        m: *mut integer,
        n: *mut integer,
        mb: *mut integer,
        nb: *mut integer,
        a: *mut real,
        lda: *mut integer,
        t: *mut real,
        ldt: *mut integer,
        work: *mut real,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zgetsqrhrt_(
        m: *mut integer,
        n: *mut integer,
        mb1: *mut integer,
        nb1: *mut integer,
        nb2: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        t: *mut dcomplex,
        ldt: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zlaqz0_(
        wants: *mut c_char,
        wantq: *mut c_char,
        wantz: *mut c_char,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        alpha: *mut dcomplex,
        beta: *mut dcomplex,
        q: *mut dcomplex,
        ldq: *mut integer,
        z__: *mut dcomplex,
        ldz: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut doublereal,
        rec: *mut integer,
        info: *mut integer,
    );
    pub fn zlaqz1_(
        ilq: *mut logical,
        ilz: *mut logical,
        k: *mut integer,
        istartm: *mut integer,
        istopm: *mut integer,
        ihi: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        nq: *mut integer,
        qstart: *mut integer,
        q: *mut dcomplex,
        ldq: *mut integer,
        nz: *mut integer,
        zstart: *mut integer,
        z__: *mut dcomplex,
        ldz: *mut integer,
    );
    pub fn zlaqz2_(
        ilschur: *mut logical,
        ilq: *mut logical,
        ilz: *mut logical,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        nw: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        q: *mut dcomplex,
        ldq: *mut integer,
        z__: *mut dcomplex,
        ldz: *mut integer,
        ns: *mut integer,
        nd: *mut integer,
        alpha: *mut dcomplex,
        beta: *mut dcomplex,
        qc: *mut dcomplex,
        ldqc: *mut integer,
        zc: *mut dcomplex,
        ldzc: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut doublereal,
        rec: *mut integer,
        info: *mut integer,
    );
    pub fn zlaqz3_(
        ilschur: *mut logical,
        ilq: *mut logical,
        ilz: *mut logical,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        nshifts: *mut integer,
        nblock_desired__: *mut integer,
        alpha: *mut dcomplex,
        beta: *mut dcomplex,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        q: *mut dcomplex,
        ldq: *mut integer,
        z__: *mut dcomplex,
        ldz: *mut integer,
        qc: *mut dcomplex,
        ldqc: *mut integer,
        zc: *mut dcomplex,
        ldzc: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zlarfb_gett_(
        ident: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        t: *mut dcomplex,
        ldt: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        work: *mut dcomplex,
        ldwork: *mut integer,
    );
    pub fn zungtsqr_row_(
        m: *mut integer,
        n: *mut integer,
        mb: *mut integer,
        nb: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        t: *mut dcomplex,
        ldt: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dla_gbrcond_(
        trans: *mut c_char,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        ab: *mut f64,
        ldab: *mut integer,
        afb: *mut f64,
        ldafb: *mut integer,
        ipiv: *mut integer,
        cmode: *mut integer,
        c: *mut f64,
        info: *mut integer,
        work: *mut f64,
        iwork: *mut integer,
    ) -> f64;
    pub fn dla_gbrpvgrw_(
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        ncols: *mut integer,
        ab: *mut f64,
        ldab: *mut integer,
        afb: *mut f64,
        ldafb: *mut integer,
    ) -> f64;
    pub fn dla_gercond_(
        trans: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        af: *mut f64,
        ldaf: *mut integer,
        ipiv: *mut integer,
        cmode: *mut integer,
        c: *mut f64,
        info: *mut integer,
        work: *mut f64,
        iwork: *mut integer,
    ) -> f64;
    pub fn dla_gerpvgrw_(
        n: *mut integer,
        ncols: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        af: *mut f64,
        ldaf: *mut integer,
    ) -> f64;
    pub fn dlangb_(
        norm: *mut c_char,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        ab: *mut f64,
        ldab: *mut integer,
        work: *mut f64,
    ) -> f64;
    pub fn dlange_(
        norm: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        work: *mut f64,
    ) -> f64;
    pub fn dlangt_(
        norm: *mut c_char,
        n: *mut integer,
        dl: *mut f64,
        d: *mut f64,
        du: *mut f64,
    ) -> f64;
    pub fn dlanhs_(
        norm: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        work: *mut f64,
    ) -> f64;
    pub fn dlansb_(
        norm: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        k: *mut integer,
        ab: *mut f64,
        ldab: *mut integer,
        work: *mut f64,
    ) -> f64;
    pub fn dlansf_(
        norm: *mut c_char,
        transr: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        work: *mut f64,
    ) -> f64;
    pub fn dlansp_(
        norm: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut f64,
        work: *mut f64,
    ) -> f64;
    pub fn dlanst_(
        norm: *mut c_char,
        n: *mut integer,
        d: *mut f64,
        e: *mut f64,
    ) -> f64;
    pub fn dlansy_(
        norm: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        work: *mut f64,
    ) -> f64;
    pub fn dlantb_(
        norm: *mut c_char,
        uplo: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        k: *mut integer,
        ab: *mut f64,
        ldab: *mut integer,
        work: *mut f64,
    ) -> f64;
    pub fn dlantp_(
        norm: *mut c_char,
        uplo: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        ap: *mut f64,
        work: *mut f64,
    ) -> f64;
    pub fn dlantr_(
        norm: *mut c_char,
        uplo: *mut c_char,
        diag: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        work: *mut f64,
    ) -> f64;
    pub fn dla_porcond_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        af: *mut f64,
        ldaf: *mut integer,
        cmode: *mut integer,
        c: *mut f64,
        info: *mut integer,
        work: *mut f64,
        iwork: *mut integer,
    ) -> f64;
    pub fn dla_porpvgrw_(
        uplo: *mut c_char,
        ncols: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        af: *mut f64,
        ldaf: *mut integer,
        work: *mut f64,
    ) -> f64;
    pub fn dlapy2_(x: *mut f64, y: *mut f64) -> f64;
    pub fn dlapy3_(x: *mut f64, y: *mut f64, z__: *mut f64) -> f64;
    pub fn dla_syrcond_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        af: *mut f64,
        ldaf: *mut integer,
        ipiv: *mut integer,
        cmode: *mut integer,
        c: *mut f64,
        info: *mut integer,
        work: *mut f64,
        iwork: *mut integer,
    ) -> f64;
    pub fn dla_syrpvgrw_(
        uplo: *mut c_char,
        n: *mut integer,
        info: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        af: *mut f64,
        ldaf: *mut integer,
        ipiv: *mut integer,
        work: *mut f64,
    ) -> f64;
    pub fn dzsum1_(n: *mut integer, cx: *mut dcomplex, incx: *mut integer) -> f64;
    pub fn zla_gbrcond_c_(
        trans: *mut c_char,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        afb: *mut dcomplex,
        ldafb: *mut integer,
        ipiv: *mut integer,
        c: *mut f64,
        capply: *mut logical,
        info: *mut integer,
        work: *mut dcomplex,
        rwork: *mut f64,
    ) -> f64;
    pub fn zla_gbrcond_x_(
        trans: *mut c_char,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        afb: *mut dcomplex,
        ldafb: *mut integer,
        ipiv: *mut integer,
        x: *mut dcomplex,
        info: *mut integer,
        work: *mut dcomplex,
        rwork: *mut f64,
    ) -> f64;
    pub fn zla_gbrpvgrw_(
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        ncols: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        afb: *mut dcomplex,
        ldafb: *mut integer,
    ) -> f64;
    pub fn zla_gercond_c_(
        trans: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        af: *mut dcomplex,
        ldaf: *mut integer,
        ipiv: *mut integer,
        c: *mut f64,
        capply: *mut logical,
        info: *mut integer,
        work: *mut dcomplex,
        rwork: *mut f64,
    ) -> f64;
    pub fn zla_gercond_x_(
        trans: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        af: *mut dcomplex,
        ldaf: *mut integer,
        ipiv: *mut integer,
        x: *mut dcomplex,
        info: *mut integer,
        work: *mut dcomplex,
        rwork: *mut f64,
    ) -> f64;
    pub fn zla_gerpvgrw_(
        n: *mut integer,
        ncols: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        af: *mut dcomplex,
        ldaf: *mut integer,
    ) -> f64;
    pub fn zla_hercond_c_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        af: *mut dcomplex,
        ldaf: *mut integer,
        ipiv: *mut integer,
        c: *mut f64,
        capply: *mut logical,
        info: *mut integer,
        work: *mut dcomplex,
        rwork: *mut f64,
    ) -> f64;
    pub fn zla_hercond_x_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        af: *mut dcomplex,
        ldaf: *mut integer,
        ipiv: *mut integer,
        x: *mut dcomplex,
        info: *mut integer,
        work: *mut dcomplex,
        rwork: *mut f64,
    ) -> f64;
    pub fn zla_herpvgrw_(
        uplo: *mut c_char,
        n: *mut integer,
        info: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        af: *mut dcomplex,
        ldaf: *mut integer,
        ipiv: *mut integer,
        work: *mut f64,
    ) -> f64;
    pub fn zlangb_(
        norm: *mut c_char,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        work: *mut f64,
    ) -> f64;
    pub fn zlange_(
        norm: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        work: *mut f64,
    ) -> f64;
    pub fn zlangt_(
        norm: *mut c_char,
        n: *mut integer,
        dl: *mut dcomplex,
        d: *mut dcomplex,
        du: *mut dcomplex,
    ) -> f64;
    pub fn zlanhb_(
        norm: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        k: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        work: *mut f64,
    ) -> f64;
    pub fn zlanhe_(
        norm: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        work: *mut f64,
    ) -> f64;
    pub fn zlanhf_(
        norm: *mut c_char,
        transr: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        work: *mut f64,
    ) -> f64;
    pub fn zlanhp_(
        norm: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut dcomplex,
        work: *mut f64,
    ) -> f64;
    pub fn zlanhs_(
        norm: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        work: *mut f64,
    ) -> f64;
    pub fn zlanht_(
        norm: *mut c_char,
        n: *mut integer,
        d: *mut f64,
        e: *mut dcomplex,
    ) -> f64;
    pub fn zlansb_(
        norm: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        k: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        work: *mut f64,
    ) -> f64;
    pub fn zlansp_(
        norm: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut dcomplex,
        work: *mut f64,
    ) -> f64;
    pub fn zlansy_(
        norm: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        work: *mut f64,
    ) -> f64;
    pub fn zlantb_(
        norm: *mut c_char,
        uplo: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        k: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        work: *mut f64,
    ) -> f64;
    pub fn zlantp_(
        norm: *mut c_char,
        uplo: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        ap: *mut dcomplex,
        work: *mut f64,
    ) -> f64;
    pub fn zlantr_(
        norm: *mut c_char,
        uplo: *mut c_char,
        diag: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        work: *mut f64,
    ) -> f64;
    pub fn zla_porcond_c_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        af: *mut dcomplex,
        ldaf: *mut integer,
        c: *mut f64,
        capply: *mut logical,
        info: *mut integer,
        work: *mut dcomplex,
        rwork: *mut f64,
    ) -> f64;
    pub fn zla_porcond_x_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        af: *mut dcomplex,
        ldaf: *mut integer,
        x: *mut dcomplex,
        info: *mut integer,
        work: *mut dcomplex,
        rwork: *mut f64,
    ) -> f64;
    pub fn zla_porpvgrw_(
        uplo: *mut c_char,
        ncols: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        af: *mut dcomplex,
        ldaf: *mut integer,
        work: *mut f64,
    ) -> f64;
    pub fn zla_syrcond_c_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        af: *mut dcomplex,
        ldaf: *mut integer,
        ipiv: *mut integer,
        c: *mut f64,
        capply: *mut logical,
        info: *mut integer,
        work: *mut dcomplex,
        rwork: *mut f64,
    ) -> f64;
    pub fn zla_syrcond_x_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        af: *mut dcomplex,
        ldaf: *mut integer,
        ipiv: *mut integer,
        x: *mut dcomplex,
        info: *mut integer,
        work: *mut dcomplex,
        rwork: *mut f64,
    ) -> f64;
    pub fn zla_syrpvgrw_(
        uplo: *mut c_char,
        n: *mut integer,
        info: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        af: *mut dcomplex,
        ldaf: *mut integer,
        ipiv: *mut integer,
        work: *mut f64,
    ) -> f64;
    pub fn cla_gbrcond_c_(
        trans: *mut c_char,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        afb: *mut scomplex,
        ldafb: *mut integer,
        ipiv: *mut integer,
        c: *mut f32,
        capply: *mut logical,
        info: *mut integer,
        work: *mut scomplex,
        rwork: *mut f32,
    ) -> f32;
    pub fn cla_gbrcond_x_(
        trans: *mut c_char,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        afb: *mut scomplex,
        ldafb: *mut integer,
        ipiv: *mut integer,
        x: *mut scomplex,
        info: *mut integer,
        work: *mut scomplex,
        rwork: *mut f32,
    ) -> f32;
    pub fn cla_gbrpvgrw_(
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        ncols: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        afb: *mut scomplex,
        ldafb: *mut integer,
    ) -> f32;
    pub fn cla_gercond_c_(
        trans: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        af: *mut scomplex,
        ldaf: *mut integer,
        ipiv: *mut integer,
        c: *mut f32,
        capply: *mut logical,
        info: *mut integer,
        work: *mut scomplex,
        rwork: *mut f32,
    ) -> f32;
    pub fn cla_gercond_x_(
        trans: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        af: *mut scomplex,
        ldaf: *mut integer,
        ipiv: *mut integer,
        x: *mut scomplex,
        info: *mut integer,
        work: *mut scomplex,
        rwork: *mut f32,
    ) -> f32;
    pub fn cla_gerpvgrw_(
        n: *mut integer,
        ncols: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        af: *mut scomplex,
        ldaf: *mut integer,
    ) -> f32;
    pub fn cla_hercond_c_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        af: *mut scomplex,
        ldaf: *mut integer,
        ipiv: *mut integer,
        c: *mut f32,
        capply: *mut logical,
        info: *mut integer,
        work: *mut scomplex,
        rwork: *mut f32,
    ) -> f32;
    pub fn cla_hercond_x_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        af: *mut scomplex,
        ldaf: *mut integer,
        ipiv: *mut integer,
        x: *mut scomplex,
        info: *mut integer,
        work: *mut scomplex,
        rwork: *mut f32,
    ) -> f32;
    pub fn cla_herpvgrw_(
        uplo: *mut c_char,
        n: *mut integer,
        info: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        af: *mut scomplex,
        ldaf: *mut integer,
        ipiv: *mut integer,
        work: *mut f32,
    ) -> f32;
    pub fn clangb_(
        norm: *mut c_char,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        work: *mut f32,
    ) -> f32;
    pub fn clange_(
        norm: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        work: *mut f32,
    ) -> f32;
    pub fn clangt_(
        norm: *mut c_char,
        n: *mut integer,
        dl: *mut scomplex,
        d: *mut scomplex,
        du: *mut scomplex,
    ) -> f32;
    pub fn clanhb_(
        norm: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        k: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        work: *mut f32,
    ) -> f32;
    pub fn clanhe_(
        norm: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        work: *mut f32,
    ) -> f32;
    pub fn clanhf_(
        norm: *mut c_char,
        transr: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        work: *mut f32,
    ) -> f32;
    pub fn clanhp_(
        norm: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut scomplex,
        work: *mut f32,
    ) -> f32;
    pub fn clanhs_(
        norm: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        work: *mut f32,
    ) -> f32;
    pub fn clanht_(
        norm: *mut c_char,
        n: *mut integer,
        d: *mut f32,
        e: *mut scomplex,
    ) -> f32;
    pub fn clansb_(
        norm: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        k: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        work: *mut f32,
    ) -> f32;
    pub fn clansp_(
        norm: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut scomplex,
        work: *mut f32,
    ) -> f32;
    pub fn clansy_(
        norm: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        work: *mut f32,
    ) -> f32;
    pub fn clantb_(
        norm: *mut c_char,
        uplo: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        k: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        work: *mut f32,
    ) -> f32;
    pub fn clantp_(
        norm: *mut c_char,
        uplo: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        ap: *mut scomplex,
        work: *mut f32,
    ) -> f32;
    pub fn clantr_(
        norm: *mut c_char,
        uplo: *mut c_char,
        diag: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        work: *mut f32,
    ) -> f32;
    pub fn cla_porcond_c_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        af: *mut scomplex,
        ldaf: *mut integer,
        c: *mut f32,
        capply: *mut logical,
        info: *mut integer,
        work: *mut scomplex,
        rwork: *mut f32,
    ) -> f32;
    pub fn cla_porcond_x_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        af: *mut scomplex,
        ldaf: *mut integer,
        x: *mut scomplex,
        info: *mut integer,
        work: *mut scomplex,
        rwork: *mut f32,
    ) -> f32;
    pub fn cla_porpvgrw_(
        uplo: *mut c_char,
        ncols: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        af: *mut scomplex,
        ldaf: *mut integer,
        work: *mut f32,
    ) -> f32;
    pub fn cla_syrcond_c_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        af: *mut scomplex,
        ldaf: *mut integer,
        ipiv: *mut integer,
        c: *mut f32,
        capply: *mut logical,
        info: *mut integer,
        work: *mut scomplex,
        rwork: *mut f32,
    ) -> f32;
    pub fn cla_syrcond_x_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        af: *mut scomplex,
        ldaf: *mut integer,
        ipiv: *mut integer,
        x: *mut scomplex,
        info: *mut integer,
        work: *mut scomplex,
        rwork: *mut f32,
    ) -> f32;
    pub fn cla_syrpvgrw_(
        uplo: *mut c_char,
        n: *mut integer,
        info: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        af: *mut scomplex,
        ldaf: *mut integer,
        ipiv: *mut integer,
        work: *mut f32,
    ) -> f32;
    pub fn scsum1_(n: *mut integer, cx: *mut scomplex, incx: *mut integer) -> f32;
    pub fn sla_gbrcond_(
        trans: *mut c_char,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        ab: *mut f32,
        ldab: *mut integer,
        afb: *mut f32,
        ldafb: *mut integer,
        ipiv: *mut integer,
        cmode: *mut integer,
        c: *mut f32,
        info: *mut integer,
        work: *mut f32,
        iwork: *mut integer,
    ) -> f32;
    pub fn sla_gbrpvgrw_(
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        ncols: *mut integer,
        ab: *mut f32,
        ldab: *mut integer,
        afb: *mut f32,
        ldafb: *mut integer,
    ) -> f32;
    pub fn sla_gercond_(
        trans: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        af: *mut f32,
        ldaf: *mut integer,
        ipiv: *mut integer,
        cmode: *mut integer,
        c: *mut f32,
        info: *mut integer,
        work: *mut f32,
        iwork: *mut integer,
    ) -> f32;
    pub fn sla_gerpvgrw_(
        n: *mut integer,
        ncols: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        af: *mut f32,
        ldaf: *mut integer,
    ) -> f32;
    pub fn slangb_(
        norm: *mut c_char,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        ab: *mut f32,
        ldab: *mut integer,
        work: *mut f32,
    ) -> f32;
    pub fn slange_(
        norm: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        work: *mut f32,
    ) -> f32;
    pub fn slangt_(
        norm: *mut c_char,
        n: *mut integer,
        dl: *mut f32,
        d: *mut f32,
        du: *mut f32,
    ) -> f32;
    pub fn slanhs_(
        norm: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        work: *mut f32,
    ) -> f32;
    pub fn slansb_(
        norm: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        k: *mut integer,
        ab: *mut f32,
        ldab: *mut integer,
        work: *mut f32,
    ) -> f32;
    pub fn slansf_(
        norm: *mut c_char,
        transr: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        work: *mut f32,
    ) -> f32;
    pub fn slansp_(
        norm: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut f32,
        work: *mut f32,
    ) -> f32;
    pub fn slanst_(
        norm: *mut c_char,
        n: *mut integer,
        d: *mut f32,
        e: *mut f32,
    ) -> f32;
    pub fn slansy_(
        norm: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        work: *mut f32,
    ) -> f32;
    pub fn slantb_(
        norm: *mut c_char,
        uplo: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        k: *mut integer,
        ab: *mut f32,
        ldab: *mut integer,
        work: *mut f32,
    ) -> f32;
    pub fn slantp_(
        norm: *mut c_char,
        uplo: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        ap: *mut f32,
        work: *mut f32,
    ) -> f32;
    pub fn slantr_(
        norm: *mut c_char,
        uplo: *mut c_char,
        diag: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        work: *mut f32,
    ) -> f32;
    pub fn sla_porcond_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        af: *mut f32,
        ldaf: *mut integer,
        cmode: *mut integer,
        c: *mut f32,
        info: *mut integer,
        work: *mut f32,
        iwork: *mut integer,
    ) -> f32;
    pub fn sla_porpvgrw_(
        uplo: *mut c_char,
        ncols: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        af: *mut f32,
        ldaf: *mut integer,
        work: *mut f32,
    ) -> f32;
    pub fn slapy2_(x: *mut f32, y: *mut f32) -> f32;
    pub fn slapy3_(x: *mut f32, y: *mut f32, z__: *mut f32) -> f32;
    pub fn sla_syrcond_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        af: *mut f32,
        ldaf: *mut integer,
        ipiv: *mut integer,
        cmode: *mut integer,
        c: *mut f32,
        info: *mut integer,
        work: *mut f32,
        iwork: *mut integer,
    ) -> f32;
    pub fn sla_syrpvgrw_(
        uplo: *mut c_char,
        n: *mut integer,
        info: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        af: *mut f32,
        ldaf: *mut integer,
        ipiv: *mut integer,
        work: *mut f32,
    ) -> f32;
    pub fn cbbcsd_(
        jobu1: *mut c_char,
        jobu2: *mut c_char,
        jobv1t: *mut c_char,
        jobv2t: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        p: *mut integer,
        q: *mut integer,
        theta: *mut f32,
        phi: *mut f32,
        u1: *mut scomplex,
        ldu1: *mut integer,
        u2: *mut scomplex,
        ldu2: *mut integer,
        v1t: *mut scomplex,
        ldv1t: *mut integer,
        v2t: *mut scomplex,
        ldv2t: *mut integer,
        b11d: *mut f32,
        b11e: *mut f32,
        b12d: *mut f32,
        b12e: *mut f32,
        b21d: *mut f32,
        b21e: *mut f32,
        b22d: *mut f32,
        b22e: *mut f32,
        rwork: *mut f32,
        lrwork: *mut integer,
        info: *mut integer,
    );
    pub fn cbdsqr_(
        uplo: *mut c_char,
        n: *mut integer,
        ncvt: *mut integer,
        nru: *mut integer,
        ncc: *mut integer,
        d: *mut f32,
        e: *mut f32,
        vt: *mut scomplex,
        ldvt: *mut integer,
        u: *mut scomplex,
        ldu: *mut integer,
        c: *mut scomplex,
        ldc: *mut integer,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn cgbbrd_(
        vect: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        ncc: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        d: *mut f32,
        e: *mut f32,
        q: *mut scomplex,
        ldq: *mut integer,
        pt: *mut scomplex,
        ldpt: *mut integer,
        c: *mut scomplex,
        ldc: *mut integer,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn cgbcon_(
        norm: *mut c_char,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        ipiv: *mut integer,
        anorm: *mut f32,
        rcond: *mut f32,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn cgbequb_(
        m: *mut integer,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        r: *mut f32,
        c: *mut f32,
        rowcnd: *mut f32,
        colcnd: *mut f32,
        amax: *mut f32,
        info: *mut integer,
    );
    pub fn cgbequ_(
        m: *mut integer,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        r: *mut f32,
        c: *mut f32,
        rowcnd: *mut f32,
        colcnd: *mut f32,
        amax: *mut f32,
        info: *mut integer,
    );
    pub fn cgbrfs_(
        trans: *mut c_char,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        nrhs: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        afb: *mut scomplex,
        ldafb: *mut integer,
        ipiv: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        x: *mut scomplex,
        ldx: *mut integer,
        ferr: *mut f32,
        berr: *mut f32,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn cgbrfsx_(
        trans: *mut c_char,
        equed: *mut c_char,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        nrhs: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        afb: *mut scomplex,
        ldafb: *mut integer,
        ipiv: *mut integer,
        r: *mut f32,
        c: *mut f32,
        b: *mut scomplex,
        ldb: *mut integer,
        x: *mut scomplex,
        ldx: *mut integer,
        rcond: *mut f32,
        berr: *mut f32,
        n_err_bnds: *mut integer,
        err_bnds_norm: *mut f32,
        err_bnds_comp: *mut f32,
        nparams: *mut integer,
        params: *mut f32,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn cgbsv_(
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        nrhs: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        ipiv: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn cgbsvx_(
        fact: *mut c_char,
        trans: *mut c_char,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        nrhs: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        afb: *mut scomplex,
        ldafb: *mut integer,
        ipiv: *mut integer,
        equed: *mut c_char,
        r: *mut f32,
        c: *mut f32,
        b: *mut scomplex,
        ldb: *mut integer,
        x: *mut scomplex,
        ldx: *mut integer,
        rcond: *mut f32,
        ferr: *mut f32,
        berr: *mut f32,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn cgbsvxx_(
        fact: *mut c_char,
        trans: *mut c_char,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        nrhs: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        afb: *mut scomplex,
        ldafb: *mut integer,
        ipiv: *mut integer,
        equed: *mut c_char,
        r: *mut f32,
        c: *mut f32,
        b: *mut scomplex,
        ldb: *mut integer,
        x: *mut scomplex,
        ldx: *mut integer,
        rcond: *mut f32,
        rpvgrw: *mut f32,
        berr: *mut f32,
        n_err_bnds: *mut integer,
        err_bnds_norm: *mut f32,
        err_bnds_comp: *mut f32,
        nparams: *mut integer,
        params: *mut f32,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn cgbtf2_(
        m: *mut integer,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn cgbtrf_(
        m: *mut integer,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn cgbtrs_(
        trans: *mut c_char,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        nrhs: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        ipiv: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn cgebak_(
        job: *mut c_char,
        side: *mut c_char,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        scale: *mut f32,
        m: *mut integer,
        v: *mut scomplex,
        ldv: *mut integer,
        info: *mut integer,
    );
    pub fn cgebal_(
        job: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        scale: *mut f32,
        info: *mut integer,
    );
    pub fn cgebd2_(
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        d: *mut f32,
        e: *mut f32,
        tauq: *mut scomplex,
        taup: *mut scomplex,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn cgebrd_(
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        d: *mut f32,
        e: *mut f32,
        tauq: *mut scomplex,
        taup: *mut scomplex,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn cgecon_(
        norm: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        anorm: *mut f32,
        rcond: *mut f32,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn cgeequb_(
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        r: *mut f32,
        c: *mut f32,
        rowcnd: *mut f32,
        colcnd: *mut f32,
        amax: *mut f32,
        info: *mut integer,
    );
    pub fn cgeequ_(
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        r: *mut f32,
        c: *mut f32,
        rowcnd: *mut f32,
        colcnd: *mut f32,
        amax: *mut f32,
        info: *mut integer,
    );
    pub fn cgees_(
        jobvs: *mut c_char,
        sort: *mut c_char,
        select: L_fp,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        sdim: *mut integer,
        w: *mut scomplex,
        vs: *mut scomplex,
        ldvs: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        bwork: *mut logical,
        info: *mut integer,
    );
    pub fn cgeesx_(
        jobvs: *mut c_char,
        sort: *mut c_char,
        select: L_fp,
        sense: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        sdim: *mut integer,
        w: *mut scomplex,
        vs: *mut scomplex,
        ldvs: *mut integer,
        rconde: *mut f32,
        rcondv: *mut f32,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        bwork: *mut logical,
        info: *mut integer,
    );
    pub fn cgeev_(
        jobvl: *mut c_char,
        jobvr: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        w: *mut scomplex,
        vl: *mut scomplex,
        ldvl: *mut integer,
        vr: *mut scomplex,
        ldvr: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn cgeevx_(
        balanc: *mut c_char,
        jobvl: *mut c_char,
        jobvr: *mut c_char,
        sense: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        w: *mut scomplex,
        vl: *mut scomplex,
        ldvl: *mut integer,
        vr: *mut scomplex,
        ldvr: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        scale: *mut f32,
        abnrm: *mut f32,
        rconde: *mut f32,
        rcondv: *mut f32,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn cgegs_(
        jobvsl: *mut c_char,
        jobvsr: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        alpha: *mut scomplex,
        beta: *mut scomplex,
        vsl: *mut scomplex,
        ldvsl: *mut integer,
        vsr: *mut scomplex,
        ldvsr: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn cgegv_(
        jobvl: *mut c_char,
        jobvr: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        alpha: *mut scomplex,
        beta: *mut scomplex,
        vl: *mut scomplex,
        ldvl: *mut integer,
        vr: *mut scomplex,
        ldvr: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn cgehd2_(
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        tau: *mut scomplex,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn cgehrd_(
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        tau: *mut scomplex,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn cgejsv_(
        joba: *mut c_char,
        jobu: *mut c_char,
        jobv: *mut c_char,
        jobr: *mut c_char,
        jobt: *mut c_char,
        jobp: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        sva: *mut f32,
        u: *mut scomplex,
        ldu: *mut integer,
        v: *mut scomplex,
        ldv: *mut integer,
        cwork: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        lrwork: *mut integer,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn cgelq2_(
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        tau: *mut scomplex,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn cgelqf_(
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        tau: *mut scomplex,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn cgelq_(
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        t: *mut scomplex,
        tsize: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn cgelqt3_(
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        t: *mut scomplex,
        ldt: *mut integer,
        info: *mut integer,
    );
    pub fn cgelqt_(
        m: *mut integer,
        n: *mut integer,
        mb: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        t: *mut scomplex,
        ldt: *mut integer,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn cgels_(
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn cgelsd_(
        m: *mut integer,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        s: *mut f32,
        rcond: *mut f32,
        rank: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn cgelss_(
        m: *mut integer,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        s: *mut f32,
        rcond: *mut f32,
        rank: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn cgelsx_(
        m: *mut integer,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        jpvt: *mut integer,
        rcond: *mut f32,
        rank: *mut integer,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn cgelsy_(
        m: *mut integer,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        jpvt: *mut integer,
        rcond: *mut f32,
        rank: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn cgemlq_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        t: *mut scomplex,
        tsize: *mut integer,
        c: *mut scomplex,
        ldc: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn cgemlqt_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        mb: *mut integer,
        v: *mut scomplex,
        ldv: *mut integer,
        t: *mut scomplex,
        ldt: *mut integer,
        c: *mut scomplex,
        ldc: *mut integer,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn cgemqr_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        t: *mut scomplex,
        tsize: *mut integer,
        c: *mut scomplex,
        ldc: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn cgemqrt_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        nb: *mut integer,
        v: *mut scomplex,
        ldv: *mut integer,
        t: *mut scomplex,
        ldt: *mut integer,
        c: *mut scomplex,
        ldc: *mut integer,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn cgeql2_(
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        tau: *mut scomplex,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn cgeqlf_(
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        tau: *mut scomplex,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn cgeqp3_(
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        jpvt: *mut integer,
        tau: *mut scomplex,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn cgeqpf_(
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        jpvt: *mut integer,
        tau: *mut scomplex,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn cgeqr2_(
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        tau: *mut scomplex,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn cgeqr2p_(
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        tau: *mut scomplex,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn cgeqrf_(
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        tau: *mut scomplex,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn cgeqrfp_(
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        tau: *mut scomplex,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn cgeqr_(
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        t: *mut scomplex,
        tsize: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn cgeqrt2_(
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        t: *mut scomplex,
        ldt: *mut integer,
        info: *mut integer,
    );
    pub fn cgeqrt3_(
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        t: *mut scomplex,
        ldt: *mut integer,
        info: *mut integer,
    );
    pub fn cgeqrt_(
        m: *mut integer,
        n: *mut integer,
        nb: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        t: *mut scomplex,
        ldt: *mut integer,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn cgerfs_(
        trans: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        af: *mut scomplex,
        ldaf: *mut integer,
        ipiv: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        x: *mut scomplex,
        ldx: *mut integer,
        ferr: *mut f32,
        berr: *mut f32,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn cgerfsx_(
        trans: *mut c_char,
        equed: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        af: *mut scomplex,
        ldaf: *mut integer,
        ipiv: *mut integer,
        r: *mut f32,
        c: *mut f32,
        b: *mut scomplex,
        ldb: *mut integer,
        x: *mut scomplex,
        ldx: *mut integer,
        rcond: *mut f32,
        berr: *mut f32,
        n_err_bnds: *mut integer,
        err_bnds_norm: *mut f32,
        err_bnds_comp: *mut f32,
        nparams: *mut integer,
        params: *mut f32,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn cgerq2_(
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        tau: *mut scomplex,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn cgerqf_(
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        tau: *mut scomplex,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn cgesc2_(
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        rhs: *mut scomplex,
        ipiv: *mut integer,
        jpiv: *mut integer,
        scale: *mut f32,
    );
    pub fn cgesdd_(
        jobz: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        s: *mut f32,
        u: *mut scomplex,
        ldu: *mut integer,
        vt: *mut scomplex,
        ldvt: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn cgesvd_(
        jobu: *mut c_char,
        jobv: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        s: *mut f32,
        u: *mut scomplex,
        ldu: *mut integer,
        vt: *mut scomplex,
        ldvt: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn cgesvdq_(
        joba: *mut c_char,
        jobp: *mut c_char,
        jobr: *mut c_char,
        jobu: *mut c_char,
        jobv: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        s: *mut f32,
        u: *mut scomplex,
        ldu: *mut integer,
        v: *mut scomplex,
        ldv: *mut integer,
        numrank: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        cwork: *mut scomplex,
        lcwork: *mut integer,
        rwork: *mut f32,
        lrwork: *mut integer,
        info: *mut integer,
    );
    pub fn cgesvdx_(
        jobu: *mut c_char,
        jobvt: *mut c_char,
        range: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        vl: *mut f32,
        vu: *mut f32,
        il: *mut integer,
        iu: *mut integer,
        ns: *mut integer,
        s: *mut f32,
        u: *mut scomplex,
        ldu: *mut integer,
        vt: *mut scomplex,
        ldvt: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn cgesv_(
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn cgesvj_(
        joba: *mut c_char,
        jobu: *mut c_char,
        jobv: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        sva: *mut f32,
        mv: *mut integer,
        v: *mut scomplex,
        ldv: *mut integer,
        cwork: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        lrwork: *mut integer,
        info: *mut integer,
    );
    pub fn cgesvx_(
        fact: *mut c_char,
        trans: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        af: *mut scomplex,
        ldaf: *mut integer,
        ipiv: *mut integer,
        equed: *mut c_char,
        r: *mut f32,
        c: *mut f32,
        b: *mut scomplex,
        ldb: *mut integer,
        x: *mut scomplex,
        ldx: *mut integer,
        rcond: *mut f32,
        ferr: *mut f32,
        berr: *mut f32,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn cgesvxx_(
        fact: *mut c_char,
        trans: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        af: *mut scomplex,
        ldaf: *mut integer,
        ipiv: *mut integer,
        equed: *mut c_char,
        r: *mut f32,
        c: *mut f32,
        b: *mut scomplex,
        ldb: *mut integer,
        x: *mut scomplex,
        ldx: *mut integer,
        rcond: *mut f32,
        rpvgrw: *mut f32,
        berr: *mut f32,
        n_err_bnds: *mut integer,
        err_bnds_norm: *mut f32,
        err_bnds_comp: *mut f32,
        nparams: *mut integer,
        params: *mut f32,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn cgetc2_(
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        jpiv: *mut integer,
        info: *mut integer,
    );
    pub fn cgetf2_(
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn cgetrf2_(
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn cgetrf_(
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn cgetri_(
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn cgetrs_(
        trans: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn cgetsls_(
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn cggbak_(
        job: *mut c_char,
        side: *mut c_char,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        lscale: *mut f32,
        rscale: *mut f32,
        m: *mut integer,
        v: *mut scomplex,
        ldv: *mut integer,
        info: *mut integer,
    );
    pub fn cggbal_(
        job: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        lscale: *mut f32,
        rscale: *mut f32,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn cgges3_(
        jobvsl: *mut c_char,
        jobvsr: *mut c_char,
        sort: *mut c_char,
        selctg: L_fp,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        sdim: *mut integer,
        alpha: *mut scomplex,
        beta: *mut scomplex,
        vsl: *mut scomplex,
        ldvsl: *mut integer,
        vsr: *mut scomplex,
        ldvsr: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        bwork: *mut logical,
        info: *mut integer,
    );
    pub fn cgges_(
        jobvsl: *mut c_char,
        jobvsr: *mut c_char,
        sort: *mut c_char,
        selctg: L_fp,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        sdim: *mut integer,
        alpha: *mut scomplex,
        beta: *mut scomplex,
        vsl: *mut scomplex,
        ldvsl: *mut integer,
        vsr: *mut scomplex,
        ldvsr: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        bwork: *mut logical,
        info: *mut integer,
    );
    pub fn cggesx_(
        jobvsl: *mut c_char,
        jobvsr: *mut c_char,
        sort: *mut c_char,
        selctg: L_fp,
        sense: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        sdim: *mut integer,
        alpha: *mut scomplex,
        beta: *mut scomplex,
        vsl: *mut scomplex,
        ldvsl: *mut integer,
        vsr: *mut scomplex,
        ldvsr: *mut integer,
        rconde: *mut f32,
        rcondv: *mut f32,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        iwork: *mut integer,
        liwork: *mut integer,
        bwork: *mut logical,
        info: *mut integer,
    );
    pub fn cggev3_(
        jobvl: *mut c_char,
        jobvr: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        alpha: *mut scomplex,
        beta: *mut scomplex,
        vl: *mut scomplex,
        ldvl: *mut integer,
        vr: *mut scomplex,
        ldvr: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn cggev_(
        jobvl: *mut c_char,
        jobvr: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        alpha: *mut scomplex,
        beta: *mut scomplex,
        vl: *mut scomplex,
        ldvl: *mut integer,
        vr: *mut scomplex,
        ldvr: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn cggevx_(
        balanc: *mut c_char,
        jobvl: *mut c_char,
        jobvr: *mut c_char,
        sense: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        alpha: *mut scomplex,
        beta: *mut scomplex,
        vl: *mut scomplex,
        ldvl: *mut integer,
        vr: *mut scomplex,
        ldvr: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        lscale: *mut f32,
        rscale: *mut f32,
        abnrm: *mut f32,
        bbnrm: *mut f32,
        rconde: *mut f32,
        rcondv: *mut f32,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        iwork: *mut integer,
        bwork: *mut logical,
        info: *mut integer,
    );
    pub fn cggglm_(
        n: *mut integer,
        m: *mut integer,
        p: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        d: *mut scomplex,
        x: *mut scomplex,
        y: *mut scomplex,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn cgghd3_(
        compq: *mut c_char,
        compz: *mut c_char,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        q: *mut scomplex,
        ldq: *mut integer,
        z: *mut scomplex,
        ldz: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn cgghrd_(
        compq: *mut c_char,
        compz: *mut c_char,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        q: *mut scomplex,
        ldq: *mut integer,
        z: *mut scomplex,
        ldz: *mut integer,
        info: *mut integer,
    );
    pub fn cgglse_(
        m: *mut integer,
        n: *mut integer,
        p: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        c: *mut scomplex,
        d: *mut scomplex,
        x: *mut scomplex,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn cggqrf_(
        n: *mut integer,
        m: *mut integer,
        p: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        taua: *mut scomplex,
        b: *mut scomplex,
        ldb: *mut integer,
        taub: *mut scomplex,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn cggrqf_(
        m: *mut integer,
        p: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        taua: *mut scomplex,
        b: *mut scomplex,
        ldb: *mut integer,
        taub: *mut scomplex,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn cggsvd3_(
        jobu: *mut c_char,
        jobv: *mut c_char,
        jobq: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        p: *mut integer,
        k: *mut integer,
        l: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        alpha: *mut f32,
        beta: *mut f32,
        u: *mut scomplex,
        ldu: *mut integer,
        v: *mut scomplex,
        ldv: *mut integer,
        q: *mut scomplex,
        ldq: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn cggsvd_(
        jobu: *mut c_char,
        jobv: *mut c_char,
        jobq: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        p: *mut integer,
        k: *mut integer,
        l: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        alpha: *mut f32,
        beta: *mut f32,
        u: *mut scomplex,
        ldu: *mut integer,
        v: *mut scomplex,
        ldv: *mut integer,
        q: *mut scomplex,
        ldq: *mut integer,
        work: *mut scomplex,
        rwork: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn cggsvp3_(
        jobu: *mut c_char,
        jobv: *mut c_char,
        jobq: *mut c_char,
        m: *mut integer,
        p: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        tola: *mut f32,
        tolb: *mut f32,
        k: *mut integer,
        l: *mut integer,
        u: *mut scomplex,
        ldu: *mut integer,
        v: *mut scomplex,
        ldv: *mut integer,
        q: *mut scomplex,
        ldq: *mut integer,
        iwork: *mut integer,
        rwork: *mut f32,
        tau: *mut scomplex,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn cggsvp_(
        jobu: *mut c_char,
        jobv: *mut c_char,
        jobq: *mut c_char,
        m: *mut integer,
        p: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        tola: *mut f32,
        tolb: *mut f32,
        k: *mut integer,
        l: *mut integer,
        u: *mut scomplex,
        ldu: *mut integer,
        v: *mut scomplex,
        ldv: *mut integer,
        q: *mut scomplex,
        ldq: *mut integer,
        iwork: *mut integer,
        rwork: *mut f32,
        tau: *mut scomplex,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn cgsvj0_(
        jobv: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        d: *mut scomplex,
        sva: *mut f32,
        mv: *mut integer,
        v: *mut scomplex,
        ldv: *mut integer,
        eps: *mut f32,
        sfmin: *mut f32,
        tol: *mut f32,
        nsweep: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn cgsvj1_(
        jobv: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        n1: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        d: *mut scomplex,
        sva: *mut f32,
        mv: *mut integer,
        v: *mut scomplex,
        ldv: *mut integer,
        eps: *mut f32,
        sfmin: *mut f32,
        tol: *mut f32,
        nsweep: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn cgtcon_(
        norm: *mut c_char,
        n: *mut integer,
        dl: *mut scomplex,
        d: *mut scomplex,
        du: *mut scomplex,
        du2: *mut scomplex,
        ipiv: *mut integer,
        anorm: *mut f32,
        rcond: *mut f32,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn cgtrfs_(
        trans: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        dl: *mut scomplex,
        d: *mut scomplex,
        du: *mut scomplex,
        dlf: *mut scomplex,
        df: *mut scomplex,
        duf: *mut scomplex,
        du2: *mut scomplex,
        ipiv: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        x: *mut scomplex,
        ldx: *mut integer,
        ferr: *mut f32,
        berr: *mut f32,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn cgtsv_(
        n: *mut integer,
        nrhs: *mut integer,
        dl: *mut scomplex,
        d: *mut scomplex,
        du: *mut scomplex,
        b: *mut scomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn cgtsvx_(
        fact: *mut c_char,
        trans: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        dl: *mut scomplex,
        d: *mut scomplex,
        du: *mut scomplex,
        dlf: *mut scomplex,
        df: *mut scomplex,
        duf: *mut scomplex,
        du2: *mut scomplex,
        ipiv: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        x: *mut scomplex,
        ldx: *mut integer,
        rcond: *mut f32,
        ferr: *mut f32,
        berr: *mut f32,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn cgttrf_(
        n: *mut integer,
        dl: *mut scomplex,
        d: *mut scomplex,
        du: *mut scomplex,
        du2: *mut scomplex,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn cgttrs_(
        trans: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        dl: *mut scomplex,
        d: *mut scomplex,
        du: *mut scomplex,
        du2: *mut scomplex,
        ipiv: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn cgtts2_(
        itrans: *mut integer,
        n: *mut integer,
        nrhs: *mut integer,
        dl: *mut scomplex,
        d: *mut scomplex,
        du: *mut scomplex,
        du2: *mut scomplex,
        ipiv: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
    );
    pub fn chb2st_kernels_(
        uplo: *mut c_char,
        wantz: *mut logical,
        ttype: *mut integer,
        st: *mut integer,
        ed: *mut integer,
        sweep: *mut integer,
        n: *mut integer,
        nb: *mut integer,
        ib: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        v: *mut scomplex,
        tau: *mut scomplex,
        ldvt: *mut integer,
        work: *mut scomplex,
    );
    pub fn chbev_2stage_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        w: *mut f32,
        z: *mut scomplex,
        ldz: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn chbev_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        w: *mut f32,
        z: *mut scomplex,
        ldz: *mut integer,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn chbevd_2stage_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        w: *mut f32,
        z: *mut scomplex,
        ldz: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        lrwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn chbevd_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        w: *mut f32,
        z: *mut scomplex,
        ldz: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        lrwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn chbevx_2stage_(
        jobz: *mut c_char,
        range: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        q: *mut scomplex,
        ldq: *mut integer,
        vl: *mut f32,
        vu: *mut f32,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f32,
        m: *mut integer,
        w: *mut f32,
        z: *mut scomplex,
        ldz: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        iwork: *mut integer,
        ifail: *mut integer,
        info: *mut integer,
    );
    pub fn chbevx_(
        jobz: *mut c_char,
        range: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        q: *mut scomplex,
        ldq: *mut integer,
        vl: *mut f32,
        vu: *mut f32,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f32,
        m: *mut integer,
        w: *mut f32,
        z: *mut scomplex,
        ldz: *mut integer,
        work: *mut scomplex,
        rwork: *mut f32,
        iwork: *mut integer,
        ifail: *mut integer,
        info: *mut integer,
    );
    pub fn chbgst_(
        vect: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ka: *mut integer,
        kb: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        bb: *mut scomplex,
        ldbb: *mut integer,
        x: *mut scomplex,
        ldx: *mut integer,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn chbgv_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ka: *mut integer,
        kb: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        bb: *mut scomplex,
        ldbb: *mut integer,
        w: *mut f32,
        z: *mut scomplex,
        ldz: *mut integer,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn chbgvd_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ka: *mut integer,
        kb: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        bb: *mut scomplex,
        ldbb: *mut integer,
        w: *mut f32,
        z: *mut scomplex,
        ldz: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        lrwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn chbgvx_(
        jobz: *mut c_char,
        range: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ka: *mut integer,
        kb: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        bb: *mut scomplex,
        ldbb: *mut integer,
        q: *mut scomplex,
        ldq: *mut integer,
        vl: *mut f32,
        vu: *mut f32,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f32,
        m: *mut integer,
        w: *mut f32,
        z: *mut scomplex,
        ldz: *mut integer,
        work: *mut scomplex,
        rwork: *mut f32,
        iwork: *mut integer,
        ifail: *mut integer,
        info: *mut integer,
    );
    pub fn chbtrd_(
        vect: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        d: *mut f32,
        e: *mut f32,
        q: *mut scomplex,
        ldq: *mut integer,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn checon_3_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        e: *mut scomplex,
        ipiv: *mut integer,
        anorm: *mut f32,
        rcond: *mut f32,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn checon_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        anorm: *mut f32,
        rcond: *mut f32,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn checon_rook_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        anorm: *mut f32,
        rcond: *mut f32,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn cheequb_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        s: *mut f32,
        scond: *mut f32,
        amax: *mut f32,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn cheev_2stage_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        w: *mut f32,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn cheev_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        w: *mut f32,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn cheevd_2stage_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        w: *mut f32,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        lrwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn cheevd_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        w: *mut f32,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        lrwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn cheevr_2stage_(
        jobz: *mut c_char,
        range: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        vl: *mut f32,
        vu: *mut f32,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f32,
        m: *mut integer,
        w: *mut f32,
        z: *mut scomplex,
        ldz: *mut integer,
        isuppz: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        lrwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn cheevr_(
        jobz: *mut c_char,
        range: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        vl: *mut f32,
        vu: *mut f32,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f32,
        m: *mut integer,
        w: *mut f32,
        z: *mut scomplex,
        ldz: *mut integer,
        isuppz: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        lrwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn cheevx_2stage_(
        jobz: *mut c_char,
        range: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        vl: *mut f32,
        vu: *mut f32,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f32,
        m: *mut integer,
        w: *mut f32,
        z: *mut scomplex,
        ldz: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        iwork: *mut integer,
        ifail: *mut integer,
        info: *mut integer,
    );
    pub fn cheevx_(
        jobz: *mut c_char,
        range: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        vl: *mut f32,
        vu: *mut f32,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f32,
        m: *mut integer,
        w: *mut f32,
        z: *mut scomplex,
        ldz: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        iwork: *mut integer,
        ifail: *mut integer,
        info: *mut integer,
    );
    pub fn chegs2_(
        itype: *mut integer,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn chegst_(
        itype: *mut integer,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn chegv_2stage_(
        itype: *mut integer,
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        w: *mut f32,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn chegvd_(
        itype: *mut integer,
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        w: *mut f32,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        lrwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn chegv_(
        itype: *mut integer,
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        w: *mut f32,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn chegvx_(
        itype: *mut integer,
        jobz: *mut c_char,
        range: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        vl: *mut f32,
        vu: *mut f32,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f32,
        m: *mut integer,
        w: *mut f32,
        z: *mut scomplex,
        ldz: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        iwork: *mut integer,
        ifail: *mut integer,
        info: *mut integer,
    );
    pub fn cherfs_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        af: *mut scomplex,
        ldaf: *mut integer,
        ipiv: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        x: *mut scomplex,
        ldx: *mut integer,
        ferr: *mut f32,
        berr: *mut f32,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn cherfsx_(
        uplo: *mut c_char,
        equed: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        af: *mut scomplex,
        ldaf: *mut integer,
        ipiv: *mut integer,
        s: *mut f32,
        b: *mut scomplex,
        ldb: *mut integer,
        x: *mut scomplex,
        ldx: *mut integer,
        rcond: *mut f32,
        berr: *mut f32,
        n_err_bnds: *mut integer,
        err_bnds_norm: *mut f32,
        err_bnds_comp: *mut f32,
        nparams: *mut integer,
        params: *mut f32,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn chesv_aa_2stage_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        tb: *mut scomplex,
        ltb: *mut integer,
        ipiv: *mut integer,
        ipiv2: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn chesv_aa_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn chesv_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn chesv_rk_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        e: *mut scomplex,
        ipiv: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn chesv_rook_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn chesvx_(
        fact: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        af: *mut scomplex,
        ldaf: *mut integer,
        ipiv: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        x: *mut scomplex,
        ldx: *mut integer,
        rcond: *mut f32,
        ferr: *mut f32,
        berr: *mut f32,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn chesvxx_(
        fact: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        af: *mut scomplex,
        ldaf: *mut integer,
        ipiv: *mut integer,
        equed: *mut c_char,
        s: *mut f32,
        b: *mut scomplex,
        ldb: *mut integer,
        x: *mut scomplex,
        ldx: *mut integer,
        rcond: *mut f32,
        rpvgrw: *mut f32,
        berr: *mut f32,
        n_err_bnds: *mut integer,
        err_bnds_norm: *mut f32,
        err_bnds_comp: *mut f32,
        nparams: *mut integer,
        params: *mut f32,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn cheswapr_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        i1: *mut integer,
        i2: *mut integer,
    );
    pub fn chetd2_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        d: *mut f32,
        e: *mut f32,
        tau: *mut scomplex,
        info: *mut integer,
    );
    pub fn chetf2_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn chetf2_rk_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        e: *mut scomplex,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn chetf2_rook_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn chetrd_2stage_(
        vect: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        d: *mut f32,
        e: *mut f32,
        tau: *mut scomplex,
        hous2: *mut scomplex,
        lhous2: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn chetrd_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        d: *mut f32,
        e: *mut f32,
        tau: *mut scomplex,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn chetrd_hb2st_(
        stage1: *mut c_char,
        vect: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        d: *mut f32,
        e: *mut f32,
        hous: *mut scomplex,
        lhous: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn chetrd_he2hb_(
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        tau: *mut scomplex,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn chetrf_aa_2stage_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        tb: *mut scomplex,
        ltb: *mut integer,
        ipiv: *mut integer,
        ipiv2: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn chetrf_aa_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn chetrf_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn chetrf_rk_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        e: *mut scomplex,
        ipiv: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn chetrf_rook_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn chetri2_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn chetri2x_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut scomplex,
        nb: *mut integer,
        info: *mut integer,
    );
    pub fn chetri_3_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        e: *mut scomplex,
        ipiv: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn chetri_3x_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        e: *mut scomplex,
        ipiv: *mut integer,
        work: *mut scomplex,
        nb: *mut integer,
        info: *mut integer,
    );
    pub fn chetri_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn chetri_rook_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn chetrs2_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn chetrs_3_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        e: *mut scomplex,
        ipiv: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn chetrs_aa_2stage_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        tb: *mut scomplex,
        ltb: *mut integer,
        ipiv: *mut integer,
        ipiv2: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn chetrs_aa_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn chetrs_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn chetrs_rook_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn chfrk_(
        transr: *mut c_char,
        uplo: *mut c_char,
        trans: *mut c_char,
        n: *mut integer,
        k: *mut integer,
        alpha: *mut f32,
        a: *mut scomplex,
        lda: *mut integer,
        beta: *mut f32,
        c__: *mut scomplex,
    );
    pub fn chgeqz_(
        job: *mut c_char,
        compq: *mut c_char,
        compz: *mut c_char,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        h: *mut scomplex,
        ldh: *mut integer,
        t: *mut scomplex,
        ldt: *mut integer,
        alpha: *mut scomplex,
        beta: *mut scomplex,
        q: *mut scomplex,
        ldq: *mut integer,
        z: *mut scomplex,
        ldz: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn chpcon_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut scomplex,
        ipiv: *mut integer,
        anorm: *mut f32,
        rcond: *mut f32,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn chpev_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut scomplex,
        w: *mut f32,
        z: *mut scomplex,
        ldz: *mut integer,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn chpevd_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut scomplex,
        w: *mut f32,
        z: *mut scomplex,
        ldz: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        lrwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn chpevx_(
        jobz: *mut c_char,
        range: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut scomplex,
        vl: *mut f32,
        vu: *mut f32,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f32,
        m: *mut integer,
        w: *mut f32,
        z: *mut scomplex,
        ldz: *mut integer,
        work: *mut scomplex,
        rwork: *mut f32,
        iwork: *mut integer,
        ifail: *mut integer,
        info: *mut integer,
    );
    pub fn chpgst_(
        itype: *mut integer,
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut scomplex,
        bp: *mut scomplex,
        info: *mut integer,
    );
    pub fn chpgvd_(
        itype: *mut integer,
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut scomplex,
        bp: *mut scomplex,
        w: *mut f32,
        z: *mut scomplex,
        ldz: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        lrwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn chpgv_(
        itype: *mut integer,
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut scomplex,
        bp: *mut scomplex,
        w: *mut f32,
        z: *mut scomplex,
        ldz: *mut integer,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn chpgvx_(
        itype: *mut integer,
        jobz: *mut c_char,
        range: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut scomplex,
        bp: *mut scomplex,
        vl: *mut f32,
        vu: *mut f32,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f32,
        m: *mut integer,
        w: *mut f32,
        z: *mut scomplex,
        ldz: *mut integer,
        work: *mut scomplex,
        rwork: *mut f32,
        iwork: *mut integer,
        ifail: *mut integer,
        info: *mut integer,
    );
    pub fn chprfs_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut scomplex,
        afp: *mut scomplex,
        ipiv: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        x: *mut scomplex,
        ldx: *mut integer,
        ferr: *mut f32,
        berr: *mut f32,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn chpsv_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut scomplex,
        ipiv: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn chpsvx_(
        fact: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut scomplex,
        afp: *mut scomplex,
        ipiv: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        x: *mut scomplex,
        ldx: *mut integer,
        rcond: *mut f32,
        ferr: *mut f32,
        berr: *mut f32,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn chptrd_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut scomplex,
        d: *mut f32,
        e: *mut f32,
        tau: *mut scomplex,
        info: *mut integer,
    );
    pub fn chptrf_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut scomplex,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn chptri_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut scomplex,
        ipiv: *mut integer,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn chptrs_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut scomplex,
        ipiv: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn chsein_(
        side: *mut c_char,
        eigsrc: *mut c_char,
        initv: *mut c_char,
        select: *mut logical,
        n: *mut integer,
        h: *mut scomplex,
        ldh: *mut integer,
        w: *mut scomplex,
        vl: *mut scomplex,
        ldvl: *mut integer,
        vr: *mut scomplex,
        ldvr: *mut integer,
        mm: *mut integer,
        m: *mut integer,
        work: *mut scomplex,
        rwork: *mut f32,
        ifaill: *mut integer,
        ifailr: *mut integer,
        info: *mut integer,
    );
    pub fn chseqr_(
        job: *mut c_char,
        compz: *mut c_char,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        h: *mut scomplex,
        ldh: *mut integer,
        w: *mut scomplex,
        z: *mut scomplex,
        ldz: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn clabrd_(
        m: *mut integer,
        n: *mut integer,
        nb: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        d: *mut f32,
        e: *mut f32,
        tauq: *mut scomplex,
        taup: *mut scomplex,
        x: *mut scomplex,
        ldx: *mut integer,
        y: *mut scomplex,
        ldy: *mut integer,
    );
    pub fn clacgv_(n: *mut integer, x: *mut scomplex, incx: *mut integer);
    pub fn clacn2_(
        n: *mut integer,
        v: *mut scomplex,
        x: *mut scomplex,
        est: *mut f32,
        kase: *mut integer,
        isave: *mut integer,
    );
    pub fn clacon_(
        n: *mut integer,
        v: *mut scomplex,
        x: *mut scomplex,
        est: *mut f32,
        kase: *mut integer,
    );
    pub fn clacp2_(
        uplo: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
    );
    pub fn clacpy_(
        uplo: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
    );
    pub fn clacrm_(
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        c: *mut scomplex,
        ldc: *mut integer,
        rwork: *mut f32,
    );
    pub fn clacrt_(
        n: *mut integer,
        cx: *mut scomplex,
        incx: *mut integer,
        cy: *mut scomplex,
        incy: *mut integer,
        c: *mut scomplex,
        s: *mut scomplex,
    );
    pub fn claed0_(
        qsiz: *mut integer,
        n: *mut integer,
        d: *mut f32,
        e: *mut f32,
        q: *mut scomplex,
        ldq: *mut integer,
        qstore: *mut scomplex,
        ldqs: *mut integer,
        rwork: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn claed7_(
        n: *mut integer,
        cutpnt: *mut integer,
        qsiz: *mut integer,
        tlvls: *mut integer,
        curlvl: *mut integer,
        curpbm: *mut integer,
        d: *mut f32,
        q: *mut scomplex,
        ldq: *mut integer,
        rho: *mut f32,
        indxq: *mut integer,
        qstore: *mut f32,
        qptr: *mut integer,
        prmptr: *mut integer,
        perm: *mut integer,
        givptr: *mut integer,
        givcol: *mut integer,
        givnum: *mut f32,
        work: *mut scomplex,
        rwork: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn claed8_(
        k: *mut integer,
        n: *mut integer,
        qsiz: *mut integer,
        q: *mut scomplex,
        ldq: *mut integer,
        d: *mut f32,
        rho: *mut f32,
        cutpnt: *mut integer,
        z: *mut f32,
        dlamda: *mut f32,
        q2: *mut scomplex,
        ldq2: *mut integer,
        w: *mut f32,
        indxp: *mut integer,
        indx: *mut integer,
        indxq: *mut integer,
        perm: *mut integer,
        givptr: *mut integer,
        givcol: *mut integer,
        givnum: *mut f32,
        info: *mut integer,
    );
    pub fn claein_(
        rightv: *mut logical,
        noinit: *mut logical,
        n: *mut integer,
        h: *mut scomplex,
        ldh: *mut integer,
        w: *mut scomplex,
        v: *mut scomplex,
        b: *mut scomplex,
        ldb: *mut integer,
        rwork: *mut f32,
        eps3: *mut f32,
        smlnum: *mut f32,
        info: *mut integer,
    );
    pub fn claesy_(
        a: *mut scomplex,
        b: *mut scomplex,
        c: *mut scomplex,
        rt1: *mut scomplex,
        rt2: *mut scomplex,
        evscal: *mut scomplex,
        cs1: *mut scomplex,
        sn1: *mut scomplex,
    );
    pub fn claev2_(
        a: *mut scomplex,
        b: *mut scomplex,
        c: *mut scomplex,
        rt1: *mut f32,
        rt2: *mut f32,
        cs1: *mut f32,
        sn1: *mut scomplex,
    );
    pub fn clag2z_(
        m: *mut integer,
        n: *mut integer,
        sa: *mut scomplex,
        ldsa: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn cla_gbamv_(
        trans: *mut integer,
        m: *mut integer,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        alpha: *mut f32,
        ab: *mut scomplex,
        ldab: *mut integer,
        x: *mut scomplex,
        incx: *mut integer,
        beta: *mut f32,
        y: *mut f32,
        incy: *mut integer,
    );
    pub fn cla_gbrfsx_extended_(
        prec_type: *mut integer,
        trans_type: *mut integer,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        nrhs: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        afb: *mut scomplex,
        ldafb: *mut integer,
        ipiv: *mut integer,
        colequ: *mut logical,
        c: *mut f32,
        b: *mut scomplex,
        ldb: *mut integer,
        y: *mut scomplex,
        ldy: *mut integer,
        berr_out: *mut f32,
        n_norms: *mut integer,
        err_bnds_norm: *mut f32,
        err_bnds_comp: *mut f32,
        res: *mut scomplex,
        ayb: *mut f32,
        dy: *mut scomplex,
        y_tail: *mut scomplex,
        rcond: *mut f32,
        ithresh: *mut integer,
        rthresh: *mut f32,
        dz_ub: *mut f32,
        ignore_cwise: *mut logical,
        info: *mut integer,
    );
    pub fn cla_geamv_(
        trans: *mut integer,
        m: *mut integer,
        n: *mut integer,
        alpha: *mut f32,
        a: *mut scomplex,
        lda: *mut integer,
        x: *mut scomplex,
        incx: *mut integer,
        beta: *mut f32,
        y: *mut f32,
        incy: *mut integer,
    );
    pub fn cla_gerfsx_extended_(
        prec_type: *mut integer,
        trans_type: *mut integer,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        af: *mut scomplex,
        ldaf: *mut integer,
        ipiv: *mut integer,
        colequ: *mut logical,
        c: *mut f32,
        b: *mut scomplex,
        ldb: *mut integer,
        y: *mut scomplex,
        ldy: *mut integer,
        berr_out: *mut f32,
        n_norms: *mut integer,
        errs_n: *mut f32,
        errs_c: *mut f32,
        res: *mut scomplex,
        ayb: *mut f32,
        dy: *mut scomplex,
        y_tail: *mut scomplex,
        rcond: *mut f32,
        ithresh: *mut integer,
        rthresh: *mut f32,
        dz_ub: *mut f32,
        ignore_cwise: *mut logical,
        info: *mut integer,
    );
    pub fn clags2_(
        upper: *mut logical,
        a1: *mut f32,
        a2: *mut scomplex,
        a3: *mut f32,
        b1: *mut f32,
        b2: *mut scomplex,
        b3: *mut f32,
        csu: *mut f32,
        snu: *mut scomplex,
        csv: *mut f32,
        snv: *mut scomplex,
        csq: *mut f32,
        snq: *mut scomplex,
    );
    pub fn clagtm_(
        trans: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        alpha: *mut f32,
        dl: *mut scomplex,
        d: *mut scomplex,
        du: *mut scomplex,
        x: *mut scomplex,
        ldx: *mut integer,
        beta: *mut f32,
        b: *mut scomplex,
        ldb: *mut integer,
    );
    pub fn cla_heamv_(
        uplo: *mut integer,
        n: *mut integer,
        alpha: *mut f32,
        a: *mut scomplex,
        lda: *mut integer,
        x: *mut scomplex,
        incx: *mut integer,
        beta: *mut f32,
        y: *mut f32,
        incy: *mut integer,
    );
    pub fn clahef_aa_(
        uplo: *mut c_char,
        j1: *mut integer,
        m: *mut integer,
        nb: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        h: *mut scomplex,
        ldh: *mut integer,
        work: *mut scomplex,
    );
    pub fn clahef_(
        uplo: *mut c_char,
        n: *mut integer,
        nb: *mut integer,
        kb: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        w: *mut scomplex,
        ldw: *mut integer,
        info: *mut integer,
    );
    pub fn clahef_rk_(
        uplo: *mut c_char,
        n: *mut integer,
        nb: *mut integer,
        kb: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        e: *mut scomplex,
        ipiv: *mut integer,
        w: *mut scomplex,
        ldw: *mut integer,
        info: *mut integer,
    );
    pub fn clahef_rook_(
        uplo: *mut c_char,
        n: *mut integer,
        nb: *mut integer,
        kb: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        w: *mut scomplex,
        ldw: *mut integer,
        info: *mut integer,
    );
    pub fn cla_herfsx_extended_(
        prec_type: *mut integer,
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        af: *mut scomplex,
        ldaf: *mut integer,
        ipiv: *mut integer,
        colequ: *mut logical,
        c: *mut f32,
        b: *mut scomplex,
        ldb: *mut integer,
        y: *mut scomplex,
        ldy: *mut integer,
        berr_out: *mut f32,
        n_norms: *mut integer,
        err_bnds_norm: *mut f32,
        err_bnds_comp: *mut f32,
        res: *mut scomplex,
        ayb: *mut f32,
        dy: *mut scomplex,
        y_tail: *mut scomplex,
        rcond: *mut f32,
        ithresh: *mut integer,
        rthresh: *mut f32,
        dz_ub: *mut f32,
        ignore_cwise: *mut logical,
        info: *mut integer,
    );
    pub fn clahqr_(
        wantt: *mut logical,
        wantz: *mut logical,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        h: *mut scomplex,
        ldh: *mut integer,
        w: *mut scomplex,
        iloz: *mut integer,
        ihiz: *mut integer,
        z: *mut scomplex,
        ldz: *mut integer,
        info: *mut integer,
    );
    pub fn clahr2_(
        n: *mut integer,
        k: *mut integer,
        nb: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        tau: *mut scomplex,
        t: *mut scomplex,
        ldt: *mut integer,
        y: *mut scomplex,
        ldy: *mut integer,
    );
    pub fn clahrd_(
        n: *mut integer,
        k: *mut integer,
        nb: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        tau: *mut scomplex,
        t: *mut scomplex,
        ldt: *mut integer,
        y: *mut scomplex,
        ldy: *mut integer,
    );
    pub fn claic1_(
        job: *mut integer,
        j: *mut integer,
        x: *mut scomplex,
        sest: *mut f32,
        w: *mut scomplex,
        gamma: *mut scomplex,
        sestpr: *mut f32,
        s: *mut scomplex,
        c__: *mut scomplex,
    );
    pub fn cla_lin_berr_(
        n: *mut integer,
        nz: *mut integer,
        nrhs: *mut integer,
        res: *mut scomplex,
        ayb: *mut f32,
        berr: *mut f32,
    );
    pub fn clals0_(
        icompq: *mut integer,
        nl: *mut integer,
        nr: *mut integer,
        sqre: *mut integer,
        nrhs: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        bx: *mut scomplex,
        ldbx: *mut integer,
        perm: *mut integer,
        givptr: *mut integer,
        givcol: *mut integer,
        ldgcol: *mut integer,
        givnum: *mut f32,
        ldgnum: *mut integer,
        poles: *mut f32,
        difl: *mut f32,
        difr: *mut f32,
        z: *mut f32,
        k: *mut integer,
        c: *mut f32,
        s: *mut f32,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn clalsa_(
        icompq: *mut integer,
        smlsiz: *mut integer,
        n: *mut integer,
        nrhs: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        bx: *mut scomplex,
        ldbx: *mut integer,
        u: *mut f32,
        ldu: *mut integer,
        vt: *mut f32,
        k: *mut integer,
        difl: *mut f32,
        difr: *mut f32,
        z: *mut f32,
        poles: *mut f32,
        givptr: *mut integer,
        givcol: *mut integer,
        ldgcol: *mut integer,
        perm: *mut integer,
        givnum: *mut f32,
        c: *mut f32,
        s: *mut f32,
        rwork: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn clalsd_(
        uplo: *mut c_char,
        smlsiz: *mut integer,
        n: *mut integer,
        nrhs: *mut integer,
        d: *mut f32,
        e: *mut f32,
        b: *mut scomplex,
        ldb: *mut integer,
        rcond: *mut f32,
        rank: *mut integer,
        work: *mut scomplex,
        rwork: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn clamswlq_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        mb: *mut integer,
        nb: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        t: *mut scomplex,
        ldt: *mut integer,
        c: *mut scomplex,
        ldc: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn clamtsqr_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        mb: *mut integer,
        nb: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        t: *mut scomplex,
        ldt: *mut integer,
        c: *mut scomplex,
        ldc: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn clapll_(
        n: *mut integer,
        x: *mut scomplex,
        incx: *mut integer,
        y: *mut scomplex,
        incy: *mut integer,
        ssmin: *mut f32,
    );
    pub fn clapmr_(
        forwrd: *mut logical,
        m: *mut integer,
        n: *mut integer,
        x: *mut scomplex,
        ldx: *mut integer,
        k: *mut integer,
    );
    pub fn clapmt_(
        forwrd: *mut logical,
        m: *mut integer,
        n: *mut integer,
        x: *mut scomplex,
        ldx: *mut integer,
        k: *mut integer,
    );
    pub fn cla_porfsx_extended_(
        prec_type: *mut integer,
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        af: *mut scomplex,
        ldaf: *mut integer,
        colequ: *mut logical,
        c: *mut f32,
        b: *mut scomplex,
        ldb: *mut integer,
        y: *mut scomplex,
        ldy: *mut integer,
        berr_out: *mut f32,
        n_norms: *mut integer,
        err_bnds_norm: *mut f32,
        err_bnds_comp: *mut f32,
        res: *mut scomplex,
        ayb: *mut f32,
        dy: *mut scomplex,
        y_tail: *mut scomplex,
        rcond: *mut f32,
        ithresh: *mut integer,
        rthresh: *mut f32,
        dz_ub: *mut f32,
        ignore_cwise: *mut logical,
        info: *mut integer,
    );
    pub fn claqgb_(
        m: *mut integer,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        r: *mut f32,
        c: *mut f32,
        rowcnd: *mut f32,
        colcnd: *mut f32,
        amax: *mut f32,
        equed: *mut c_char,
    );
    pub fn claqge_(
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        r: *mut f32,
        c: *mut f32,
        rowcnd: *mut f32,
        colcnd: *mut f32,
        amax: *mut f32,
        equed: *mut c_char,
    );
    pub fn claqhb_(
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        s: *mut f32,
        scond: *mut f32,
        amax: *mut f32,
        equed: *mut c_char,
    );
    pub fn claqhe_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        s: *mut f32,
        scond: *mut f32,
        amax: *mut f32,
        equed: *mut c_char,
    );
    pub fn claqhp_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut scomplex,
        s: *mut f32,
        scond: *mut f32,
        amax: *mut f32,
        equed: *mut c_char,
    );
    pub fn claqp2_(
        m: *mut integer,
        n: *mut integer,
        offset: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        jpvt: *mut integer,
        tau: *mut scomplex,
        vn1: *mut f32,
        vn2: *mut f32,
        work: *mut scomplex,
    );
    pub fn claqps_(
        m: *mut integer,
        n: *mut integer,
        offset: *mut integer,
        nb: *mut integer,
        kb: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        jpvt: *mut integer,
        tau: *mut scomplex,
        vn1: *mut f32,
        vn2: *mut f32,
        auxv: *mut scomplex,
        f: *mut scomplex,
        ldf: *mut integer,
    );
    pub fn claqr0_(
        wantt: *mut logical,
        wantz: *mut logical,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        h: *mut scomplex,
        ldh: *mut integer,
        w: *mut scomplex,
        iloz: *mut integer,
        ihiz: *mut integer,
        z: *mut scomplex,
        ldz: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn claqr1_(
        n: *mut integer,
        h: *mut scomplex,
        ldh: *mut integer,
        s1: *mut scomplex,
        s2: *mut scomplex,
        v: *mut scomplex,
    );
    pub fn claqr2_(
        wantt: *mut logical,
        wantz: *mut logical,
        n: *mut integer,
        ktop: *mut integer,
        kbot: *mut integer,
        nw: *mut integer,
        h: *mut scomplex,
        ldh: *mut integer,
        iloz: *mut integer,
        ihiz: *mut integer,
        z: *mut scomplex,
        ldz: *mut integer,
        ns: *mut integer,
        nd: *mut integer,
        sh: *mut scomplex,
        v: *mut scomplex,
        ldv: *mut integer,
        nh: *mut integer,
        t: *mut scomplex,
        ldt: *mut integer,
        nv: *mut integer,
        wv: *mut scomplex,
        ldwv: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
    );
    pub fn claqr3_(
        wantt: *mut logical,
        wantz: *mut logical,
        n: *mut integer,
        ktop: *mut integer,
        kbot: *mut integer,
        nw: *mut integer,
        h: *mut scomplex,
        ldh: *mut integer,
        iloz: *mut integer,
        ihiz: *mut integer,
        z: *mut scomplex,
        ldz: *mut integer,
        ns: *mut integer,
        nd: *mut integer,
        sh: *mut scomplex,
        v: *mut scomplex,
        ldv: *mut integer,
        nh: *mut integer,
        t: *mut scomplex,
        ldt: *mut integer,
        nv: *mut integer,
        wv: *mut scomplex,
        ldwv: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
    );
    pub fn claqr4_(
        wantt: *mut logical,
        wantz: *mut logical,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        h: *mut scomplex,
        ldh: *mut integer,
        w: *mut scomplex,
        iloz: *mut integer,
        ihiz: *mut integer,
        z: *mut scomplex,
        ldz: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn claqr5_(
        wantt: *mut logical,
        wantz: *mut logical,
        kacc22: *mut integer,
        n: *mut integer,
        ktop: *mut integer,
        kbot: *mut integer,
        nshfts: *mut integer,
        s: *mut scomplex,
        h: *mut scomplex,
        ldh: *mut integer,
        iloz: *mut integer,
        ihiz: *mut integer,
        z: *mut scomplex,
        ldz: *mut integer,
        v: *mut scomplex,
        ldv: *mut integer,
        u: *mut scomplex,
        ldu: *mut integer,
        nv: *mut integer,
        wv: *mut scomplex,
        ldwv: *mut integer,
        nh: *mut integer,
        wh: *mut scomplex,
        ldwh: *mut integer,
    );
    pub fn claqsb_(
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        s: *mut f32,
        scond: *mut f32,
        amax: *mut f32,
        equed: *mut c_char,
    );
    pub fn claqsp_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut scomplex,
        s: *mut f32,
        scond: *mut f32,
        amax: *mut f32,
        equed: *mut c_char,
    );
    pub fn claqsy_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        s: *mut f32,
        scond: *mut f32,
        amax: *mut f32,
        equed: *mut c_char,
    );
    pub fn clar1v_(
        n: *mut integer,
        b1: *mut integer,
        bn: *mut integer,
        lambda: *mut f32,
        d: *mut f32,
        l: *mut f32,
        ld: *mut f32,
        lld: *mut f32,
        pivmin: *mut f32,
        gaptol: *mut f32,
        z: *mut scomplex,
        wantnc: *mut logical,
        negcnt: *mut integer,
        ztz: *mut f32,
        mingma: *mut f32,
        r: *mut integer,
        isuppz: *mut integer,
        nrminv: *mut f32,
        resid: *mut f32,
        rqcorr: *mut f32,
        work: *mut f32,
    );
    pub fn clar2v_(
        n: *mut integer,
        x: *mut scomplex,
        y: *mut scomplex,
        z: *mut scomplex,
        incx: *mut integer,
        c: *mut f32,
        s: *mut scomplex,
        incc: *mut integer,
    );
    pub fn clarcm_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        c: *mut scomplex,
        ldc: *mut integer,
        rwork: *mut f32,
    );
    pub fn clarfb_(
        side: *mut c_char,
        trans: *mut c_char,
        direct: *mut c_char,
        storev: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        v: *mut scomplex,
        ldv: *mut integer,
        t: *mut scomplex,
        ldt: *mut integer,
        c: *mut scomplex,
        ldc: *mut integer,
        work: *mut scomplex,
        ldwork: *mut integer,
    );
    pub fn clarf_(
        side: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        v: *mut scomplex,
        incv: *mut integer,
        tau: *mut scomplex,
        c: *mut scomplex,
        ldc: *mut integer,
        work: *mut scomplex,
    );
    pub fn clarfg_(
        n: *mut integer,
        alpha: *mut scomplex,
        x: *mut scomplex,
        incx: *mut integer,
        tau: *mut scomplex,
    );
    pub fn clarfgp_(
        n: *mut integer,
        alpha: *mut scomplex,
        x: *mut scomplex,
        incx: *mut integer,
        tau: *mut scomplex,
    );
    pub fn clarft_(
        direct: *mut c_char,
        storev: *mut c_char,
        n: *mut integer,
        k: *mut integer,
        v: *mut scomplex,
        ldv: *mut integer,
        tau: *mut scomplex,
        t: *mut scomplex,
        ldt: *mut integer,
    );
    pub fn clarfx_(
        side: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        v: *mut scomplex,
        tau: *mut scomplex,
        c: *mut scomplex,
        ldc: *mut integer,
        work: *mut scomplex,
    );
    pub fn clarfy_(
        uplo: *mut c_char,
        n: *mut integer,
        v: *mut scomplex,
        incv: *mut integer,
        tau: *mut scomplex,
        c: *mut scomplex,
        ldc: *mut integer,
        work: *mut scomplex,
    );
    pub fn clargv_(
        n: *mut integer,
        x: *mut scomplex,
        incx: *mut integer,
        y: *mut scomplex,
        incy: *mut integer,
        c: *mut f32,
        incc: *mut integer,
    );
    pub fn clarnv_(idist: *mut integer, iseed: *mut integer, n: *mut integer, x: *mut scomplex);
    pub fn clarrv_(
        n: *mut integer,
        vl: *mut f32,
        vu: *mut f32,
        d: *mut f32,
        l: *mut f32,
        pivmin: *mut f32,
        isplit: *mut integer,
        m: *mut integer,
        dol: *mut integer,
        dou: *mut integer,
        minrgp: *mut f32,
        rtol1: *mut f32,
        rtol2: *mut f32,
        w: *mut f32,
        werr: *mut f32,
        wgap: *mut f32,
        iblock: *mut integer,
        indexw: *mut integer,
        gers: *mut f32,
        z: *mut scomplex,
        ldz: *mut integer,
        isuppz: *mut integer,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn clarscl2_(
        m: *mut integer,
        n: *mut integer,
        d: *mut f32,
        x: *mut scomplex,
        ldx: *mut integer,
    );
    pub fn clartg_(
        f: *mut scomplex,
        g: *mut scomplex,
        cs: *mut f32,
        sn: *mut scomplex,
        r__: *mut scomplex,
    );
    pub fn clartv_(
        n: *mut integer,
        x: *mut scomplex,
        incx: *mut integer,
        y: *mut scomplex,
        incy: *mut integer,
        c: *mut f32,
        s: *mut scomplex,
        incc: *mut integer,
    );
    pub fn clarzb_(
        side: *mut c_char,
        trans: *mut c_char,
        direct: *mut c_char,
        storev: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        l: *mut integer,
        v: *mut scomplex,
        ldv: *mut integer,
        t: *mut scomplex,
        ldt: *mut integer,
        c: *mut scomplex,
        ldc: *mut integer,
        work: *mut scomplex,
        ldwork: *mut integer,
    );
    pub fn clarz_(
        side: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        l: *mut integer,
        v: *mut scomplex,
        incv: *mut integer,
        tau: *mut scomplex,
        c: *mut scomplex,
        ldc: *mut integer,
        work: *mut scomplex,
    );
    pub fn clarzt_(
        direct: *mut c_char,
        storev: *mut c_char,
        n: *mut integer,
        k: *mut integer,
        v: *mut scomplex,
        ldv: *mut integer,
        tau: *mut scomplex,
        t: *mut scomplex,
        ldt: *mut integer,
    );
    pub fn clascl2_(
        m: *mut integer,
        n: *mut integer,
        d: *mut f32,
        x: *mut scomplex,
        ldx: *mut integer,
    );
    pub fn clascl_(
        type_: *mut c_char,
        kl: *mut integer,
        ku: *mut integer,
        cfrom: *mut f32,
        cto: *mut f32,
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn claset_(
        uplo: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        alpha: *mut scomplex,
        beta: *mut scomplex,
        a: *mut scomplex,
        lda: *mut integer,
    );
    pub fn clasr_(
        side: *mut c_char,
        pivot: *mut c_char,
        direct: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        c: *mut f32,
        s: *mut f32,
        a: *mut scomplex,
        lda: *mut integer,
    );
    pub fn classq_(
        n: *mut integer,
        x: *mut scomplex,
        incx: *mut integer,
        scale: *mut f32,
        sumsq: *mut f32,
    );
    pub fn claswlq_(
        m: *mut integer,
        n: *mut integer,
        mb: *mut integer,
        nb: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        t: *mut scomplex,
        ldt: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn claswp_(
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        k1: *mut integer,
        k2: *mut integer,
        ipiv: *mut integer,
        incx: *mut integer,
    );
    pub fn cla_syamv_(
        uplo: *mut integer,
        n: *mut integer,
        alpha: *mut f32,
        a: *mut scomplex,
        lda: *mut integer,
        x: *mut scomplex,
        incx: *mut integer,
        beta: *mut f32,
        y: *mut f32,
        incy: *mut integer,
    );
    pub fn clasyf_aa_(
        uplo: *mut c_char,
        j1: *mut integer,
        m: *mut integer,
        nb: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        h: *mut scomplex,
        ldh: *mut integer,
        work: *mut scomplex,
    );
    pub fn clasyf_(
        uplo: *mut c_char,
        n: *mut integer,
        nb: *mut integer,
        kb: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        w: *mut scomplex,
        ldw: *mut integer,
        info: *mut integer,
    );
    pub fn clasyf_rk_(
        uplo: *mut c_char,
        n: *mut integer,
        nb: *mut integer,
        kb: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        e: *mut scomplex,
        ipiv: *mut integer,
        w: *mut scomplex,
        ldw: *mut integer,
        info: *mut integer,
    );
    pub fn clasyf_rook_(
        uplo: *mut c_char,
        n: *mut integer,
        nb: *mut integer,
        kb: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        w: *mut scomplex,
        ldw: *mut integer,
        info: *mut integer,
    );
    pub fn cla_syrfsx_extended_(
        prec_type: *mut integer,
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        af: *mut scomplex,
        ldaf: *mut integer,
        ipiv: *mut integer,
        colequ: *mut logical,
        c: *mut f32,
        b: *mut scomplex,
        ldb: *mut integer,
        y: *mut scomplex,
        ldy: *mut integer,
        berr_out: *mut f32,
        n_norms: *mut integer,
        err_bnds_norm: *mut f32,
        err_bnds_comp: *mut f32,
        res: *mut scomplex,
        ayb: *mut f32,
        dy: *mut scomplex,
        y_tail: *mut scomplex,
        rcond: *mut f32,
        ithresh: *mut integer,
        rthresh: *mut f32,
        dz_ub: *mut f32,
        ignore_cwise: *mut logical,
        info: *mut integer,
    );
    pub fn clatbs_(
        uplo: *mut c_char,
        trans: *mut c_char,
        diag: *mut c_char,
        normin: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        x: *mut scomplex,
        scale: *mut f32,
        cnorm: *mut f32,
        info: *mut integer,
    );
    pub fn clatdf_(
        ijob: *mut integer,
        n: *mut integer,
        z: *mut scomplex,
        ldz: *mut integer,
        rhs: *mut scomplex,
        rdsum: *mut f32,
        rdscal: *mut f32,
        ipiv: *mut integer,
        jpiv: *mut integer,
    );
    pub fn clatps_(
        uplo: *mut c_char,
        trans: *mut c_char,
        diag: *mut c_char,
        normin: *mut c_char,
        n: *mut integer,
        ap: *mut scomplex,
        x: *mut scomplex,
        scale: *mut f32,
        cnorm: *mut f32,
        info: *mut integer,
    );
    pub fn clatrd_(
        uplo: *mut c_char,
        n: *mut integer,
        nb: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        e: *mut f32,
        tau: *mut scomplex,
        w: *mut scomplex,
        ldw: *mut integer,
    );
    pub fn clatrs_(
        uplo: *mut c_char,
        trans: *mut c_char,
        diag: *mut c_char,
        normin: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        x: *mut scomplex,
        scale: *mut f32,
        cnorm: *mut f32,
        info: *mut integer,
    );
    pub fn clatrz_(
        m: *mut integer,
        n: *mut integer,
        l: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        tau: *mut scomplex,
        work: *mut scomplex,
    );
    pub fn clatsqr_(
        m: *mut integer,
        n: *mut integer,
        mb: *mut integer,
        nb: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        t: *mut scomplex,
        ldt: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn clatzm_(
        side: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        v: *mut scomplex,
        incv: *mut integer,
        tau: *mut scomplex,
        c1: *mut scomplex,
        c2: *mut scomplex,
        ldc: *mut integer,
        work: *mut scomplex,
    );
    pub fn claunhr_col_getrfnp2_(
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        d: *mut scomplex,
        info: *mut integer,
    );
    pub fn claunhr_col_getrfnp_(
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        d: *mut scomplex,
        info: *mut integer,
    );
    pub fn clauu2_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn clauum_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn cla_wwaddw_(n: *mut integer, x: *mut scomplex, y: *mut scomplex, w: *mut scomplex);
    pub fn cpbcon_(
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        anorm: *mut f32,
        rcond: *mut f32,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn cpbequ_(
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        s: *mut f32,
        scond: *mut f32,
        amax: *mut f32,
        info: *mut integer,
    );
    pub fn cpbrfs_(
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        nrhs: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        afb: *mut scomplex,
        ldafb: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        x: *mut scomplex,
        ldx: *mut integer,
        ferr: *mut f32,
        berr: *mut f32,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn cpbstf_(
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        info: *mut integer,
    );
    pub fn cpbsv_(
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        nrhs: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn cpbsvx_(
        fact: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        nrhs: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        afb: *mut scomplex,
        ldafb: *mut integer,
        equed: *mut c_char,
        s: *mut f32,
        b: *mut scomplex,
        ldb: *mut integer,
        x: *mut scomplex,
        ldx: *mut integer,
        rcond: *mut f32,
        ferr: *mut f32,
        berr: *mut f32,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn cpbtf2_(
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        info: *mut integer,
    );
    pub fn cpbtrf_(
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        info: *mut integer,
    );
    pub fn cpbtrs_(
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        nrhs: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn cpftrf_(
        transr: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        info: *mut integer,
    );
    pub fn cpftri_(
        transr: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        info: *mut integer,
    );
    pub fn cpftrs_(
        transr: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        b: *mut scomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn cpocon_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        anorm: *mut f32,
        rcond: *mut f32,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn cpoequb_(
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        s: *mut f32,
        scond: *mut f32,
        amax: *mut f32,
        info: *mut integer,
    );
    pub fn cpoequ_(
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        s: *mut f32,
        scond: *mut f32,
        amax: *mut f32,
        info: *mut integer,
    );
    pub fn cporfs_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        af: *mut scomplex,
        ldaf: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        x: *mut scomplex,
        ldx: *mut integer,
        ferr: *mut f32,
        berr: *mut f32,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn cporfsx_(
        uplo: *mut c_char,
        equed: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        af: *mut scomplex,
        ldaf: *mut integer,
        s: *mut f32,
        b: *mut scomplex,
        ldb: *mut integer,
        x: *mut scomplex,
        ldx: *mut integer,
        rcond: *mut f32,
        berr: *mut f32,
        n_err_bnds: *mut integer,
        err_bnds_norm: *mut f32,
        err_bnds_comp: *mut f32,
        nparams: *mut integer,
        params: *mut f32,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn cposv_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn cposvx_(
        fact: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        af: *mut scomplex,
        ldaf: *mut integer,
        equed: *mut c_char,
        s: *mut f32,
        b: *mut scomplex,
        ldb: *mut integer,
        x: *mut scomplex,
        ldx: *mut integer,
        rcond: *mut f32,
        ferr: *mut f32,
        berr: *mut f32,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn cposvxx_(
        fact: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        af: *mut scomplex,
        ldaf: *mut integer,
        equed: *mut c_char,
        s: *mut f32,
        b: *mut scomplex,
        ldb: *mut integer,
        x: *mut scomplex,
        ldx: *mut integer,
        rcond: *mut f32,
        rpvgrw: *mut f32,
        berr: *mut f32,
        n_err_bnds: *mut integer,
        err_bnds_norm: *mut f32,
        err_bnds_comp: *mut f32,
        nparams: *mut integer,
        params: *mut f32,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn cpotf2_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn cpotrf2_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn cpotrf_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn cpotri_(
        uplo: *mut c_char,
        n: *mut integer,
        buff_A: *mut scomplex,
        ldim_A: *mut integer,
        info: *mut integer,
    );
    pub fn cpotrs_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn cppcon_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut scomplex,
        anorm: *mut f32,
        rcond: *mut f32,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn cppequ_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut scomplex,
        s: *mut f32,
        scond: *mut f32,
        amax: *mut f32,
        info: *mut integer,
    );
    pub fn cpprfs_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut scomplex,
        afp: *mut scomplex,
        b: *mut scomplex,
        ldb: *mut integer,
        x: *mut scomplex,
        ldx: *mut integer,
        ferr: *mut f32,
        berr: *mut f32,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn cppsv_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut scomplex,
        b: *mut scomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn cppsvx_(
        fact: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut scomplex,
        afp: *mut scomplex,
        equed: *mut c_char,
        s: *mut f32,
        b: *mut scomplex,
        ldb: *mut integer,
        x: *mut scomplex,
        ldx: *mut integer,
        rcond: *mut f32,
        ferr: *mut f32,
        berr: *mut f32,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn cpptrf_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut scomplex,
        info: *mut integer,
    );
    pub fn cpptri_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut scomplex,
        info: *mut integer,
    );
    pub fn cpptrs_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut scomplex,
        b: *mut scomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn cpstf2_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        piv: *mut integer,
        rank: *mut integer,
        tol: *mut f32,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn cpstrf_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        piv: *mut integer,
        rank: *mut integer,
        tol: *mut f32,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn cptcon_(
        n: *mut integer,
        d: *mut f32,
        e: *mut scomplex,
        anorm: *mut f32,
        rcond: *mut f32,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn cpteqr_(
        compz: *mut c_char,
        n: *mut integer,
        d: *mut f32,
        e: *mut f32,
        z: *mut scomplex,
        ldz: *mut integer,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn cptrfs_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        d: *mut f32,
        e: *mut scomplex,
        df: *mut f32,
        ef: *mut scomplex,
        b: *mut scomplex,
        ldb: *mut integer,
        x: *mut scomplex,
        ldx: *mut integer,
        ferr: *mut f32,
        berr: *mut f32,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn cptsv_(
        n: *mut integer,
        nrhs: *mut integer,
        d: *mut f32,
        e: *mut scomplex,
        b: *mut scomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn cptsvx_(
        fact: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        d: *mut f32,
        e: *mut scomplex,
        df: *mut f32,
        ef: *mut scomplex,
        b: *mut scomplex,
        ldb: *mut integer,
        x: *mut scomplex,
        ldx: *mut integer,
        rcond: *mut f32,
        ferr: *mut f32,
        berr: *mut f32,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn cpttrf_(n: *mut integer, d: *mut f32, e: *mut scomplex, info: *mut integer);
    pub fn cpttrs_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        d: *mut f32,
        e: *mut scomplex,
        b: *mut scomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn cptts2_(
        iuplo: *mut integer,
        n: *mut integer,
        nrhs: *mut integer,
        d: *mut f32,
        e: *mut scomplex,
        b: *mut scomplex,
        ldb: *mut integer,
    );
    pub fn crot_(
        n: *mut integer,
        cx: *mut scomplex,
        incx: *mut integer,
        cy: *mut scomplex,
        incy: *mut integer,
        c: *mut f32,
        s: *mut scomplex,
    );
    pub fn cspcon_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut scomplex,
        ipiv: *mut integer,
        anorm: *mut f32,
        rcond: *mut f32,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn cspmv_(
        uplo: *mut c_char,
        n: *mut integer,
        alpha: *mut scomplex,
        ap: *mut scomplex,
        x: *mut scomplex,
        incx: *mut integer,
        beta: *mut scomplex,
        y: *mut scomplex,
        incy: *mut integer,
    );
    pub fn cspr_(
        uplo: *mut c_char,
        n: *mut integer,
        alpha: *mut scomplex,
        x: *mut scomplex,
        incx: *mut integer,
        ap: *mut scomplex,
    );
    pub fn csprfs_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut scomplex,
        afp: *mut scomplex,
        ipiv: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        x: *mut scomplex,
        ldx: *mut integer,
        ferr: *mut f32,
        berr: *mut f32,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn cspsv_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut scomplex,
        ipiv: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn cspsvx_(
        fact: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut scomplex,
        afp: *mut scomplex,
        ipiv: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        x: *mut scomplex,
        ldx: *mut integer,
        rcond: *mut f32,
        ferr: *mut f32,
        berr: *mut f32,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn csptrf_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut scomplex,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn csptri_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut scomplex,
        ipiv: *mut integer,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn csptrs_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut scomplex,
        ipiv: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn csrscl_(n: *mut integer, sa: *mut f32, sx: *mut scomplex, incx: *mut integer);
    pub fn cstedc_(
        compz: *mut c_char,
        n: *mut integer,
        d: *mut f32,
        e: *mut f32,
        z: *mut scomplex,
        ldz: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        lrwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn cstegr_(
        jobz: *mut c_char,
        range: *mut c_char,
        n: *mut integer,
        d: *mut f32,
        e: *mut f32,
        vl: *mut f32,
        vu: *mut f32,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f32,
        m: *mut integer,
        w: *mut f32,
        z: *mut scomplex,
        ldz: *mut integer,
        isuppz: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn cstein_(
        n: *mut integer,
        d: *mut f32,
        e: *mut f32,
        m: *mut integer,
        w: *mut f32,
        iblock: *mut integer,
        isplit: *mut integer,
        z: *mut scomplex,
        ldz: *mut integer,
        work: *mut f32,
        iwork: *mut integer,
        ifail: *mut integer,
        info: *mut integer,
    );
    pub fn cstemr_(
        jobz: *mut c_char,
        range: *mut c_char,
        n: *mut integer,
        d: *mut f32,
        e: *mut f32,
        vl: *mut f32,
        vu: *mut f32,
        il: *mut integer,
        iu: *mut integer,
        m: *mut integer,
        w: *mut f32,
        z: *mut scomplex,
        ldz: *mut integer,
        nzc: *mut integer,
        isuppz: *mut integer,
        tryrac: *mut logical,
        work: *mut f32,
        lwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn csteqr_(
        compz: *mut c_char,
        n: *mut integer,
        d: *mut f32,
        e: *mut f32,
        z: *mut scomplex,
        ldz: *mut integer,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn csycon_3_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        e: *mut scomplex,
        ipiv: *mut integer,
        anorm: *mut f32,
        rcond: *mut f32,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn csycon_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        anorm: *mut f32,
        rcond: *mut f32,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn csycon_rook_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        anorm: *mut f32,
        rcond: *mut f32,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn csyconv_(
        uplo: *mut c_char,
        way: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn csyconvf_(
        uplo: *mut c_char,
        way: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        e: *mut scomplex,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn csyconvf_rook_(
        uplo: *mut c_char,
        way: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        e: *mut scomplex,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn csyequb_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        s: *mut f32,
        scond: *mut f32,
        amax: *mut f32,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn csymv_(
        uplo: *mut c_char,
        n: *mut integer,
        alpha: *mut scomplex,
        a: *mut scomplex,
        lda: *mut integer,
        x: *mut scomplex,
        incx: *mut integer,
        beta: *mut scomplex,
        y: *mut scomplex,
        incy: *mut integer,
    );
    pub fn csyr_(
        uplo: *mut c_char,
        n: *mut integer,
        alpha: *mut scomplex,
        x: *mut scomplex,
        incx: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
    );
    pub fn csyrfs_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        af: *mut scomplex,
        ldaf: *mut integer,
        ipiv: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        x: *mut scomplex,
        ldx: *mut integer,
        ferr: *mut f32,
        berr: *mut f32,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn csyrfsx_(
        uplo: *mut c_char,
        equed: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        af: *mut scomplex,
        ldaf: *mut integer,
        ipiv: *mut integer,
        s: *mut f32,
        b: *mut scomplex,
        ldb: *mut integer,
        x: *mut scomplex,
        ldx: *mut integer,
        rcond: *mut f32,
        berr: *mut f32,
        n_err_bnds: *mut integer,
        err_bnds_norm: *mut f32,
        err_bnds_comp: *mut f32,
        nparams: *mut integer,
        params: *mut f32,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn csysv_aa_2stage_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        tb: *mut scomplex,
        ltb: *mut integer,
        ipiv: *mut integer,
        ipiv2: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn csysv_aa_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn csysv_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn csysv_rk_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        e: *mut scomplex,
        ipiv: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn csysv_rook_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn csysvx_(
        fact: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        af: *mut scomplex,
        ldaf: *mut integer,
        ipiv: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        x: *mut scomplex,
        ldx: *mut integer,
        rcond: *mut f32,
        ferr: *mut f32,
        berr: *mut f32,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn csysvxx_(
        fact: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        af: *mut scomplex,
        ldaf: *mut integer,
        ipiv: *mut integer,
        equed: *mut c_char,
        s: *mut f32,
        b: *mut scomplex,
        ldb: *mut integer,
        x: *mut scomplex,
        ldx: *mut integer,
        rcond: *mut f32,
        rpvgrw: *mut f32,
        berr: *mut f32,
        n_err_bnds: *mut integer,
        err_bnds_norm: *mut f32,
        err_bnds_comp: *mut f32,
        nparams: *mut integer,
        params: *mut f32,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn csyswapr_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        i1: *mut integer,
        i2: *mut integer,
    );
    pub fn csytf2_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn csytf2_rk_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        e: *mut scomplex,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn csytf2_rook_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn csytrf_aa_2stage_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        tb: *mut scomplex,
        ltb: *mut integer,
        ipiv: *mut integer,
        ipiv2: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn csytrf_aa_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn csytrf_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn csytrf_rk_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        e: *mut scomplex,
        ipiv: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn csytrf_rook_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn csytri2_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn csytri2x_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut scomplex,
        nb: *mut integer,
        info: *mut integer,
    );
    pub fn csytri_3_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        e: *mut scomplex,
        ipiv: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn csytri_3x_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        e: *mut scomplex,
        ipiv: *mut integer,
        work: *mut scomplex,
        nb: *mut integer,
        info: *mut integer,
    );
    pub fn csytri_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn csytri_rook_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn csytrs2_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn csytrs_3_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        e: *mut scomplex,
        ipiv: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn csytrs_aa_2stage_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        tb: *mut scomplex,
        ltb: *mut integer,
        ipiv: *mut integer,
        ipiv2: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn csytrs_aa_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn csytrs_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn csytrs_rook_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn ctbcon_(
        norm: *mut c_char,
        uplo: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        rcond: *mut f32,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn ctbrfs_(
        uplo: *mut c_char,
        trans: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        nrhs: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        x: *mut scomplex,
        ldx: *mut integer,
        ferr: *mut f32,
        berr: *mut f32,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn ctbtrs_(
        uplo: *mut c_char,
        trans: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        nrhs: *mut integer,
        ab: *mut scomplex,
        ldab: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn ctfsm_(
        transr: *mut c_char,
        side: *mut c_char,
        uplo: *mut c_char,
        trans: *mut c_char,
        diag: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        alpha: *mut scomplex,
        a: *mut scomplex,
        b: *mut scomplex,
        ldb: *mut integer,
    );
    pub fn ctftri_(
        transr: *mut c_char,
        uplo: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        info: *mut integer,
    );
    pub fn ctfttp_(
        transr: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        arf: *mut scomplex,
        ap: *mut scomplex,
        info: *mut integer,
    );
    pub fn ctfttr_(
        transr: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        arf: *mut scomplex,
        a: *mut scomplex,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn ctgevc_(
        side: *mut c_char,
        howmny: *mut c_char,
        select: *mut logical,
        n: *mut integer,
        s: *mut scomplex,
        lds: *mut integer,
        p: *mut scomplex,
        ldp: *mut integer,
        vl: *mut scomplex,
        ldvl: *mut integer,
        vr: *mut scomplex,
        ldvr: *mut integer,
        mm: *mut integer,
        m: *mut integer,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn ctgex2_(
        wantq: *mut logical,
        wantz: *mut logical,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        q: *mut scomplex,
        ldq: *mut integer,
        z: *mut scomplex,
        ldz: *mut integer,
        j1: *mut integer,
        info: *mut integer,
    );
    pub fn ctgexc_(
        wantq: *mut logical,
        wantz: *mut logical,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        q: *mut scomplex,
        ldq: *mut integer,
        z: *mut scomplex,
        ldz: *mut integer,
        ifst: *mut integer,
        ilst: *mut integer,
        info: *mut integer,
    );
    pub fn ctgsen_(
        ijob: *mut integer,
        wantq: *mut logical,
        wantz: *mut logical,
        select: *mut logical,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        alpha: *mut scomplex,
        beta: *mut scomplex,
        q: *mut scomplex,
        ldq: *mut integer,
        z: *mut scomplex,
        ldz: *mut integer,
        m: *mut integer,
        pl: *mut f32,
        pr: *mut f32,
        dif: *mut f32,
        work: *mut scomplex,
        lwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn ctgsja_(
        jobu: *mut c_char,
        jobv: *mut c_char,
        jobq: *mut c_char,
        m: *mut integer,
        p: *mut integer,
        n: *mut integer,
        k: *mut integer,
        l: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        tola: *mut f32,
        tolb: *mut f32,
        alpha: *mut f32,
        beta: *mut f32,
        u: *mut scomplex,
        ldu: *mut integer,
        v: *mut scomplex,
        ldv: *mut integer,
        q: *mut scomplex,
        ldq: *mut integer,
        work: *mut scomplex,
        ncycle: *mut integer,
        info: *mut integer,
    );
    pub fn ctgsna_(
        job: *mut c_char,
        howmny: *mut c_char,
        select: *mut logical,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        vl: *mut scomplex,
        ldvl: *mut integer,
        vr: *mut scomplex,
        ldvr: *mut integer,
        s: *mut f32,
        dif: *mut f32,
        mm: *mut integer,
        m: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn ctgsy2_(
        trans: *mut c_char,
        ijob: *mut integer,
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        c: *mut scomplex,
        ldc: *mut integer,
        d: *mut scomplex,
        ldd: *mut integer,
        e: *mut scomplex,
        lde: *mut integer,
        f: *mut scomplex,
        ldf: *mut integer,
        scale: *mut f32,
        rdsum: *mut f32,
        rdscal: *mut f32,
        info: *mut integer,
    );
    pub fn ctgsyl_(
        trans: *mut c_char,
        ijob: *mut integer,
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        c: *mut scomplex,
        ldc: *mut integer,
        d: *mut scomplex,
        ldd: *mut integer,
        e: *mut scomplex,
        lde: *mut integer,
        f: *mut scomplex,
        ldf: *mut integer,
        scale: *mut f32,
        dif: *mut f32,
        work: *mut scomplex,
        lwork: *mut integer,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn ctpcon_(
        norm: *mut c_char,
        uplo: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        ap: *mut scomplex,
        rcond: *mut f32,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn ctplqt2_(
        m: *mut integer,
        n: *mut integer,
        l: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        t: *mut scomplex,
        ldt: *mut integer,
        info: *mut integer,
    );
    pub fn ctplqt_(
        m: *mut integer,
        n: *mut integer,
        l: *mut integer,
        mb: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        t: *mut scomplex,
        ldt: *mut integer,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn ctpmlqt_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        l: *mut integer,
        mb: *mut integer,
        v: *mut scomplex,
        ldv: *mut integer,
        t: *mut scomplex,
        ldt: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn ctpmqrt_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        l: *mut integer,
        nb: *mut integer,
        v: *mut scomplex,
        ldv: *mut integer,
        t: *mut scomplex,
        ldt: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn ctpqrt2_(
        m: *mut integer,
        n: *mut integer,
        l: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        t: *mut scomplex,
        ldt: *mut integer,
        info: *mut integer,
    );
    pub fn ctpqrt_(
        m: *mut integer,
        n: *mut integer,
        l: *mut integer,
        nb: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        t: *mut scomplex,
        ldt: *mut integer,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn ctprfb_(
        side: *mut c_char,
        trans: *mut c_char,
        direct: *mut c_char,
        storev: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        l: *mut integer,
        v: *mut scomplex,
        ldv: *mut integer,
        t: *mut scomplex,
        ldt: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        work: *mut scomplex,
        ldwork: *mut integer,
    );
    pub fn ctprfs_(
        uplo: *mut c_char,
        trans: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut scomplex,
        b: *mut scomplex,
        ldb: *mut integer,
        x: *mut scomplex,
        ldx: *mut integer,
        ferr: *mut f32,
        berr: *mut f32,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn ctptri_(
        uplo: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        ap: *mut scomplex,
        info: *mut integer,
    );
    pub fn ctptrs_(
        uplo: *mut c_char,
        trans: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut scomplex,
        b: *mut scomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn ctpttf_(
        transr: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut scomplex,
        arf: *mut scomplex,
        info: *mut integer,
    );
    pub fn ctpttr_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut scomplex,
        a: *mut scomplex,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn ctrcon_(
        norm: *mut c_char,
        uplo: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        rcond: *mut f32,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn ctrevc3_(
        side: *mut c_char,
        howmny: *mut c_char,
        select: *mut logical,
        n: *mut integer,
        t: *mut scomplex,
        ldt: *mut integer,
        vl: *mut scomplex,
        ldvl: *mut integer,
        vr: *mut scomplex,
        ldvr: *mut integer,
        mm: *mut integer,
        m: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        lrwork: *mut integer,
        info: *mut integer,
    );
    pub fn ctrevc_(
        side: *mut c_char,
        howmny: *mut c_char,
        select: *mut logical,
        n: *mut integer,
        t: *mut scomplex,
        ldt: *mut integer,
        vl: *mut scomplex,
        ldvl: *mut integer,
        vr: *mut scomplex,
        ldvr: *mut integer,
        mm: *mut integer,
        m: *mut integer,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn ctrexc_(
        compq: *mut c_char,
        n: *mut integer,
        t: *mut scomplex,
        ldt: *mut integer,
        q: *mut scomplex,
        ldq: *mut integer,
        ifst: *mut integer,
        ilst: *mut integer,
        info: *mut integer,
    );
    pub fn ctrrfs_(
        uplo: *mut c_char,
        trans: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        x: *mut scomplex,
        ldx: *mut integer,
        ferr: *mut f32,
        berr: *mut f32,
        work: *mut scomplex,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn ctrsen_(
        job: *mut c_char,
        compq: *mut c_char,
        select: *mut logical,
        n: *mut integer,
        t: *mut scomplex,
        ldt: *mut integer,
        q: *mut scomplex,
        ldq: *mut integer,
        w: *mut scomplex,
        m: *mut integer,
        s: *mut f32,
        sep: *mut f32,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn ctrsna_(
        job: *mut c_char,
        howmny: *mut c_char,
        select: *mut logical,
        n: *mut integer,
        t: *mut scomplex,
        ldt: *mut integer,
        vl: *mut scomplex,
        ldvl: *mut integer,
        vr: *mut scomplex,
        ldvr: *mut integer,
        s: *mut f32,
        sep: *mut f32,
        mm: *mut integer,
        m: *mut integer,
        work: *mut scomplex,
        ldwork: *mut integer,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn ctrsyl_(
        trana: *mut c_char,
        tranb: *mut c_char,
        isgn: *mut integer,
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        c: *mut scomplex,
        ldc: *mut integer,
        scale: *mut f32,
        info: *mut integer,
    );
    pub fn ctrti2_(
        uplo: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn ctrtri_(
        uplo: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn ctrtrs_(
        uplo: *mut c_char,
        trans: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        b: *mut scomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn ctrttf_(
        transr: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        arf: *mut scomplex,
        info: *mut integer,
    );
    pub fn ctrttp_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        ap: *mut scomplex,
        info: *mut integer,
    );
    pub fn ctzrqf_(
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        tau: *mut scomplex,
        info: *mut integer,
    );
    pub fn ctzrzf_(
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        tau: *mut scomplex,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn cunbdb1_(
        m: *mut integer,
        p: *mut integer,
        q: *mut integer,
        x11: *mut scomplex,
        ldx11: *mut integer,
        x21: *mut scomplex,
        ldx21: *mut integer,
        theta: *mut f32,
        phi: *mut f32,
        taup1: *mut scomplex,
        taup2: *mut scomplex,
        tauq1: *mut scomplex,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn cunbdb2_(
        m: *mut integer,
        p: *mut integer,
        q: *mut integer,
        x11: *mut scomplex,
        ldx11: *mut integer,
        x21: *mut scomplex,
        ldx21: *mut integer,
        theta: *mut f32,
        phi: *mut f32,
        taup1: *mut scomplex,
        taup2: *mut scomplex,
        tauq1: *mut scomplex,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn cunbdb3_(
        m: *mut integer,
        p: *mut integer,
        q: *mut integer,
        x11: *mut scomplex,
        ldx11: *mut integer,
        x21: *mut scomplex,
        ldx21: *mut integer,
        theta: *mut f32,
        phi: *mut f32,
        taup1: *mut scomplex,
        taup2: *mut scomplex,
        tauq1: *mut scomplex,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn cunbdb4_(
        m: *mut integer,
        p: *mut integer,
        q: *mut integer,
        x11: *mut scomplex,
        ldx11: *mut integer,
        x21: *mut scomplex,
        ldx21: *mut integer,
        theta: *mut f32,
        phi: *mut f32,
        taup1: *mut scomplex,
        taup2: *mut scomplex,
        tauq1: *mut scomplex,
        phantom: *mut scomplex,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn cunbdb5_(
        m1: *mut integer,
        m2: *mut integer,
        n: *mut integer,
        x1: *mut scomplex,
        incx1: *mut integer,
        x2: *mut scomplex,
        incx2: *mut integer,
        q1: *mut scomplex,
        ldq1: *mut integer,
        q2: *mut scomplex,
        ldq2: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn cunbdb6_(
        m1: *mut integer,
        m2: *mut integer,
        n: *mut integer,
        x1: *mut scomplex,
        incx1: *mut integer,
        x2: *mut scomplex,
        incx2: *mut integer,
        q1: *mut scomplex,
        ldq1: *mut integer,
        q2: *mut scomplex,
        ldq2: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn cunbdb_(
        trans: *mut c_char,
        signs: *mut c_char,
        m: *mut integer,
        p: *mut integer,
        q: *mut integer,
        x11: *mut scomplex,
        ldx11: *mut integer,
        x12: *mut scomplex,
        ldx12: *mut integer,
        x21: *mut scomplex,
        ldx21: *mut integer,
        x22: *mut scomplex,
        ldx22: *mut integer,
        theta: *mut f32,
        phi: *mut f32,
        taup1: *mut scomplex,
        taup2: *mut scomplex,
        tauq1: *mut scomplex,
        tauq2: *mut scomplex,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn cuncsd2by1_(
        jobu1: *mut c_char,
        jobu2: *mut c_char,
        jobv1t: *mut c_char,
        m: *mut integer,
        p: *mut integer,
        q: *mut integer,
        x11: *mut scomplex,
        ldx11: *mut integer,
        x21: *mut scomplex,
        ldx21: *mut integer,
        theta: *mut f32,
        u1: *mut scomplex,
        ldu1: *mut integer,
        u2: *mut scomplex,
        ldu2: *mut integer,
        v1t: *mut scomplex,
        ldv1t: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        lrwork: *mut integer,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn cuncsd_(
        jobu1: *mut c_char,
        jobu2: *mut c_char,
        jobv1t: *mut c_char,
        jobv2t: *mut c_char,
        trans: *mut c_char,
        signs: *mut c_char,
        m: *mut integer,
        p: *mut integer,
        q: *mut integer,
        x11: *mut scomplex,
        ldx11: *mut integer,
        x12: *mut scomplex,
        ldx12: *mut integer,
        x21: *mut scomplex,
        ldx21: *mut integer,
        x22: *mut scomplex,
        ldx22: *mut integer,
        theta: *mut f32,
        u1: *mut scomplex,
        ldu1: *mut integer,
        u2: *mut scomplex,
        ldu2: *mut integer,
        v1t: *mut scomplex,
        ldv1t: *mut integer,
        v2t: *mut scomplex,
        ldv2t: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        rwork: *mut f32,
        lrwork: *mut integer,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn cung2l_(
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        tau: *mut scomplex,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn cung2r_(
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        tau: *mut scomplex,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn cungbr_(
        vect: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        tau: *mut scomplex,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn cunghr_(
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        tau: *mut scomplex,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn cungl2_(
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        tau: *mut scomplex,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn cunglq_(
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        tau: *mut scomplex,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn cungql_(
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        tau: *mut scomplex,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn cungqr_(
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        tau: *mut scomplex,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn cungr2_(
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        tau: *mut scomplex,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn cungrq_(
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        tau: *mut scomplex,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn cungtr_(
        uplo: *mut c_char,
        m: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        tau: *mut scomplex,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn cungtsqr_(
        m: *mut integer,
        n: *mut integer,
        mb: *mut integer,
        nb: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        t: *mut scomplex,
        ldt: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn cunhr_col_(
        m: *mut integer,
        n: *mut integer,
        nb: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        t: *mut scomplex,
        ldt: *mut integer,
        d: *mut scomplex,
        info: *mut integer,
    );
    pub fn cunm22_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        n1: *mut integer,
        n2: *mut integer,
        q: *mut scomplex,
        ldq: *mut integer,
        c: *mut scomplex,
        ldc: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn cunm2l_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        tau: *mut scomplex,
        c: *mut scomplex,
        ldc: *mut integer,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn cunm2r_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        tau: *mut scomplex,
        c: *mut scomplex,
        ldc: *mut integer,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn cunmbr_(
        vect: *mut c_char,
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        tau: *mut scomplex,
        c: *mut scomplex,
        ldc: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn cunmhr_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        tau: *mut scomplex,
        c: *mut scomplex,
        ldc: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn cunml2_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        tau: *mut scomplex,
        c: *mut scomplex,
        ldc: *mut integer,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn cunmlq_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        tau: *mut scomplex,
        c: *mut scomplex,
        ldc: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn cunmql_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        tau: *mut scomplex,
        c: *mut scomplex,
        ldc: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn cunmqr_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        tau: *mut scomplex,
        c: *mut scomplex,
        ldc: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn cunmr2_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        tau: *mut scomplex,
        c: *mut scomplex,
        ldc: *mut integer,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn cunmr3_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        l: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        tau: *mut scomplex,
        c: *mut scomplex,
        ldc: *mut integer,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn cunmrq_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        tau: *mut scomplex,
        c: *mut scomplex,
        ldc: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn cunmrz_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        l: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        tau: *mut scomplex,
        c: *mut scomplex,
        ldc: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn cunmtr_(
        side: *mut c_char,
        uplo: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        tau: *mut scomplex,
        c: *mut scomplex,
        ldc: *mut integer,
        work: *mut scomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn cupgtr_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut scomplex,
        tau: *mut scomplex,
        q: *mut scomplex,
        ldq: *mut integer,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn cupmtr_(
        side: *mut c_char,
        uplo: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        ap: *mut scomplex,
        tau: *mut scomplex,
        c: *mut scomplex,
        ldc: *mut integer,
        work: *mut scomplex,
        info: *mut integer,
    );
    pub fn dbbcsd_(
        jobu1: *mut c_char,
        jobu2: *mut c_char,
        jobv1t: *mut c_char,
        jobv2t: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        p: *mut integer,
        q: *mut integer,
        theta: *mut f64,
        phi: *mut f64,
        u1: *mut f64,
        ldu1: *mut integer,
        u2: *mut f64,
        ldu2: *mut integer,
        v1t: *mut f64,
        ldv1t: *mut integer,
        v2t: *mut f64,
        ldv2t: *mut integer,
        b11d: *mut f64,
        b11e: *mut f64,
        b12d: *mut f64,
        b12e: *mut f64,
        b21d: *mut f64,
        b21e: *mut f64,
        b22d: *mut f64,
        b22e: *mut f64,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dbdsdc_(
        uplo: *mut c_char,
        compq: *mut c_char,
        n: *mut integer,
        d: *mut f64,
        e: *mut f64,
        u: *mut f64,
        ldu: *mut integer,
        vt: *mut f64,
        ldvt: *mut integer,
        q: *mut f64,
        iq: *mut f64,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dbdsqr_(
        uplo: *mut c_char,
        n: *mut integer,
        ncvt: *mut integer,
        nru: *mut integer,
        ncc: *mut integer,
        d: *mut f64,
        e: *mut f64,
        vt: *mut f64,
        ldvt: *mut integer,
        u: *mut f64,
        ldu: *mut integer,
        c: *mut f64,
        ldc: *mut integer,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn dbdsvdx_(
        uplo: *mut c_char,
        jobz: *mut c_char,
        range: *mut c_char,
        n: *mut integer,
        d: *mut f64,
        e: *mut f64,
        vl: *mut f64,
        vu: *mut f64,
        il: *mut integer,
        iu: *mut integer,
        ns: *mut integer,
        s: *mut f64,
        z: *mut f64,
        ldz: *mut integer,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dcombssq_(v1: *mut f64, v2: *mut f64);
    pub fn ddisna_(
        job: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        d: *mut f64,
        sep: *mut f64,
        info: *mut integer,
    );
    pub fn dgbbrd_(
        vect: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        ncc: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        ab: *mut f64,
        ldab: *mut integer,
        d: *mut f64,
        e: *mut f64,
        q: *mut f64,
        ldq: *mut integer,
        pt: *mut f64,
        ldpt: *mut integer,
        c: *mut f64,
        ldc: *mut integer,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dgbcon_(
        norm: *mut c_char,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        ab: *mut f64,
        ldab: *mut integer,
        ipiv: *mut integer,
        anorm: *mut f64,
        rcond: *mut f64,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dgbequb_(
        m: *mut integer,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        ab: *mut f64,
        ldab: *mut integer,
        r: *mut f64,
        c: *mut f64,
        rowcnd: *mut f64,
        colcnd: *mut f64,
        amax: *mut f64,
        info: *mut integer,
    );
    pub fn dgbequ_(
        m: *mut integer,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        ab: *mut f64,
        ldab: *mut integer,
        r: *mut f64,
        c: *mut f64,
        rowcnd: *mut f64,
        colcnd: *mut f64,
        amax: *mut f64,
        info: *mut integer,
    );
    pub fn dgbrfs_(
        trans: *mut c_char,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        nrhs: *mut integer,
        ab: *mut f64,
        ldab: *mut integer,
        afb: *mut f64,
        ldafb: *mut integer,
        ipiv: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        x: *mut f64,
        ldx: *mut integer,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dgbrfsx_(
        trans: *mut c_char,
        equed: *mut c_char,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        nrhs: *mut integer,
        ab: *mut f64,
        ldab: *mut integer,
        afb: *mut f64,
        ldafb: *mut integer,
        ipiv: *mut integer,
        r: *mut f64,
        c: *mut f64,
        b: *mut f64,
        ldb: *mut integer,
        x: *mut f64,
        ldx: *mut integer,
        rcond: *mut f64,
        berr: *mut f64,
        n_err_bnds: *mut integer,
        err_bnds_norm: *mut f64,
        err_bnds_comp: *mut f64,
        nparams: *mut integer,
        params: *mut f64,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dgbsv_(
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        nrhs: *mut integer,
        ab: *mut f64,
        ldab: *mut integer,
        ipiv: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn dgbsvx_(
        fact: *mut c_char,
        trans: *mut c_char,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        nrhs: *mut integer,
        ab: *mut f64,
        ldab: *mut integer,
        afb: *mut f64,
        ldafb: *mut integer,
        ipiv: *mut integer,
        equed: *mut c_char,
        r: *mut f64,
        c: *mut f64,
        b: *mut f64,
        ldb: *mut integer,
        x: *mut f64,
        ldx: *mut integer,
        rcond: *mut f64,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dgbsvxx_(
        fact: *mut c_char,
        trans: *mut c_char,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        nrhs: *mut integer,
        ab: *mut f64,
        ldab: *mut integer,
        afb: *mut f64,
        ldafb: *mut integer,
        ipiv: *mut integer,
        equed: *mut c_char,
        r: *mut f64,
        c: *mut f64,
        b: *mut f64,
        ldb: *mut integer,
        x: *mut f64,
        ldx: *mut integer,
        rcond: *mut f64,
        rpvgrw: *mut f64,
        berr: *mut f64,
        n_err_bnds: *mut integer,
        err_bnds_norm: *mut f64,
        err_bnds_comp: *mut f64,
        nparams: *mut integer,
        params: *mut f64,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dgbtf2_(
        m: *mut integer,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        ab: *mut f64,
        ldab: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn dgbtrf_(
        m: *mut integer,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        ab: *mut f64,
        ldab: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn dgbtrs_(
        trans: *mut c_char,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        nrhs: *mut integer,
        ab: *mut f64,
        ldab: *mut integer,
        ipiv: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn dgebak_(
        job: *mut c_char,
        side: *mut c_char,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        scale: *mut f64,
        m: *mut integer,
        v: *mut f64,
        ldv: *mut integer,
        info: *mut integer,
    );
    pub fn dgebal_(
        job: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        scale: *mut f64,
        info: *mut integer,
    );
    pub fn dgebd2_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        d: *mut f64,
        e: *mut f64,
        tauq: *mut f64,
        taup: *mut f64,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dgebrd_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        d: *mut f64,
        e: *mut f64,
        tauq: *mut f64,
        taup: *mut f64,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dgecon_(
        norm: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        anorm: *mut f64,
        rcond: *mut f64,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dgeequb_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        r: *mut f64,
        c: *mut f64,
        rowcnd: *mut f64,
        colcnd: *mut f64,
        amax: *mut f64,
        info: *mut integer,
    );
    pub fn dgeequ_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        r: *mut f64,
        c: *mut f64,
        rowcnd: *mut f64,
        colcnd: *mut f64,
        amax: *mut f64,
        info: *mut integer,
    );
    pub fn dgees_(
        jobvs: *mut c_char,
        sort: *mut c_char,
        select: L_fp,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        sdim: *mut integer,
        wr: *mut f64,
        wi: *mut f64,
        vs: *mut f64,
        ldvs: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        bwork: *mut logical,
        info: *mut integer,
    );
    pub fn dgeesx_(
        jobvs: *mut c_char,
        sort: *mut c_char,
        select: L_fp,
        sense: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        sdim: *mut integer,
        wr: *mut f64,
        wi: *mut f64,
        vs: *mut f64,
        ldvs: *mut integer,
        rconde: *mut f64,
        rcondv: *mut f64,
        work: *mut f64,
        lwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        bwork: *mut logical,
        info: *mut integer,
    );
    pub fn dgeev_(
        jobvl: *mut c_char,
        jobvr: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        wr: *mut f64,
        wi: *mut f64,
        vl: *mut f64,
        ldvl: *mut integer,
        vr: *mut f64,
        ldvr: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dgeevx_(
        balanc: *mut c_char,
        jobvl: *mut c_char,
        jobvr: *mut c_char,
        sense: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        wr: *mut f64,
        wi: *mut f64,
        vl: *mut f64,
        ldvl: *mut integer,
        vr: *mut f64,
        ldvr: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        scale: *mut f64,
        abnrm: *mut f64,
        rconde: *mut f64,
        rcondv: *mut f64,
        work: *mut f64,
        lwork: *mut integer,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dgegs_(
        jobvsl: *mut c_char,
        jobvsr: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        alphar: *mut f64,
        alphai: *mut f64,
        beta: *mut f64,
        vsl: *mut f64,
        ldvsl: *mut integer,
        vsr: *mut f64,
        ldvsr: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dgegv_(
        jobvl: *mut c_char,
        jobvr: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        alphar: *mut f64,
        alphai: *mut f64,
        beta: *mut f64,
        vl: *mut f64,
        ldvl: *mut integer,
        vr: *mut f64,
        ldvr: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dgehd2_(
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        tau: *mut f64,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dgehrd_(
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        tau: *mut f64,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dgejsv_(
        joba: *mut c_char,
        jobu: *mut c_char,
        jobv: *mut c_char,
        jobr: *mut c_char,
        jobt: *mut c_char,
        jobp: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        sva: *mut f64,
        u: *mut f64,
        ldu: *mut integer,
        v: *mut f64,
        ldv: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dgelq2_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        tau: *mut f64,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dgelqf_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        tau: *mut f64,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dgelq_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        t: *mut f64,
        tsize: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dgelqt3_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        t: *mut f64,
        ldt: *mut integer,
        info: *mut integer,
    );
    pub fn dgelqt_(
        m: *mut integer,
        n: *mut integer,
        mb: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        t: *mut f64,
        ldt: *mut integer,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dgels_(
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dgelsd_(
        m: *mut integer,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        s: *mut f64,
        rcond: *mut f64,
        rank: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dgelss_(
        m: *mut integer,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        s: *mut f64,
        rcond: *mut f64,
        rank: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dgelsx_(
        m: *mut integer,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        jpvt: *mut integer,
        rcond: *mut f64,
        rank: *mut integer,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dgelsy_(
        m: *mut integer,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        jpvt: *mut integer,
        rcond: *mut f64,
        rank: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dgemlq_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        t: *mut f64,
        tsize: *mut integer,
        c: *mut f64,
        ldc: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dgemlqt_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        mb: *mut integer,
        v: *mut f64,
        ldv: *mut integer,
        t: *mut f64,
        ldt: *mut integer,
        c: *mut f64,
        ldc: *mut integer,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dgemqr_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        t: *mut f64,
        tsize: *mut integer,
        c: *mut f64,
        ldc: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dgemqrt_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        nb: *mut integer,
        v: *mut f64,
        ldv: *mut integer,
        t: *mut f64,
        ldt: *mut integer,
        c: *mut f64,
        ldc: *mut integer,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dgeql2_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        tau: *mut f64,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dgeqlf_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        tau: *mut f64,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dgeqp3_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        jpvt: *mut integer,
        tau: *mut f64,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dgeqpf_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        jpvt: *mut integer,
        tau: *mut f64,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dgeqr2_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        tau: *mut f64,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dgeqr2p_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        tau: *mut f64,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dgeqrf_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        tau: *mut f64,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dgeqrfp_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        tau: *mut f64,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dgeqr_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        t: *mut f64,
        tsize: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dgeqrt2_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        t: *mut f64,
        ldt: *mut integer,
        info: *mut integer,
    );
    pub fn dgeqrt3_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        t: *mut f64,
        ldt: *mut integer,
        info: *mut integer,
    );
    pub fn dgeqrt_(
        m: *mut integer,
        n: *mut integer,
        nb: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        t: *mut f64,
        ldt: *mut integer,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dgerfs_(
        trans: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        af: *mut f64,
        ldaf: *mut integer,
        ipiv: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        x: *mut f64,
        ldx: *mut integer,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dgerfsx_(
        trans: *mut c_char,
        equed: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        af: *mut f64,
        ldaf: *mut integer,
        ipiv: *mut integer,
        r: *mut f64,
        c: *mut f64,
        b: *mut f64,
        ldb: *mut integer,
        x: *mut f64,
        ldx: *mut integer,
        rcond: *mut f64,
        berr: *mut f64,
        n_err_bnds: *mut integer,
        err_bnds_norm: *mut f64,
        err_bnds_comp: *mut f64,
        nparams: *mut integer,
        params: *mut f64,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dgerq2_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        tau: *mut f64,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dgerqf_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        tau: *mut f64,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dgesc2_(
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        rhs: *mut f64,
        ipiv: *mut integer,
        jpiv: *mut integer,
        scale: *mut f64,
    );
    pub fn dgesdd_(
        jobz: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        s: *mut f64,
        u: *mut f64,
        ldu: *mut integer,
        vt: *mut f64,
        ldvt: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dgesvd_(
        jobu: *mut c_char,
        jobv: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        s: *mut f64,
        u: *mut f64,
        ldu: *mut integer,
        vt: *mut f64,
        ldvt: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dgesvdq_(
        joba: *mut c_char,
        jobp: *mut c_char,
        jobr: *mut c_char,
        jobu: *mut c_char,
        jobv: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        s: *mut f64,
        u: *mut f64,
        ldu: *mut integer,
        v: *mut f64,
        ldv: *mut integer,
        numrank: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        rwork: *mut f64,
        lrwork: *mut integer,
        info: *mut integer,
    );
    pub fn dgesvdx_(
        jobu: *mut c_char,
        jobvt: *mut c_char,
        range: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        vl: *mut f64,
        vu: *mut f64,
        il: *mut integer,
        iu: *mut integer,
        ns: *mut integer,
        s: *mut f64,
        u: *mut f64,
        ldu: *mut integer,
        vt: *mut f64,
        ldvt: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dgesv_(
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn dgesvj_(
        joba: *mut c_char,
        jobu: *mut c_char,
        jobv: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        sva: *mut f64,
        mv: *mut integer,
        v: *mut f64,
        ldv: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dgesvx_(
        fact: *mut c_char,
        trans: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        af: *mut f64,
        ldaf: *mut integer,
        ipiv: *mut integer,
        equed: *mut c_char,
        r: *mut f64,
        c: *mut f64,
        b: *mut f64,
        ldb: *mut integer,
        x: *mut f64,
        ldx: *mut integer,
        rcond: *mut f64,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dgesvxx_(
        fact: *mut c_char,
        trans: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        af: *mut f64,
        ldaf: *mut integer,
        ipiv: *mut integer,
        equed: *mut c_char,
        r: *mut f64,
        c: *mut f64,
        b: *mut f64,
        ldb: *mut integer,
        x: *mut f64,
        ldx: *mut integer,
        rcond: *mut f64,
        rpvgrw: *mut f64,
        berr: *mut f64,
        n_err_bnds: *mut integer,
        err_bnds_norm: *mut f64,
        err_bnds_comp: *mut f64,
        nparams: *mut integer,
        params: *mut f64,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dgetc2_(
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        ipiv: *mut integer,
        jpiv: *mut integer,
        info: *mut integer,
    );
    pub fn dgetf2_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn dgetrf2_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn dgetrf_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn dgetri_(
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dgetrs_(
        trans: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn dgetsls_(
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dggbak_(
        job: *mut c_char,
        side: *mut c_char,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        lscale: *mut f64,
        rscale: *mut f64,
        m: *mut integer,
        v: *mut f64,
        ldv: *mut integer,
        info: *mut integer,
    );
    pub fn dggbal_(
        job: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        lscale: *mut f64,
        rscale: *mut f64,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dgges3_(
        jobvsl: *mut c_char,
        jobvsr: *mut c_char,
        sort: *mut c_char,
        selctg: L_fp,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        sdim: *mut integer,
        alphar: *mut f64,
        alphai: *mut f64,
        beta: *mut f64,
        vsl: *mut f64,
        ldvsl: *mut integer,
        vsr: *mut f64,
        ldvsr: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        bwork: *mut logical,
        info: *mut integer,
    );
    pub fn dgges_(
        jobvsl: *mut c_char,
        jobvsr: *mut c_char,
        sort: *mut c_char,
        selctg: L_fp,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        sdim: *mut integer,
        alphar: *mut f64,
        alphai: *mut f64,
        beta: *mut f64,
        vsl: *mut f64,
        ldvsl: *mut integer,
        vsr: *mut f64,
        ldvsr: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        bwork: *mut logical,
        info: *mut integer,
    );
    pub fn dggesx_(
        jobvsl: *mut c_char,
        jobvsr: *mut c_char,
        sort: *mut c_char,
        selctg: L_fp,
        sense: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        sdim: *mut integer,
        alphar: *mut f64,
        alphai: *mut f64,
        beta: *mut f64,
        vsl: *mut f64,
        ldvsl: *mut integer,
        vsr: *mut f64,
        ldvsr: *mut integer,
        rconde: *mut f64,
        rcondv: *mut f64,
        work: *mut f64,
        lwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        bwork: *mut logical,
        info: *mut integer,
    );
    pub fn dggev3_(
        jobvl: *mut c_char,
        jobvr: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        alphar: *mut f64,
        alphai: *mut f64,
        beta: *mut f64,
        vl: *mut f64,
        ldvl: *mut integer,
        vr: *mut f64,
        ldvr: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dggev_(
        jobvl: *mut c_char,
        jobvr: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        alphar: *mut f64,
        alphai: *mut f64,
        beta: *mut f64,
        vl: *mut f64,
        ldvl: *mut integer,
        vr: *mut f64,
        ldvr: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dggevx_(
        balanc: *mut c_char,
        jobvl: *mut c_char,
        jobvr: *mut c_char,
        sense: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        alphar: *mut f64,
        alphai: *mut f64,
        beta: *mut f64,
        vl: *mut f64,
        ldvl: *mut integer,
        vr: *mut f64,
        ldvr: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        lscale: *mut f64,
        rscale: *mut f64,
        abnrm: *mut f64,
        bbnrm: *mut f64,
        rconde: *mut f64,
        rcondv: *mut f64,
        work: *mut f64,
        lwork: *mut integer,
        iwork: *mut integer,
        bwork: *mut logical,
        info: *mut integer,
    );
    pub fn dggglm_(
        n: *mut integer,
        m: *mut integer,
        p: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        d: *mut f64,
        x: *mut f64,
        y: *mut f64,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dgghd3_(
        compq: *mut c_char,
        compz: *mut c_char,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        q: *mut f64,
        ldq: *mut integer,
        z: *mut f64,
        ldz: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dgghrd_(
        compq: *mut c_char,
        compz: *mut c_char,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        q: *mut f64,
        ldq: *mut integer,
        z: *mut f64,
        ldz: *mut integer,
        info: *mut integer,
    );
    pub fn dgglse_(
        m: *mut integer,
        n: *mut integer,
        p: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        c: *mut f64,
        d: *mut f64,
        x: *mut f64,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dggqrf_(
        n: *mut integer,
        m: *mut integer,
        p: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        taua: *mut f64,
        b: *mut f64,
        ldb: *mut integer,
        taub: *mut f64,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dggrqf_(
        m: *mut integer,
        p: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        taua: *mut f64,
        b: *mut f64,
        ldb: *mut integer,
        taub: *mut f64,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dggsvd3_(
        jobu: *mut c_char,
        jobv: *mut c_char,
        jobq: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        p: *mut integer,
        k: *mut integer,
        l: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        alpha: *mut f64,
        beta: *mut f64,
        u: *mut f64,
        ldu: *mut integer,
        v: *mut f64,
        ldv: *mut integer,
        q: *mut f64,
        ldq: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dggsvd_(
        jobu: *mut c_char,
        jobv: *mut c_char,
        jobq: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        p: *mut integer,
        k: *mut integer,
        l: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        alpha: *mut f64,
        beta: *mut f64,
        u: *mut f64,
        ldu: *mut integer,
        v: *mut f64,
        ldv: *mut integer,
        q: *mut f64,
        ldq: *mut integer,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dggsvp3_(
        jobu: *mut c_char,
        jobv: *mut c_char,
        jobq: *mut c_char,
        m: *mut integer,
        p: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        tola: *mut f64,
        tolb: *mut f64,
        k: *mut integer,
        l: *mut integer,
        u: *mut f64,
        ldu: *mut integer,
        v: *mut f64,
        ldv: *mut integer,
        q: *mut f64,
        ldq: *mut integer,
        iwork: *mut integer,
        tau: *mut f64,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dggsvp_(
        jobu: *mut c_char,
        jobv: *mut c_char,
        jobq: *mut c_char,
        m: *mut integer,
        p: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        tola: *mut f64,
        tolb: *mut f64,
        k: *mut integer,
        l: *mut integer,
        u: *mut f64,
        ldu: *mut integer,
        v: *mut f64,
        ldv: *mut integer,
        q: *mut f64,
        ldq: *mut integer,
        iwork: *mut integer,
        tau: *mut f64,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dgsvj0_(
        jobv: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        d: *mut f64,
        sva: *mut f64,
        mv: *mut integer,
        v: *mut f64,
        ldv: *mut integer,
        eps: *mut f64,
        sfmin: *mut f64,
        tol: *mut f64,
        nsweep: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dgsvj1_(
        jobv: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        n1: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        d: *mut f64,
        sva: *mut f64,
        mv: *mut integer,
        v: *mut f64,
        ldv: *mut integer,
        eps: *mut f64,
        sfmin: *mut f64,
        tol: *mut f64,
        nsweep: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dgtcon_(
        norm: *mut c_char,
        n: *mut integer,
        dl: *mut f64,
        d: *mut f64,
        du: *mut f64,
        du2: *mut f64,
        ipiv: *mut integer,
        anorm: *mut f64,
        rcond: *mut f64,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dgtrfs_(
        trans: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        dl: *mut f64,
        d: *mut f64,
        du: *mut f64,
        dlf: *mut f64,
        df: *mut f64,
        duf: *mut f64,
        du2: *mut f64,
        ipiv: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        x: *mut f64,
        ldx: *mut integer,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dgtsv_(
        n: *mut integer,
        nrhs: *mut integer,
        dl: *mut f64,
        d: *mut f64,
        du: *mut f64,
        b: *mut f64,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn dgtsvx_(
        fact: *mut c_char,
        trans: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        dl: *mut f64,
        d: *mut f64,
        du: *mut f64,
        dlf: *mut f64,
        df: *mut f64,
        duf: *mut f64,
        du2: *mut f64,
        ipiv: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        x: *mut f64,
        ldx: *mut integer,
        rcond: *mut f64,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dgttrf_(
        n: *mut integer,
        dl: *mut f64,
        d: *mut f64,
        du: *mut f64,
        du2: *mut f64,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn dgttrs_(
        trans: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        dl: *mut f64,
        d: *mut f64,
        du: *mut f64,
        du2: *mut f64,
        ipiv: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn dgtts2_(
        itrans: *mut integer,
        n: *mut integer,
        nrhs: *mut integer,
        dl: *mut f64,
        d: *mut f64,
        du: *mut f64,
        du2: *mut f64,
        ipiv: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
    );
    pub fn dhgeqz_(
        job: *mut c_char,
        compq: *mut c_char,
        compz: *mut c_char,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        h: *mut f64,
        ldh: *mut integer,
        t: *mut f64,
        ldt: *mut integer,
        alphar: *mut f64,
        alphai: *mut f64,
        beta: *mut f64,
        q: *mut f64,
        ldq: *mut integer,
        z: *mut f64,
        ldz: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dhsein_(
        side: *mut c_char,
        eigsrc: *mut c_char,
        initv: *mut c_char,
        select: *mut logical,
        n: *mut integer,
        h: *mut f64,
        ldh: *mut integer,
        wr: *mut f64,
        wi: *mut f64,
        vl: *mut f64,
        ldvl: *mut integer,
        vr: *mut f64,
        ldvr: *mut integer,
        mm: *mut integer,
        m: *mut integer,
        work: *mut f64,
        ifaill: *mut integer,
        ifailr: *mut integer,
        info: *mut integer,
    );
    pub fn dhseqr_(
        job: *mut c_char,
        compz: *mut c_char,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        h: *mut f64,
        ldh: *mut integer,
        wr: *mut f64,
        wi: *mut f64,
        z: *mut f64,
        ldz: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dlabad_(small_: *mut f64, large: *mut f64);
    pub fn dlabrd_(
        m: *mut integer,
        n: *mut integer,
        nb: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        d: *mut f64,
        e: *mut f64,
        tauq: *mut f64,
        taup: *mut f64,
        x: *mut f64,
        ldx: *mut integer,
        y: *mut f64,
        ldy: *mut integer,
    );
    pub fn dlacn2_(
        n: *mut integer,
        v: *mut f64,
        x: *mut f64,
        isgn: *mut integer,
        est: *mut f64,
        kase: *mut integer,
        isave: *mut integer,
    );
    pub fn dlacon_(
        n: *mut integer,
        v: *mut f64,
        x: *mut f64,
        isgn: *mut integer,
        est: *mut f64,
        kase: *mut integer,
    );
    pub fn dlacpy_(
        uplo: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
    );
    pub fn dladiv_(a: *mut f64, b: *mut f64, c: *mut f64, d: *mut f64, p: *mut f64, q: *mut f64);
    pub fn dlae2_(a: *mut f64, b: *mut f64, c: *mut f64, rt1: *mut f64, rt2: *mut f64);
    pub fn dlaebz_(
        ijob: *mut integer,
        nitmax: *mut integer,
        n: *mut integer,
        mmax: *mut integer,
        minp: *mut integer,
        nbmin: *mut integer,
        abstol: *mut f64,
        reltol: *mut f64,
        pivmin: *mut f64,
        d: *mut f64,
        e: *mut f64,
        e2: *mut f64,
        nval: *mut integer,
        ab: *mut f64,
        c: *mut f64,
        mout: *mut integer,
        nab: *mut integer,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dlaed0_(
        icompq: *mut integer,
        qsiz: *mut integer,
        n: *mut integer,
        d: *mut f64,
        e: *mut f64,
        q: *mut f64,
        ldq: *mut integer,
        qstore: *mut f64,
        ldqs: *mut integer,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dlaed1_(
        n: *mut integer,
        d: *mut f64,
        q: *mut f64,
        ldq: *mut integer,
        indxq: *mut integer,
        rho: *mut f64,
        cutpnt: *mut integer,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dlaed2_(
        k: *mut integer,
        n: *mut integer,
        n1: *mut integer,
        d: *mut f64,
        q: *mut f64,
        ldq: *mut integer,
        indxq: *mut integer,
        rho: *mut f64,
        z: *mut f64,
        dlamda: *mut f64,
        w: *mut f64,
        q2: *mut f64,
        indx: *mut integer,
        indxc: *mut integer,
        indxp: *mut integer,
        coltyp: *mut integer,
        info: *mut integer,
    );
    pub fn dlaed3_(
        k: *mut integer,
        n: *mut integer,
        n1: *mut integer,
        d: *mut f64,
        q: *mut f64,
        ldq: *mut integer,
        rho: *mut f64,
        dlamda: *mut f64,
        q2: *mut f64,
        indx: *mut integer,
        ctot: *mut integer,
        w: *mut f64,
        s: *mut f64,
        info: *mut integer,
    );
    pub fn dlaed4_(
        n: *mut integer,
        i: *mut integer,
        d: *mut f64,
        z: *mut f64,
        delta: *mut f64,
        rho: *mut f64,
        dlam: *mut f64,
        info: *mut integer,
    );
    pub fn dlaed5_(
        i: *mut integer,
        d: *mut f64,
        z: *mut f64,
        delta: *mut f64,
        rho: *mut f64,
        dlam: *mut f64,
    );
    pub fn dlaed6_(
        kniter: *mut integer,
        orgati: *mut logical,
        rho: *mut f64,
        d: *mut f64,
        z: *mut f64,
        finit: *mut f64,
        tau: *mut f64,
        info: *mut integer,
    );
    pub fn dlaed7_(
        icompq: *mut integer,
        n: *mut integer,
        qsiz: *mut integer,
        tlvls: *mut integer,
        curlvl: *mut integer,
        curpbm: *mut integer,
        d: *mut f64,
        q: *mut f64,
        ldq: *mut integer,
        indxq: *mut integer,
        rho: *mut f64,
        cutpnt: *mut integer,
        qstore: *mut f64,
        qptr: *mut integer,
        prmptr: *mut integer,
        perm: *mut integer,
        givptr: *mut integer,
        givcol: *mut integer,
        givnum: *mut f64,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dlaed8_(
        icompq: *mut integer,
        k: *mut integer,
        n: *mut integer,
        qsiz: *mut integer,
        d: *mut f64,
        q: *mut f64,
        ldq: *mut integer,
        indxq: *mut integer,
        rho: *mut f64,
        cutpnt: *mut integer,
        z: *mut f64,
        dlamda: *mut f64,
        q2: *mut f64,
        ldq2: *mut integer,
        w: *mut f64,
        perm: *mut integer,
        givptr: *mut integer,
        givcol: *mut integer,
        givnum: *mut f64,
        indxp: *mut integer,
        indx: *mut integer,
        info: *mut integer,
    );
    pub fn dlaed9_(
        k: *mut integer,
        kstart: *mut integer,
        kstop: *mut integer,
        n: *mut integer,
        d: *mut f64,
        q: *mut f64,
        ldq: *mut integer,
        rho: *mut f64,
        dlamda: *mut f64,
        w: *mut f64,
        s: *mut f64,
        lds: *mut integer,
        info: *mut integer,
    );
    pub fn dlaeda_(
        n: *mut integer,
        tlvls: *mut integer,
        curlvl: *mut integer,
        curpbm: *mut integer,
        prmptr: *mut integer,
        perm: *mut integer,
        givptr: *mut integer,
        givcol: *mut integer,
        givnum: *mut f64,
        q: *mut f64,
        qptr: *mut integer,
        z: *mut f64,
        ztemp: *mut f64,
        info: *mut integer,
    );
    pub fn dlaein_(
        rightv: *mut logical,
        noinit: *mut logical,
        n: *mut integer,
        h: *mut f64,
        ldh: *mut integer,
        wr: *mut f64,
        wi: *mut f64,
        vr: *mut f64,
        vi: *mut f64,
        b: *mut f64,
        ldb: *mut integer,
        work: *mut f64,
        eps3: *mut f64,
        smlnum: *mut f64,
        bignum: *mut f64,
        info: *mut integer,
    );
    pub fn dlaev2_(
        a: *mut f64,
        b: *mut f64,
        c: *mut f64,
        rt1: *mut f64,
        rt2: *mut f64,
        cs1: *mut f64,
        sn1: *mut f64,
    );
    pub fn dlaexc_(
        wantq: *mut logical,
        n: *mut integer,
        t: *mut f64,
        ldt: *mut integer,
        q: *mut f64,
        ldq: *mut integer,
        j1: *mut integer,
        n1: *mut integer,
        n2: *mut integer,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dlag2_(
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        safmin: *mut f64,
        scale1: *mut f64,
        scale2: *mut f64,
        wr1: *mut f64,
        wr2: *mut f64,
        wi: *mut f64,
    );
    pub fn dlag2s_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        sa: *mut f32,
        ldsa: *mut integer,
        info: *mut integer,
    );
    pub fn dla_gbamv_(
        trans: *mut integer,
        m: *mut integer,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        alpha: *mut f64,
        ab: *mut f64,
        ldab: *mut integer,
        x: *mut f64,
        incx: *mut integer,
        beta: *mut f64,
        y: *mut f64,
        incy: *mut integer,
    );
    pub fn dla_gbrfsx_extended_(
        prec_type: *mut integer,
        trans_type: *mut integer,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        nrhs: *mut integer,
        ab: *mut f64,
        ldab: *mut integer,
        afb: *mut f64,
        ldafb: *mut integer,
        ipiv: *mut integer,
        colequ: *mut logical,
        c: *mut f64,
        b: *mut f64,
        ldb: *mut integer,
        y: *mut f64,
        ldy: *mut integer,
        berr_out: *mut f64,
        n_norms: *mut integer,
        err_bnds_norm: *mut f64,
        err_bnds_comp: *mut f64,
        res: *mut f64,
        ayb: *mut f64,
        dy: *mut f64,
        y_tail: *mut f64,
        rcond: *mut f64,
        ithresh: *mut integer,
        rthresh: *mut f64,
        dz_ub: *mut f64,
        ignore_cwise: *mut logical,
        info: *mut integer,
    );
    pub fn dla_geamv_(
        trans: *mut integer,
        m: *mut integer,
        n: *mut integer,
        alpha: *mut f64,
        a: *mut f64,
        lda: *mut integer,
        x: *mut f64,
        incx: *mut integer,
        beta: *mut f64,
        y: *mut f64,
        incy: *mut integer,
    );
    pub fn dla_gerfsx_extended_(
        prec_type: *mut integer,
        trans_type: *mut integer,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        af: *mut f64,
        ldaf: *mut integer,
        ipiv: *mut integer,
        colequ: *mut logical,
        c: *mut f64,
        b: *mut f64,
        ldb: *mut integer,
        y: *mut f64,
        ldy: *mut integer,
        berr_out: *mut f64,
        n_norms: *mut integer,
        errs_n: *mut f64,
        errs_c: *mut f64,
        res: *mut f64,
        ayb: *mut f64,
        dy: *mut f64,
        y_tail: *mut f64,
        rcond: *mut f64,
        ithresh: *mut integer,
        rthresh: *mut f64,
        dz_ub: *mut f64,
        ignore_cwise: *mut logical,
        info: *mut integer,
    );
    pub fn dlags2_(
        upper: *mut logical,
        a1: *mut f64,
        a2: *mut f64,
        a3: *mut f64,
        b1: *mut f64,
        b2: *mut f64,
        b3: *mut f64,
        csu: *mut f64,
        snu: *mut f64,
        csv: *mut f64,
        snv: *mut f64,
        csq: *mut f64,
        snq: *mut f64,
    );
    pub fn dlagtf_(
        n: *mut integer,
        a: *mut f64,
        lambda: *mut f64,
        b: *mut f64,
        c: *mut f64,
        tol: *mut f64,
        d: *mut f64,
        in_: *mut integer,
        info: *mut integer,
    );
    pub fn dlagtm_(
        trans: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        alpha: *mut f64,
        dl: *mut f64,
        d: *mut f64,
        du: *mut f64,
        x: *mut f64,
        ldx: *mut integer,
        beta: *mut f64,
        b: *mut f64,
        ldb: *mut integer,
    );
    pub fn dlagts_(
        job: *mut integer,
        n: *mut integer,
        a: *mut f64,
        b: *mut f64,
        c: *mut f64,
        d: *mut f64,
        in_: *mut integer,
        y: *mut f64,
        tol: *mut f64,
        info: *mut integer,
    );
    pub fn dlagv2_(
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        alphar: *mut f64,
        alphai: *mut f64,
        beta: *mut f64,
        csl: *mut f64,
        snl: *mut f64,
        csr: *mut f64,
        snr: *mut f64,
    );
    pub fn dlahqr_(
        wantt: *mut logical,
        wantz: *mut logical,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        h: *mut f64,
        ldh: *mut integer,
        wr: *mut f64,
        wi: *mut f64,
        iloz: *mut integer,
        ihiz: *mut integer,
        z: *mut f64,
        ldz: *mut integer,
        info: *mut integer,
    );
    pub fn dlahr2_(
        n: *mut integer,
        k: *mut integer,
        nb: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        tau: *mut f64,
        t: *mut f64,
        ldt: *mut integer,
        y: *mut f64,
        ldy: *mut integer,
    );
    pub fn dlahrd_(
        n: *mut integer,
        k: *mut integer,
        nb: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        tau: *mut f64,
        t: *mut f64,
        ldt: *mut integer,
        y: *mut f64,
        ldy: *mut integer,
    );
    pub fn dlaic1_(
        job: *mut integer,
        j: *mut integer,
        x: *mut f64,
        sest: *mut f64,
        w: *mut f64,
        gamma: *mut f64,
        sestpr: *mut f64,
        s: *mut f64,
        c__: *mut f64,
    );
    pub fn dla_lin_berr_(
        n: *mut integer,
        nz: *mut integer,
        nrhs: *mut integer,
        res: *mut f64,
        ayb: *mut f64,
        berr: *mut f64,
    );
    pub fn dlaln2_(
        ltrans: *mut logical,
        na: *mut integer,
        nw: *mut integer,
        smin: *mut f64,
        ca: *mut f64,
        a: *mut f64,
        lda: *mut integer,
        d1: *mut f64,
        d2: *mut f64,
        b: *mut f64,
        ldb: *mut integer,
        wr: *mut f64,
        wi: *mut f64,
        x: *mut f64,
        ldx: *mut integer,
        scale: *mut f64,
        xnorm: *mut f64,
        info: *mut integer,
    );
    pub fn dlals0_(
        icompq: *mut integer,
        nl: *mut integer,
        nr: *mut integer,
        sqre: *mut integer,
        nrhs: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        bx: *mut f64,
        ldbx: *mut integer,
        perm: *mut integer,
        givptr: *mut integer,
        givcol: *mut integer,
        ldgcol: *mut integer,
        givnum: *mut f64,
        ldgnum: *mut integer,
        poles: *mut f64,
        difl: *mut f64,
        difr: *mut f64,
        z: *mut f64,
        k: *mut integer,
        c: *mut f64,
        s: *mut f64,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dlalsa_(
        icompq: *mut integer,
        smlsiz: *mut integer,
        n: *mut integer,
        nrhs: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        bx: *mut f64,
        ldbx: *mut integer,
        u: *mut f64,
        ldu: *mut integer,
        vt: *mut f64,
        k: *mut integer,
        difl: *mut f64,
        difr: *mut f64,
        z: *mut f64,
        poles: *mut f64,
        givptr: *mut integer,
        givcol: *mut integer,
        ldgcol: *mut integer,
        perm: *mut integer,
        givnum: *mut f64,
        c: *mut f64,
        s: *mut f64,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dlalsd_(
        uplo: *mut c_char,
        smlsiz: *mut integer,
        n: *mut integer,
        nrhs: *mut integer,
        d: *mut f64,
        e: *mut f64,
        b: *mut f64,
        ldb: *mut integer,
        rcond: *mut f64,
        rank: *mut integer,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dlamrg_(
        n1: *mut integer,
        n2: *mut integer,
        a: *mut f64,
        dtrd1: *mut integer,
        dtrd2: *mut integer,
        index: *mut integer,
    );
    pub fn dlamswlq_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        mb: *mut integer,
        nb: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        t: *mut f64,
        ldt: *mut integer,
        c: *mut f64,
        ldc: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dlamtsqr_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        mb: *mut integer,
        nb: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        t: *mut f64,
        ldt: *mut integer,
        c: *mut f64,
        ldc: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dlaneg_(
        n: *mut integer,
        d: *mut f64,
        lld: *mut f64,
        sigma: *mut f64,
        pivmin: *mut f64,
        r__: *mut integer,
    ) -> integer;
    pub fn dlanv2_(
        a: *mut f64,
        b: *mut f64,
        c: *mut f64,
        d: *mut f64,
        rt1r: *mut f64,
        rt1i: *mut f64,
        rt2r: *mut f64,
        rt2i: *mut f64,
        cs: *mut f64,
        sn: *mut f64,
    );
    pub fn dlaorhr_col_getrfnp2_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        d: *mut f64,
        info: *mut integer,
    );
    pub fn dlaorhr_col_getrfnp_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        d: *mut f64,
        info: *mut integer,
    );
    pub fn dlapll_(
        n: *mut integer,
        x: *mut f64,
        incx: *mut integer,
        y: *mut f64,
        incy: *mut integer,
        ssmin: *mut f64,
    );
    pub fn dlapmr_(
        forwrd: *mut logical,
        m: *mut integer,
        n: *mut integer,
        x: *mut f64,
        ldx: *mut integer,
        k: *mut integer,
    );
    pub fn dlapmt_(
        forwrd: *mut logical,
        m: *mut integer,
        n: *mut integer,
        x: *mut f64,
        ldx: *mut integer,
        k: *mut integer,
    );
    pub fn dla_porfsx_extended_(
        prec_type: *mut integer,
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        af: *mut f64,
        ldaf: *mut integer,
        colequ: *mut logical,
        c: *mut f64,
        b: *mut f64,
        ldb: *mut integer,
        y: *mut f64,
        ldy: *mut integer,
        berr_out: *mut f64,
        n_norms: *mut integer,
        err_bnds_norm: *mut f64,
        err_bnds_comp: *mut f64,
        res: *mut f64,
        ayb: *mut f64,
        dy: *mut f64,
        y_tail: *mut f64,
        rcond: *mut f64,
        ithresh: *mut integer,
        rthresh: *mut f64,
        dz_ub: *mut f64,
        ignore_cwise: *mut logical,
        info: *mut integer,
    );
    pub fn dlaqgb_(
        m: *mut integer,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        ab: *mut f64,
        ldab: *mut integer,
        r: *mut f64,
        c: *mut f64,
        rowcnd: *mut f64,
        colcnd: *mut f64,
        amax: *mut f64,
        equed: *mut c_char,
    );
    pub fn dlaqge_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        r: *mut f64,
        c: *mut f64,
        rowcnd: *mut f64,
        colcnd: *mut f64,
        amax: *mut f64,
        equed: *mut c_char,
    );
    pub fn dlaqp2_(
        m: *mut integer,
        n: *mut integer,
        offset: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        jpvt: *mut integer,
        tau: *mut f64,
        vn1: *mut f64,
        vn2: *mut f64,
        work: *mut f64,
    );
    pub fn dlaqps_(
        m: *mut integer,
        n: *mut integer,
        offset: *mut integer,
        nb: *mut integer,
        kb: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        jpvt: *mut integer,
        tau: *mut f64,
        vn1: *mut f64,
        vn2: *mut f64,
        auxv: *mut f64,
        f: *mut f64,
        ldf: *mut integer,
    );
    pub fn dlaqr0_(
        wantt: *mut logical,
        wantz: *mut logical,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        h: *mut f64,
        ldh: *mut integer,
        wr: *mut f64,
        wi: *mut f64,
        iloz: *mut integer,
        ihiz: *mut integer,
        z: *mut f64,
        ldz: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dlaqr1_(
        n: *mut integer,
        h: *mut f64,
        ldh: *mut integer,
        sr1: *mut f64,
        si1: *mut f64,
        sr2: *mut f64,
        si2: *mut f64,
        v: *mut f64,
    );
    pub fn dlaqr2_(
        wantt: *mut logical,
        wantz: *mut logical,
        n: *mut integer,
        ktop: *mut integer,
        kbot: *mut integer,
        nw: *mut integer,
        h: *mut f64,
        ldh: *mut integer,
        iloz: *mut integer,
        ihiz: *mut integer,
        z: *mut f64,
        ldz: *mut integer,
        ns: *mut integer,
        nd: *mut integer,
        sr: *mut f64,
        si: *mut f64,
        v: *mut f64,
        ldv: *mut integer,
        nh: *mut integer,
        t: *mut f64,
        ldt: *mut integer,
        nv: *mut integer,
        wv: *mut f64,
        ldwv: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
    );
    pub fn dlaqr3_(
        wantt: *mut logical,
        wantz: *mut logical,
        n: *mut integer,
        ktop: *mut integer,
        kbot: *mut integer,
        nw: *mut integer,
        h: *mut f64,
        ldh: *mut integer,
        iloz: *mut integer,
        ihiz: *mut integer,
        z: *mut f64,
        ldz: *mut integer,
        ns: *mut integer,
        nd: *mut integer,
        sr: *mut f64,
        si: *mut f64,
        v: *mut f64,
        ldv: *mut integer,
        nh: *mut integer,
        t: *mut f64,
        ldt: *mut integer,
        nv: *mut integer,
        wv: *mut f64,
        ldwv: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
    );
    pub fn dlaqr4_(
        wantt: *mut logical,
        wantz: *mut logical,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        h: *mut f64,
        ldh: *mut integer,
        wr: *mut f64,
        wi: *mut f64,
        iloz: *mut integer,
        ihiz: *mut integer,
        z: *mut f64,
        ldz: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dlaqr5_(
        wantt: *mut logical,
        wantz: *mut logical,
        kacc22: *mut integer,
        n: *mut integer,
        ktop: *mut integer,
        kbot: *mut integer,
        nshfts: *mut integer,
        sr: *mut f64,
        si: *mut f64,
        h: *mut f64,
        ldh: *mut integer,
        iloz: *mut integer,
        ihiz: *mut integer,
        z: *mut f64,
        ldz: *mut integer,
        v: *mut f64,
        ldv: *mut integer,
        u: *mut f64,
        ldu: *mut integer,
        nv: *mut integer,
        wv: *mut f64,
        ldwv: *mut integer,
        nh: *mut integer,
        wh: *mut f64,
        ldwh: *mut integer,
    );
    pub fn dlaqsb_(
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut f64,
        ldab: *mut integer,
        s: *mut f64,
        scond: *mut f64,
        amax: *mut f64,
        equed: *mut c_char,
    );
    pub fn dlaqsp_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut f64,
        s: *mut f64,
        scond: *mut f64,
        amax: *mut f64,
        equed: *mut c_char,
    );
    pub fn dlaqsy_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        s: *mut f64,
        scond: *mut f64,
        amax: *mut f64,
        equed: *mut c_char,
    );
    pub fn dlaqtr_(
        ltran: *mut logical,
        lfloat: *mut logical,
        n: *mut integer,
        t: *mut f64,
        ldt: *mut integer,
        b: *mut f64,
        w: *mut f64,
        scale: *mut f64,
        x: *mut f64,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dlar1v_(
        n: *mut integer,
        b1: *mut integer,
        bn: *mut integer,
        lambda: *mut f64,
        d: *mut f64,
        l: *mut f64,
        ld: *mut f64,
        lld: *mut f64,
        pivmin: *mut f64,
        gaptol: *mut f64,
        z: *mut f64,
        wantnc: *mut logical,
        negcnt: *mut integer,
        ztz: *mut f64,
        mingma: *mut f64,
        r: *mut integer,
        isuppz: *mut integer,
        nrminv: *mut f64,
        resid: *mut f64,
        rqcorr: *mut f64,
        work: *mut f64,
    );
    pub fn dlar2v_(
        n: *mut integer,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        incx: *mut integer,
        c: *mut f64,
        s: *mut f64,
        incc: *mut integer,
    );
    pub fn dlarfb_(
        side: *mut c_char,
        trans: *mut c_char,
        direct: *mut c_char,
        storev: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        v: *mut f64,
        ldv: *mut integer,
        t: *mut f64,
        ldt: *mut integer,
        c: *mut f64,
        ldc: *mut integer,
        work: *mut f64,
        ldwork: *mut integer,
    );
    pub fn dlarf_(
        side: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        v: *mut f64,
        incv: *mut integer,
        tau: *mut f64,
        c: *mut f64,
        ldc: *mut integer,
        work: *mut f64,
    );
    pub fn dlarfg_(
        n: *mut integer,
        alpha: *mut f64,
        x: *mut f64,
        incx: *mut integer,
        tau: *mut f64,
    );
    pub fn dlarfgp_(
        n: *mut integer,
        alpha: *mut f64,
        x: *mut f64,
        incx: *mut integer,
        tau: *mut f64,
    );
    pub fn dlarft_(
        direct: *mut c_char,
        storev: *mut c_char,
        n: *mut integer,
        k: *mut integer,
        v: *mut f64,
        ldv: *mut integer,
        tau: *mut f64,
        t: *mut f64,
        ldt: *mut integer,
    );
    pub fn dlarfx_(
        side: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        v: *mut f64,
        tau: *mut f64,
        c: *mut f64,
        ldc: *mut integer,
        work: *mut f64,
    );
    pub fn dlarfy_(
        uplo: *mut c_char,
        n: *mut integer,
        v: *mut f64,
        incv: *mut integer,
        tau: *mut f64,
        c: *mut f64,
        ldc: *mut integer,
        work: *mut f64,
    );
    pub fn dlargv_(
        n: *mut integer,
        x: *mut f64,
        incx: *mut integer,
        y: *mut f64,
        incy: *mut integer,
        c: *mut f64,
        incc: *mut integer,
    );
    pub fn dlarnv_(idist: *mut integer, iseed: *mut integer, n: *mut integer, x: *mut f64);
    pub fn dlarra_(
        n: *mut integer,
        d: *mut f64,
        e: *mut f64,
        e2: *mut f64,
        spltol: *mut f64,
        tnrm: *mut f64,
        nsplit: *mut integer,
        isplit: *mut integer,
        info: *mut integer,
    );
    pub fn dlarrb_(
        n: *mut integer,
        d: *mut f64,
        lld: *mut f64,
        ifirst: *mut integer,
        ilast: *mut integer,
        rtol1: *mut f64,
        rtol2: *mut f64,
        offset: *mut integer,
        w: *mut f64,
        wgap: *mut f64,
        werr: *mut f64,
        work: *mut f64,
        iwork: *mut integer,
        pivmin: *mut f64,
        spdiam: *mut f64,
        twist: *mut integer,
        info: *mut integer,
    );
    pub fn dlarrc_(
        jobt: *mut c_char,
        n: *mut integer,
        vl: *mut f64,
        vu: *mut f64,
        d: *mut f64,
        e: *mut f64,
        pivmin: *mut f64,
        eigcnt: *mut integer,
        lcnt: *mut integer,
        rcnt: *mut integer,
        info: *mut integer,
    );
    pub fn dlarrd_(
        range: *mut c_char,
        order: *mut c_char,
        n: *mut integer,
        vl: *mut f64,
        vu: *mut f64,
        il: *mut integer,
        iu: *mut integer,
        gers: *mut f64,
        reltol: *mut f64,
        d: *mut f64,
        e: *mut f64,
        e2: *mut f64,
        pivmin: *mut f64,
        nsplit: *mut integer,
        isplit: *mut integer,
        m: *mut integer,
        w: *mut f64,
        werr: *mut f64,
        wl: *mut f64,
        wu: *mut f64,
        iblock: *mut integer,
        indexw: *mut integer,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dlarre_(
        range: *mut c_char,
        n: *mut integer,
        vl: *mut f64,
        vu: *mut f64,
        il: *mut integer,
        iu: *mut integer,
        d: *mut f64,
        e: *mut f64,
        e2: *mut f64,
        rtol1: *mut f64,
        rtol2: *mut f64,
        spltol: *mut f64,
        nsplit: *mut integer,
        isplit: *mut integer,
        m: *mut integer,
        w: *mut f64,
        werr: *mut f64,
        wgap: *mut f64,
        iblock: *mut integer,
        indexw: *mut integer,
        gers: *mut f64,
        pivmin: *mut f64,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dlarrf_(
        n: *mut integer,
        d: *mut f64,
        l: *mut f64,
        ld: *mut f64,
        clstrt: *mut integer,
        clend: *mut integer,
        w: *mut f64,
        wgap: *mut f64,
        werr: *mut f64,
        spdiam: *mut f64,
        clgapl: *mut f64,
        clgapr: *mut f64,
        pivmin: *mut f64,
        sigma: *mut f64,
        dplus: *mut f64,
        lplus: *mut f64,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dlarrj_(
        n: *mut integer,
        d: *mut f64,
        e2: *mut f64,
        ifirst: *mut integer,
        ilast: *mut integer,
        rtol: *mut f64,
        offset: *mut integer,
        w: *mut f64,
        werr: *mut f64,
        work: *mut f64,
        iwork: *mut integer,
        pivmin: *mut f64,
        spdiam: *mut f64,
        info: *mut integer,
    );
    pub fn dlarrk_(
        n: *mut integer,
        iw: *mut integer,
        gl: *mut f64,
        gu: *mut f64,
        d: *mut f64,
        e2: *mut f64,
        pivmin: *mut f64,
        reltol: *mut f64,
        w: *mut f64,
        werr: *mut f64,
        info: *mut integer,
    );
    pub fn dlarrr_(n: *mut integer, d: *mut f64, e: *mut f64, info: *mut integer);
    pub fn dlarrv_(
        n: *mut integer,
        vl: *mut f64,
        vu: *mut f64,
        d: *mut f64,
        l: *mut f64,
        pivmin: *mut f64,
        isplit: *mut integer,
        m: *mut integer,
        dol: *mut integer,
        dou: *mut integer,
        minrgp: *mut f64,
        rtol1: *mut f64,
        rtol2: *mut f64,
        w: *mut f64,
        werr: *mut f64,
        wgap: *mut f64,
        iblock: *mut integer,
        indexw: *mut integer,
        gers: *mut f64,
        z: *mut f64,
        ldz: *mut integer,
        isuppz: *mut integer,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dlarscl2_(m: *mut integer, n: *mut integer, d: *mut f64, x: *mut f64, ldx: *mut integer);
    pub fn dlartg_(f: *mut f64, g: *mut f64, cs: *mut f64, sn: *mut f64, r__: *mut f64);
    pub fn dlartgp_(f: *mut f64, g: *mut f64, cs: *mut f64, sn: *mut f64, r__: *mut f64);
    pub fn dlartgs_(x: *mut f64, y: *mut f64, sigma: *mut f64, cs: *mut f64, sn: *mut f64);
    pub fn dlartv_(
        n: *mut integer,
        x: *mut f64,
        incx: *mut integer,
        y: *mut f64,
        incy: *mut integer,
        c: *mut f64,
        s: *mut f64,
        incc: *mut integer,
    );
    pub fn dlaruv_(iseed: *mut integer, n: *mut integer, x: *mut f64);
    pub fn dlarzb_(
        side: *mut c_char,
        trans: *mut c_char,
        direct: *mut c_char,
        storev: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        l: *mut integer,
        v: *mut f64,
        ldv: *mut integer,
        t: *mut f64,
        ldt: *mut integer,
        c: *mut f64,
        ldc: *mut integer,
        work: *mut f64,
        ldwork: *mut integer,
    );
    pub fn dlarz_(
        side: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        l: *mut integer,
        v: *mut f64,
        incv: *mut integer,
        tau: *mut f64,
        c: *mut f64,
        ldc: *mut integer,
        work: *mut f64,
    );
    pub fn dlarzt_(
        direct: *mut c_char,
        storev: *mut c_char,
        n: *mut integer,
        k: *mut integer,
        v: *mut f64,
        ldv: *mut integer,
        tau: *mut f64,
        t: *mut f64,
        ldt: *mut integer,
    );
    pub fn dlas2_(f: *mut f64, g: *mut f64, h: *mut f64, ssmin: *mut f64, ssmax: *mut f64);
    pub fn dlascl2_(m: *mut integer, n: *mut integer, d: *mut f64, x: *mut f64, ldx: *mut integer);
    pub fn dlascl_(
        type_: *mut c_char,
        kl: *mut integer,
        ku: *mut integer,
        cfrom: *mut f64,
        cto: *mut f64,
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn dlasd0_(
        n: *mut integer,
        sqre: *mut integer,
        d: *mut f64,
        e: *mut f64,
        u: *mut f64,
        ldu: *mut integer,
        vt: *mut f64,
        ldvt: *mut integer,
        smlsiz: *mut integer,
        iwork: *mut integer,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dlasd1_(
        nl: *mut integer,
        nr: *mut integer,
        sqre: *mut integer,
        d: *mut f64,
        alpha: *mut f64,
        beta: *mut f64,
        u: *mut f64,
        ldu: *mut integer,
        vt: *mut f64,
        ldvt: *mut integer,
        idxq: *mut integer,
        iwork: *mut integer,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dlasd2_(
        nl: *mut integer,
        nr: *mut integer,
        sqre: *mut integer,
        k: *mut integer,
        d: *mut f64,
        z: *mut f64,
        alpha: *mut f64,
        beta: *mut f64,
        u: *mut f64,
        ldu: *mut integer,
        vt: *mut f64,
        ldvt: *mut integer,
        dsigma: *mut f64,
        u2: *mut f64,
        ldu2: *mut integer,
        vt2: *mut f64,
        ldvt2: *mut integer,
        idxp: *mut integer,
        idx: *mut integer,
        idxc: *mut integer,
        idxq: *mut integer,
        coltyp: *mut integer,
        info: *mut integer,
    );
    pub fn dlasd3_(
        nl: *mut integer,
        nr: *mut integer,
        sqre: *mut integer,
        k: *mut integer,
        d: *mut f64,
        q: *mut f64,
        ldq: *mut integer,
        dsigma: *mut f64,
        u: *mut f64,
        ldu: *mut integer,
        u2: *mut f64,
        ldu2: *mut integer,
        vt: *mut f64,
        ldvt: *mut integer,
        vt2: *mut f64,
        ldvt2: *mut integer,
        idxc: *mut integer,
        ctot: *mut integer,
        z: *mut f64,
        info: *mut integer,
    );
    pub fn dlasd4_(
        n: *mut integer,
        i: *mut integer,
        d: *mut f64,
        z: *mut f64,
        delta: *mut f64,
        rho: *mut f64,
        sigma: *mut f64,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dlasd5_(
        i: *mut integer,
        d: *mut f64,
        z: *mut f64,
        delta: *mut f64,
        rho: *mut f64,
        dsigma: *mut f64,
        work: *mut f64,
    );
    pub fn dlasd6_(
        icompq: *mut integer,
        nl: *mut integer,
        nr: *mut integer,
        sqre: *mut integer,
        d: *mut f64,
        vf: *mut f64,
        vl: *mut f64,
        alpha: *mut f64,
        beta: *mut f64,
        idxq: *mut integer,
        perm: *mut integer,
        givptr: *mut integer,
        givcol: *mut integer,
        ldgcol: *mut integer,
        givnum: *mut f64,
        ldgnum: *mut integer,
        poles: *mut f64,
        difl: *mut f64,
        difr: *mut f64,
        z: *mut f64,
        k: *mut integer,
        c: *mut f64,
        s: *mut f64,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dlasd7_(
        icompq: *mut integer,
        nl: *mut integer,
        nr: *mut integer,
        sqre: *mut integer,
        k: *mut integer,
        d: *mut f64,
        z: *mut f64,
        zw: *mut f64,
        vf: *mut f64,
        vfw: *mut f64,
        vl: *mut f64,
        vlw: *mut f64,
        alpha: *mut f64,
        beta: *mut f64,
        dsigma: *mut f64,
        idx: *mut integer,
        idxp: *mut integer,
        idxq: *mut integer,
        perm: *mut integer,
        givptr: *mut integer,
        givcol: *mut integer,
        ldgcol: *mut integer,
        givnum: *mut f64,
        ldgnum: *mut integer,
        c: *mut f64,
        s: *mut f64,
        info: *mut integer,
    );
    pub fn dlasd8_(
        icompq: *mut integer,
        k: *mut integer,
        d: *mut f64,
        z: *mut f64,
        vf: *mut f64,
        vl: *mut f64,
        difl: *mut f64,
        difr: *mut f64,
        lddifr: *mut integer,
        dsigma: *mut f64,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dlasda_(
        icompq: *mut integer,
        smlsiz: *mut integer,
        n: *mut integer,
        sqre: *mut integer,
        d: *mut f64,
        e: *mut f64,
        u: *mut f64,
        ldu: *mut integer,
        vt: *mut f64,
        k: *mut integer,
        difl: *mut f64,
        difr: *mut f64,
        z: *mut f64,
        poles: *mut f64,
        givptr: *mut integer,
        givcol: *mut integer,
        ldgcol: *mut integer,
        perm: *mut integer,
        givnum: *mut f64,
        c: *mut f64,
        s: *mut f64,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dlasdq_(
        uplo: *mut c_char,
        sqre: *mut integer,
        n: *mut integer,
        ncvt: *mut integer,
        nru: *mut integer,
        ncc: *mut integer,
        d: *mut f64,
        e: *mut f64,
        vt: *mut f64,
        ldvt: *mut integer,
        u: *mut f64,
        ldu: *mut integer,
        c: *mut f64,
        ldc: *mut integer,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dlasdt_(
        n: *mut integer,
        lvl: *mut integer,
        nd: *mut integer,
        inode: *mut integer,
        ndiml: *mut integer,
        ndimr: *mut integer,
        msub: *mut integer,
    );
    pub fn dlaset_(
        uplo: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        alpha: *mut f64,
        beta: *mut f64,
        a: *mut f64,
        lda: *mut integer,
    );
    pub fn dlasq1_(n: *mut integer, d: *mut f64, e: *mut f64, work: *mut f64, info: *mut integer);
    pub fn dlasq2_(n: *mut integer, z: *mut f64, info: *mut integer);
    pub fn dlasq3_(
        i0: *mut integer,
        n0: *mut integer,
        z: *mut f64,
        pp: *mut integer,
        dmin: *mut f64,
        sigma: *mut f64,
        desig: *mut f64,
        qmax: *mut f64,
        nfail: *mut integer,
        iter: *mut integer,
        ndiv: *mut integer,
        ieee: *mut logical,
        ttype: *mut integer,
        dmin1: *mut f64,
        dmin2: *mut f64,
        dn: *mut f64,
        dn1: *mut f64,
        dn2: *mut f64,
        g: *mut f64,
        tau: *mut f64,
    );
    pub fn dlasq4_(
        i0: *mut integer,
        n0: *mut integer,
        z: *mut f64,
        pp: *mut integer,
        n0in: *mut integer,
        dmin: *mut f64,
        dmin1: *mut f64,
        dmin2: *mut f64,
        dn: *mut f64,
        dn1: *mut f64,
        dn2: *mut f64,
        tau: *mut f64,
        ttype: *mut integer,
        g: *mut f64,
    );
    pub fn dlasq5_(
        i0: *mut integer,
        n0: *mut integer,
        z: *mut f64,
        pp: *mut integer,
        tau: *mut f64,
        sigma: *mut f64,
        dmin: *mut f64,
        dmin1: *mut f64,
        dmin2: *mut f64,
        dn: *mut f64,
        dnm1: *mut f64,
        dnm2: *mut f64,
        ieee: *mut logical,
        eps: *mut f64,
    );
    pub fn dlasq6_(
        i0: *mut integer,
        n0: *mut integer,
        z: *mut f64,
        pp: *mut integer,
        dmin: *mut f64,
        dmin1: *mut f64,
        dmin2: *mut f64,
        dn: *mut f64,
        dnm1: *mut f64,
        dnm2: *mut f64,
    );
    pub fn dlasr_(
        side: *mut c_char,
        pivot: *mut c_char,
        direct: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        c: *mut f64,
        s: *mut f64,
        a: *mut f64,
        lda: *mut integer,
    );
    pub fn dlasrt_(id: *mut c_char, n: *mut integer, d: *mut f64, info: *mut integer);
    pub fn dlassq_(
        n: *mut integer,
        x: *mut f64,
        incx: *mut integer,
        scale: *mut f64,
        sumsq: *mut f64,
    );
    pub fn dlasv2_(
        f: *mut f64,
        g: *mut f64,
        h: *mut f64,
        ssmin: *mut f64,
        ssmax: *mut f64,
        snr: *mut f64,
        csr: *mut f64,
        snl: *mut f64,
        csl: *mut f64,
    );
    pub fn dlaswlq_(
        m: *mut integer,
        n: *mut integer,
        mb: *mut integer,
        nb: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        t: *mut f64,
        ldt: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dlaswp_(
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        k1: *mut integer,
        k2: *mut integer,
        ipiv: *mut integer,
        incx: *mut integer,
    );
    pub fn dlasy2_(
        ltranl: *mut logical,
        ltranr: *mut logical,
        isgn: *mut integer,
        n1: *mut integer,
        n2: *mut integer,
        tl: *mut f64,
        ldtl: *mut integer,
        tr: *mut f64,
        ldtr: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        scale: *mut f64,
        x: *mut f64,
        ldx: *mut integer,
        xnorm: *mut f64,
        info: *mut integer,
    );
    pub fn dla_syamv_(
        uplo: *mut integer,
        n: *mut integer,
        alpha: *mut f64,
        a: *mut f64,
        lda: *mut integer,
        x: *mut f64,
        incx: *mut integer,
        beta: *mut f64,
        y: *mut f64,
        incy: *mut integer,
    );
    pub fn dlasyf_aa_(
        uplo: *mut c_char,
        j1: *mut integer,
        m: *mut integer,
        nb: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        ipiv: *mut integer,
        h: *mut f64,
        ldh: *mut integer,
        work: *mut f64,
    );
    pub fn dlasyf_(
        uplo: *mut c_char,
        n: *mut integer,
        nb: *mut integer,
        kb: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        ipiv: *mut integer,
        w: *mut f64,
        ldw: *mut integer,
        info: *mut integer,
    );
    pub fn dlasyf_rk_(
        uplo: *mut c_char,
        n: *mut integer,
        nb: *mut integer,
        kb: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        e: *mut f64,
        ipiv: *mut integer,
        w: *mut f64,
        ldw: *mut integer,
        info: *mut integer,
    );
    pub fn dlasyf_rook_(
        uplo: *mut c_char,
        n: *mut integer,
        nb: *mut integer,
        kb: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        ipiv: *mut integer,
        w: *mut f64,
        ldw: *mut integer,
        info: *mut integer,
    );
    pub fn dla_syrfsx_extended_(
        prec_type: *mut integer,
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        af: *mut f64,
        ldaf: *mut integer,
        ipiv: *mut integer,
        colequ: *mut logical,
        c: *mut f64,
        b: *mut f64,
        ldb: *mut integer,
        y: *mut f64,
        ldy: *mut integer,
        berr_out: *mut f64,
        n_norms: *mut integer,
        err_bnds_norm: *mut f64,
        err_bnds_comp: *mut f64,
        res: *mut f64,
        ayb: *mut f64,
        dy: *mut f64,
        y_tail: *mut f64,
        rcond: *mut f64,
        ithresh: *mut integer,
        rthresh: *mut f64,
        dz_ub: *mut f64,
        ignore_cwise: *mut logical,
        info: *mut integer,
    );
    pub fn dlat2s_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        sa: *mut f32,
        ldsa: *mut integer,
        info: *mut integer,
    );
    pub fn dlatbs_(
        uplo: *mut c_char,
        trans: *mut c_char,
        diag: *mut c_char,
        normin: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut f64,
        ldab: *mut integer,
        x: *mut f64,
        scale: *mut f64,
        cnorm: *mut f64,
        info: *mut integer,
    );
    pub fn dlatdf_(
        ijob: *mut integer,
        n: *mut integer,
        z: *mut f64,
        ldz: *mut integer,
        rhs: *mut f64,
        rdsum: *mut f64,
        rdscal: *mut f64,
        ipiv: *mut integer,
        jpiv: *mut integer,
    );
    pub fn dlatps_(
        uplo: *mut c_char,
        trans: *mut c_char,
        diag: *mut c_char,
        normin: *mut c_char,
        n: *mut integer,
        ap: *mut f64,
        x: *mut f64,
        scale: *mut f64,
        cnorm: *mut f64,
        info: *mut integer,
    );
    pub fn dlatrd_(
        uplo: *mut c_char,
        n: *mut integer,
        nb: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        e: *mut f64,
        tau: *mut f64,
        w: *mut f64,
        ldw: *mut integer,
    );
    pub fn dlatrs_(
        uplo: *mut c_char,
        trans: *mut c_char,
        diag: *mut c_char,
        normin: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        x: *mut f64,
        scale: *mut f64,
        cnorm: *mut f64,
        info: *mut integer,
    );
    pub fn dlatrz_(
        m: *mut integer,
        n: *mut integer,
        l: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        tau: *mut f64,
        work: *mut f64,
    );
    pub fn dlatsqr_(
        m: *mut integer,
        n: *mut integer,
        mb: *mut integer,
        nb: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        t: *mut f64,
        ldt: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dlatzm_(
        side: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        v: *mut f64,
        incv: *mut integer,
        tau: *mut f64,
        c1: *mut f64,
        c2: *mut f64,
        ldc: *mut integer,
        work: *mut f64,
    );
    pub fn dlauu2_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn dlauum_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn dla_wwaddw_(n: *mut integer, x: *mut f64, y: *mut f64, w: *mut f64);
    pub fn dopmtr_(
        side: *mut c_char,
        uplo: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        ap: *mut f64,
        tau: *mut f64,
        c: *mut f64,
        ldc: *mut integer,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dorbdb1_(
        m: *mut integer,
        p: *mut integer,
        q: *mut integer,
        x11: *mut f64,
        ldx11: *mut integer,
        x21: *mut f64,
        ldx21: *mut integer,
        theta: *mut f64,
        phi: *mut f64,
        taup1: *mut f64,
        taup2: *mut f64,
        tauq1: *mut f64,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dorbdb2_(
        m: *mut integer,
        p: *mut integer,
        q: *mut integer,
        x11: *mut f64,
        ldx11: *mut integer,
        x21: *mut f64,
        ldx21: *mut integer,
        theta: *mut f64,
        phi: *mut f64,
        taup1: *mut f64,
        taup2: *mut f64,
        tauq1: *mut f64,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dorbdb3_(
        m: *mut integer,
        p: *mut integer,
        q: *mut integer,
        x11: *mut f64,
        ldx11: *mut integer,
        x21: *mut f64,
        ldx21: *mut integer,
        theta: *mut f64,
        phi: *mut f64,
        taup1: *mut f64,
        taup2: *mut f64,
        tauq1: *mut f64,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dorbdb4_(
        m: *mut integer,
        p: *mut integer,
        q: *mut integer,
        x11: *mut f64,
        ldx11: *mut integer,
        x21: *mut f64,
        ldx21: *mut integer,
        theta: *mut f64,
        phi: *mut f64,
        taup1: *mut f64,
        taup2: *mut f64,
        tauq1: *mut f64,
        phantom: *mut f64,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dorbdb5_(
        m1: *mut integer,
        m2: *mut integer,
        n: *mut integer,
        x1: *mut f64,
        incx1: *mut integer,
        x2: *mut f64,
        incx2: *mut integer,
        q1: *mut f64,
        ldq1: *mut integer,
        q2: *mut f64,
        ldq2: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dorbdb6_(
        m1: *mut integer,
        m2: *mut integer,
        n: *mut integer,
        x1: *mut f64,
        incx1: *mut integer,
        x2: *mut f64,
        incx2: *mut integer,
        q1: *mut f64,
        ldq1: *mut integer,
        q2: *mut f64,
        ldq2: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dorbdb_(
        trans: *mut c_char,
        signs: *mut c_char,
        m: *mut integer,
        p: *mut integer,
        q: *mut integer,
        x11: *mut f64,
        ldx11: *mut integer,
        x12: *mut f64,
        ldx12: *mut integer,
        x21: *mut f64,
        ldx21: *mut integer,
        x22: *mut f64,
        ldx22: *mut integer,
        theta: *mut f64,
        phi: *mut f64,
        taup1: *mut f64,
        taup2: *mut f64,
        tauq1: *mut f64,
        tauq2: *mut f64,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dorg2l_(
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        tau: *mut f64,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dorg2r_(
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        tau: *mut f64,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dorgl2_(
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        tau: *mut f64,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dorgbr_(
        vect: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        tau: *mut f64,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dorglq_(
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        tau: *mut f64,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dorgql_(
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        tau: *mut f64,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dorgqr_(
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        tau: *mut f64,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dorgr2_(
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        tau: *mut f64,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dorgrq_(
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        tau: *mut f64,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dorgtr_(
        uplo: *mut c_char,
        m: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        tau: *mut f64,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dorgtsqr_(
        m: *mut integer,
        n: *mut integer,
        mb: *mut integer,
        nb: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        t: *mut f64,
        ldt: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dorhr_col_(
        m: *mut integer,
        n: *mut integer,
        nb: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        t: *mut f64,
        ldt: *mut integer,
        d: *mut f64,
        info: *mut integer,
    );
    pub fn dorm22_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        n1: *mut integer,
        n2: *mut integer,
        q: *mut f64,
        ldq: *mut integer,
        c: *mut f64,
        ldc: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dorm2l_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        tau: *mut f64,
        c: *mut f64,
        ldc: *mut integer,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dorm2r_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        tau: *mut f64,
        c: *mut f64,
        ldc: *mut integer,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dormbr_(
        vect: *mut c_char,
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        tau: *mut f64,
        c: *mut f64,
        ldc: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dorml2_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        tau: *mut f64,
        c: *mut f64,
        ldc: *mut integer,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dormlq_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        tau: *mut f64,
        c: *mut f64,
        ldc: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dormql_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        tau: *mut f64,
        c: *mut f64,
        ldc: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dormqr_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        tau: *mut f64,
        c: *mut f64,
        ldc: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dormr2_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        tau: *mut f64,
        c: *mut f64,
        ldc: *mut integer,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dormr3_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        l: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        tau: *mut f64,
        c: *mut f64,
        ldc: *mut integer,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dormrq_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        tau: *mut f64,
        c: *mut f64,
        ldc: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dormrz_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        l: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        tau: *mut f64,
        c: *mut f64,
        ldc: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dormtr_(
        side: *mut c_char,
        uplo: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        tau: *mut f64,
        c: *mut f64,
        ldc: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dpbcon_(
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut f64,
        ldab: *mut integer,
        anorm: *mut f64,
        rcond: *mut f64,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dpbequ_(
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut f64,
        ldab: *mut integer,
        s: *mut f64,
        scond: *mut f64,
        amax: *mut f64,
        info: *mut integer,
    );
    pub fn dpbrfs_(
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        nrhs: *mut integer,
        ab: *mut f64,
        ldab: *mut integer,
        afb: *mut f64,
        ldafb: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        x: *mut f64,
        ldx: *mut integer,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dpbstf_(
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut f64,
        ldab: *mut integer,
        info: *mut integer,
    );
    pub fn dpbsv_(
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        nrhs: *mut integer,
        ab: *mut f64,
        ldab: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn dpbsvx_(
        fact: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        nrhs: *mut integer,
        ab: *mut f64,
        ldab: *mut integer,
        afb: *mut f64,
        ldafb: *mut integer,
        equed: *mut c_char,
        s: *mut f64,
        b: *mut f64,
        ldb: *mut integer,
        x: *mut f64,
        ldx: *mut integer,
        rcond: *mut f64,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dpbtf2_(
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut f64,
        ldab: *mut integer,
        info: *mut integer,
    );
    pub fn dpbtrf_(
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut f64,
        ldab: *mut integer,
        info: *mut integer,
    );
    pub fn dpbtrs_(
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        nrhs: *mut integer,
        ab: *mut f64,
        ldab: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn dpftrf_(
        transr: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        info: *mut integer,
    );
    pub fn dpftri_(
        transr: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        info: *mut integer,
    );
    pub fn dpftrs_(
        transr: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f64,
        b: *mut f64,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn dpocon_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        anorm: *mut f64,
        rcond: *mut f64,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dpoequb_(
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        s: *mut f64,
        scond: *mut f64,
        amax: *mut f64,
        info: *mut integer,
    );
    pub fn dpoequ_(
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        s: *mut f64,
        scond: *mut f64,
        amax: *mut f64,
        info: *mut integer,
    );
    pub fn dporfs_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        af: *mut f64,
        ldaf: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        x: *mut f64,
        ldx: *mut integer,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dporfsx_(
        uplo: *mut c_char,
        equed: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        af: *mut f64,
        ldaf: *mut integer,
        s: *mut f64,
        b: *mut f64,
        ldb: *mut integer,
        x: *mut f64,
        ldx: *mut integer,
        rcond: *mut f64,
        berr: *mut f64,
        n_err_bnds: *mut integer,
        err_bnds_norm: *mut f64,
        err_bnds_comp: *mut f64,
        nparams: *mut integer,
        params: *mut f64,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dposv_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn dposvx_(
        fact: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        af: *mut f64,
        ldaf: *mut integer,
        equed: *mut c_char,
        s: *mut f64,
        b: *mut f64,
        ldb: *mut integer,
        x: *mut f64,
        ldx: *mut integer,
        rcond: *mut f64,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dposvxx_(
        fact: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        af: *mut f64,
        ldaf: *mut integer,
        equed: *mut c_char,
        s: *mut f64,
        b: *mut f64,
        ldb: *mut integer,
        x: *mut f64,
        ldx: *mut integer,
        rcond: *mut f64,
        rpvgrw: *mut f64,
        berr: *mut f64,
        n_err_bnds: *mut integer,
        err_bnds_norm: *mut f64,
        err_bnds_comp: *mut f64,
        nparams: *mut integer,
        params: *mut f64,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dpotf2_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn dpotrf2_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn dpotrf_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn dpotri_(
        uplo: *mut c_char,
        n: *mut integer,
        buff_A: *mut f64,
        ldim_A: *mut integer,
        info: *mut integer,
    );
    pub fn dpotrs_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn dppcon_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut f64,
        anorm: *mut f64,
        rcond: *mut f64,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dppequ_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut f64,
        s: *mut f64,
        scond: *mut f64,
        amax: *mut f64,
        info: *mut integer,
    );
    pub fn dpprfs_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut f64,
        afp: *mut f64,
        b: *mut f64,
        ldb: *mut integer,
        x: *mut f64,
        ldx: *mut integer,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dppsv_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut f64,
        b: *mut f64,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn dppsvx_(
        fact: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut f64,
        afp: *mut f64,
        equed: *mut c_char,
        s: *mut f64,
        b: *mut f64,
        ldb: *mut integer,
        x: *mut f64,
        ldx: *mut integer,
        rcond: *mut f64,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dpptrf_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut f64,
        info: *mut integer,
    );
    pub fn dpptri_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut f64,
        info: *mut integer,
    );
    pub fn dpptrs_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut f64,
        b: *mut f64,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn dpstf2_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        piv: *mut integer,
        rank: *mut integer,
        tol: *mut f64,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dpstrf_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        piv: *mut integer,
        rank: *mut integer,
        tol: *mut f64,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dptcon_(
        n: *mut integer,
        d: *mut f64,
        e: *mut f64,
        anorm: *mut f64,
        rcond: *mut f64,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dpteqr_(
        compz: *mut c_char,
        n: *mut integer,
        d: *mut f64,
        e: *mut f64,
        z: *mut f64,
        ldz: *mut integer,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dptrfs_(
        n: *mut integer,
        nrhs: *mut integer,
        d: *mut f64,
        e: *mut f64,
        df: *mut f64,
        ef: *mut f64,
        b: *mut f64,
        ldb: *mut integer,
        x: *mut f64,
        ldx: *mut integer,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dptsv_(
        n: *mut integer,
        nrhs: *mut integer,
        d: *mut f64,
        e: *mut f64,
        b: *mut f64,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn dptsvx_(
        fact: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        d: *mut f64,
        e: *mut f64,
        df: *mut f64,
        ef: *mut f64,
        b: *mut f64,
        ldb: *mut integer,
        x: *mut f64,
        ldx: *mut integer,
        rcond: *mut f64,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dpttrf_(n: *mut integer, d: *mut f64, e: *mut f64, info: *mut integer);
    pub fn dpttrs_(
        n: *mut integer,
        nrhs: *mut integer,
        d: *mut f64,
        e: *mut f64,
        b: *mut f64,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn dptts2_(
        n: *mut integer,
        nrhs: *mut integer,
        d: *mut f64,
        e: *mut f64,
        b: *mut f64,
        ldb: *mut integer,
    );
    pub fn drscl_(n: *mut integer, sa: *mut f64, sx: *mut f64, incx: *mut integer);
    pub fn dsb2st_kernels_(
        uplo: *mut c_char,
        wantz: *mut logical,
        ttype: *mut integer,
        st: *mut integer,
        ed: *mut integer,
        sweep: *mut integer,
        n: *mut integer,
        nb: *mut integer,
        ib: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        v: *mut f64,
        tau: *mut f64,
        ldvt: *mut integer,
        work: *mut f64,
    );
    pub fn dsbev_2stage_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut f64,
        ldab: *mut integer,
        w: *mut f64,
        z: *mut f64,
        ldz: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dsbev_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut f64,
        ldab: *mut integer,
        w: *mut f64,
        z: *mut f64,
        ldz: *mut integer,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dsbevd_2stage_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut f64,
        ldab: *mut integer,
        w: *mut f64,
        z: *mut f64,
        ldz: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn dsbevd_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut f64,
        ldab: *mut integer,
        w: *mut f64,
        z: *mut f64,
        ldz: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn dsbevx_2stage_(
        jobz: *mut c_char,
        range: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut f64,
        ldab: *mut integer,
        q: *mut f64,
        ldq: *mut integer,
        vl: *mut f64,
        vu: *mut f64,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f64,
        m: *mut integer,
        w: *mut f64,
        z: *mut f64,
        ldz: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        iwork: *mut integer,
        ifail: *mut integer,
        info: *mut integer,
    );
    pub fn dsbevx_(
        jobz: *mut c_char,
        range: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut f64,
        ldab: *mut integer,
        q: *mut f64,
        ldq: *mut integer,
        vl: *mut f64,
        vu: *mut f64,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f64,
        m: *mut integer,
        w: *mut f64,
        z: *mut f64,
        ldz: *mut integer,
        work: *mut f64,
        iwork: *mut integer,
        ifail: *mut integer,
        info: *mut integer,
    );
    pub fn dsbgst_(
        vect: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ka: *mut integer,
        kb: *mut integer,
        ab: *mut f64,
        ldab: *mut integer,
        bb: *mut f64,
        ldbb: *mut integer,
        x: *mut f64,
        ldx: *mut integer,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dsbgv_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ka: *mut integer,
        kb: *mut integer,
        ab: *mut f64,
        ldab: *mut integer,
        bb: *mut f64,
        ldbb: *mut integer,
        w: *mut f64,
        z: *mut f64,
        ldz: *mut integer,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dsbgvd_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ka: *mut integer,
        kb: *mut integer,
        ab: *mut f64,
        ldab: *mut integer,
        bb: *mut f64,
        ldbb: *mut integer,
        w: *mut f64,
        z: *mut f64,
        ldz: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn dsbgvx_(
        jobz: *mut c_char,
        range: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ka: *mut integer,
        kb: *mut integer,
        ab: *mut f64,
        ldab: *mut integer,
        bb: *mut f64,
        ldbb: *mut integer,
        q: *mut f64,
        ldq: *mut integer,
        vl: *mut f64,
        vu: *mut f64,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f64,
        m: *mut integer,
        w: *mut f64,
        z: *mut f64,
        ldz: *mut integer,
        work: *mut f64,
        iwork: *mut integer,
        ifail: *mut integer,
        info: *mut integer,
    );
    pub fn dsbtrd_(
        vect: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut f64,
        ldab: *mut integer,
        d: *mut f64,
        e: *mut f64,
        q: *mut f64,
        ldq: *mut integer,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dsfrk_(
        transr: *mut c_char,
        uplo: *mut c_char,
        trans: *mut c_char,
        n: *mut integer,
        k: *mut integer,
        alpha: *mut f64,
        a: *mut f64,
        lda: *mut integer,
        beta: *mut f64,
        c__: *mut f64,
    );
    pub fn dsgesv_(
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        x: *mut f64,
        ldx: *mut integer,
        work: *mut f64,
        swork: *mut f32,
        iter: *mut integer,
        info: *mut integer,
    );
    pub fn dspcon_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut f64,
        ipiv: *mut integer,
        anorm: *mut f64,
        rcond: *mut f64,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dspev_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut f64,
        w: *mut f64,
        z: *mut f64,
        ldz: *mut integer,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dspevd_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut f64,
        w: *mut f64,
        z: *mut f64,
        ldz: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn dspevx_(
        jobz: *mut c_char,
        range: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut f64,
        vl: *mut f64,
        vu: *mut f64,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f64,
        m: *mut integer,
        w: *mut f64,
        z: *mut f64,
        ldz: *mut integer,
        work: *mut f64,
        iwork: *mut integer,
        ifail: *mut integer,
        info: *mut integer,
    );
    pub fn dspgst_(
        itype: *mut integer,
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut f64,
        bp: *mut f64,
        info: *mut integer,
    );
    pub fn dspgvd_(
        itype: *mut integer,
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut f64,
        bp: *mut f64,
        w: *mut f64,
        z: *mut f64,
        ldz: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn dspgv_(
        itype: *mut integer,
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut f64,
        bp: *mut f64,
        w: *mut f64,
        z: *mut f64,
        ldz: *mut integer,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dspgvx_(
        itype: *mut integer,
        jobz: *mut c_char,
        range: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut f64,
        bp: *mut f64,
        vl: *mut f64,
        vu: *mut f64,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f64,
        m: *mut integer,
        w: *mut f64,
        z: *mut f64,
        ldz: *mut integer,
        work: *mut f64,
        iwork: *mut integer,
        ifail: *mut integer,
        info: *mut integer,
    );
    pub fn dsposv_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        x: *mut f64,
        ldx: *mut integer,
        work: *mut f64,
        swork: *mut f32,
        iter: *mut integer,
        info: *mut integer,
    );
    pub fn dsprfs_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut f64,
        afp: *mut f64,
        ipiv: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        x: *mut f64,
        ldx: *mut integer,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dspsv_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut f64,
        ipiv: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn dspsvx_(
        fact: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut f64,
        afp: *mut f64,
        ipiv: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        x: *mut f64,
        ldx: *mut integer,
        rcond: *mut f64,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dsptrd_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut f64,
        d: *mut f64,
        e: *mut f64,
        tau: *mut f64,
        info: *mut integer,
    );
    pub fn dsptrf_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut f64,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn dsptri_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut f64,
        ipiv: *mut integer,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dsptrs_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut f64,
        ipiv: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn dstebz_(
        range: *mut c_char,
        order: *mut c_char,
        n: *mut integer,
        vl: *mut f64,
        vu: *mut f64,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f64,
        d: *mut f64,
        e: *mut f64,
        m: *mut integer,
        nsplit: *mut integer,
        w: *mut f64,
        iblock: *mut integer,
        isplit: *mut integer,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dstedc_(
        compz: *mut c_char,
        n: *mut integer,
        d: *mut f64,
        e: *mut f64,
        z: *mut f64,
        ldz: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn dstegr_(
        jobz: *mut c_char,
        range: *mut c_char,
        n: *mut integer,
        d: *mut f64,
        e: *mut f64,
        vl: *mut f64,
        vu: *mut f64,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f64,
        m: *mut integer,
        w: *mut f64,
        z: *mut f64,
        ldz: *mut integer,
        isuppz: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn dstein_(
        n: *mut integer,
        d: *mut f64,
        e: *mut f64,
        m: *mut integer,
        w: *mut f64,
        iblock: *mut integer,
        isplit: *mut integer,
        z: *mut f64,
        ldz: *mut integer,
        work: *mut f64,
        iwork: *mut integer,
        ifail: *mut integer,
        info: *mut integer,
    );
    pub fn dstemr_(
        jobz: *mut c_char,
        range: *mut c_char,
        n: *mut integer,
        d: *mut f64,
        e: *mut f64,
        vl: *mut f64,
        vu: *mut f64,
        il: *mut integer,
        iu: *mut integer,
        m: *mut integer,
        w: *mut f64,
        z: *mut f64,
        ldz: *mut integer,
        nzc: *mut integer,
        isuppz: *mut integer,
        tryrac: *mut logical,
        work: *mut f64,
        lwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn dsteqr_(
        compz: *mut c_char,
        n: *mut integer,
        d: *mut f64,
        e: *mut f64,
        z: *mut f64,
        ldz: *mut integer,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dsterf_(n: *mut integer, d: *mut f64, e: *mut f64, info: *mut integer);
    pub fn dstev_(
        jobz: *mut c_char,
        n: *mut integer,
        d: *mut f64,
        e: *mut f64,
        z: *mut f64,
        ldz: *mut integer,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dstevd_(
        jobz: *mut c_char,
        n: *mut integer,
        d: *mut f64,
        e: *mut f64,
        z: *mut f64,
        ldz: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn dstevr_(
        jobz: *mut c_char,
        range: *mut c_char,
        n: *mut integer,
        d: *mut f64,
        e: *mut f64,
        vl: *mut f64,
        vu: *mut f64,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f64,
        m: *mut integer,
        w: *mut f64,
        z: *mut f64,
        ldz: *mut integer,
        isuppz: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn dstevx_(
        jobz: *mut c_char,
        range: *mut c_char,
        n: *mut integer,
        d: *mut f64,
        e: *mut f64,
        vl: *mut f64,
        vu: *mut f64,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f64,
        m: *mut integer,
        w: *mut f64,
        z: *mut f64,
        ldz: *mut integer,
        work: *mut f64,
        iwork: *mut integer,
        ifail: *mut integer,
        info: *mut integer,
    );
    pub fn dsycon_3_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        e: *mut f64,
        ipiv: *mut integer,
        anorm: *mut f64,
        rcond: *mut f64,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dsycon_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        ipiv: *mut integer,
        anorm: *mut f64,
        rcond: *mut f64,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dsycon_rook_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        ipiv: *mut integer,
        anorm: *mut f64,
        rcond: *mut f64,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dsyconv_(
        uplo: *mut c_char,
        way: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dsyconvf_(
        uplo: *mut c_char,
        way: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        e: *mut f64,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn dsyconvf_rook_(
        uplo: *mut c_char,
        way: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        e: *mut f64,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn dsyequb_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        s: *mut f64,
        scond: *mut f64,
        amax: *mut f64,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dsyev_2stage_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        w: *mut f64,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dsyev_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        w: *mut f64,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dsyevd_2stage_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        w: *mut f64,
        work: *mut f64,
        lwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn dsyevd_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        w: *mut f64,
        work: *mut f64,
        lwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn dsyevr_2stage_(
        jobz: *mut c_char,
        range: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        vl: *mut f64,
        vu: *mut f64,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f64,
        m: *mut integer,
        w: *mut f64,
        z: *mut f64,
        ldz: *mut integer,
        isuppz: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn dsyevr_(
        jobz: *mut c_char,
        range: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        vl: *mut f64,
        vu: *mut f64,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f64,
        m: *mut integer,
        w: *mut f64,
        z: *mut f64,
        ldz: *mut integer,
        isuppz: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn dsyevx_2stage_(
        jobz: *mut c_char,
        range: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        vl: *mut f64,
        vu: *mut f64,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f64,
        m: *mut integer,
        w: *mut f64,
        z: *mut f64,
        ldz: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        iwork: *mut integer,
        ifail: *mut integer,
        info: *mut integer,
    );
    pub fn dsyevx_(
        jobz: *mut c_char,
        range: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        vl: *mut f64,
        vu: *mut f64,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f64,
        m: *mut integer,
        w: *mut f64,
        z: *mut f64,
        ldz: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        iwork: *mut integer,
        ifail: *mut integer,
        info: *mut integer,
    );
    pub fn dsygs2_(
        itype: *mut integer,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn dsygst_(
        itype: *mut integer,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn dsygv_2stage_(
        itype: *mut integer,
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        w: *mut f64,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dsygvd_(
        itype: *mut integer,
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        w: *mut f64,
        work: *mut f64,
        lwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn dsygv_(
        itype: *mut integer,
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        w: *mut f64,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dsygvx_(
        itype: *mut integer,
        jobz: *mut c_char,
        range: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        vl: *mut f64,
        vu: *mut f64,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f64,
        m: *mut integer,
        w: *mut f64,
        z: *mut f64,
        ldz: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        iwork: *mut integer,
        ifail: *mut integer,
        info: *mut integer,
    );
    pub fn dsyrfs_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        af: *mut f64,
        ldaf: *mut integer,
        ipiv: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        x: *mut f64,
        ldx: *mut integer,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dsyrfsx_(
        uplo: *mut c_char,
        equed: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        af: *mut f64,
        ldaf: *mut integer,
        ipiv: *mut integer,
        s: *mut f64,
        b: *mut f64,
        ldb: *mut integer,
        x: *mut f64,
        ldx: *mut integer,
        rcond: *mut f64,
        berr: *mut f64,
        n_err_bnds: *mut integer,
        err_bnds_norm: *mut f64,
        err_bnds_comp: *mut f64,
        nparams: *mut integer,
        params: *mut f64,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dsysv_aa_2stage_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        tb: *mut f64,
        ltb: *mut integer,
        ipiv: *mut integer,
        ipiv2: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dsysv_aa_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dsysv_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dsysv_rk_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        e: *mut f64,
        ipiv: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dsysv_rook_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dsysvx_(
        fact: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        af: *mut f64,
        ldaf: *mut integer,
        ipiv: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        x: *mut f64,
        ldx: *mut integer,
        rcond: *mut f64,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut f64,
        lwork: *mut integer,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dsysvxx_(
        fact: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        af: *mut f64,
        ldaf: *mut integer,
        ipiv: *mut integer,
        equed: *mut c_char,
        s: *mut f64,
        b: *mut f64,
        ldb: *mut integer,
        x: *mut f64,
        ldx: *mut integer,
        rcond: *mut f64,
        rpvgrw: *mut f64,
        berr: *mut f64,
        n_err_bnds: *mut integer,
        err_bnds_norm: *mut f64,
        err_bnds_comp: *mut f64,
        nparams: *mut integer,
        params: *mut f64,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dsyswapr_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        i1: *mut integer,
        i2: *mut integer,
    );
    pub fn dsytd2_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        d: *mut f64,
        e: *mut f64,
        tau: *mut f64,
        info: *mut integer,
    );
    pub fn dsytf2_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn dsytf2_rk_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        e: *mut f64,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn dsytf2_rook_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn dsytrd_2stage_(
        vect: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        d: *mut f64,
        e: *mut f64,
        tau: *mut f64,
        hous2: *mut f64,
        lhous2: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dsytrd_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        d: *mut f64,
        e: *mut f64,
        tau: *mut f64,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dsytrd_sb2st_(
        stage1: *mut c_char,
        vect: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut f64,
        ldab: *mut integer,
        d: *mut f64,
        e: *mut f64,
        hous: *mut f64,
        lhous: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dsytrd_sy2sb_(
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        ab: *mut f64,
        ldab: *mut integer,
        tau: *mut f64,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dsytrf_aa_2stage_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        tb: *mut f64,
        ltb: *mut integer,
        ipiv: *mut integer,
        ipiv2: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dsytrf_aa_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dsytrf_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dsytrf_rk_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        e: *mut f64,
        ipiv: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dsytrf_rook_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dsytri2_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dsytri2x_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut f64,
        nb: *mut integer,
        info: *mut integer,
    );
    pub fn dsytri_3_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        e: *mut f64,
        ipiv: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dsytri_3x_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        e: *mut f64,
        ipiv: *mut integer,
        work: *mut f64,
        nb: *mut integer,
        info: *mut integer,
    );
    pub fn dsytri_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dsytri_rook_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dsytrs2_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dsytrs_3_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        e: *mut f64,
        ipiv: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn dsytrs_aa_2stage_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        tb: *mut f64,
        ltb: *mut integer,
        ipiv: *mut integer,
        ipiv2: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn dsytrs_aa_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dsytrs_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn dsytrs_rook_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn dtbcon_(
        norm: *mut c_char,
        uplo: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut f64,
        ldab: *mut integer,
        rcond: *mut f64,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dtbrfs_(
        uplo: *mut c_char,
        trans: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        nrhs: *mut integer,
        ab: *mut f64,
        ldab: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        x: *mut f64,
        ldx: *mut integer,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dtbtrs_(
        uplo: *mut c_char,
        trans: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        nrhs: *mut integer,
        ab: *mut f64,
        ldab: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn dtfsm_(
        transr: *mut c_char,
        side: *mut c_char,
        uplo: *mut c_char,
        trans: *mut c_char,
        diag: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        alpha: *mut f64,
        a: *mut f64,
        b: *mut f64,
        ldb: *mut integer,
    );
    pub fn dtftri_(
        transr: *mut c_char,
        uplo: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        info: *mut integer,
    );
    pub fn dtfttp_(
        transr: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        arf: *mut f64,
        ap: *mut f64,
        info: *mut integer,
    );
    pub fn dtfttr_(
        transr: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        arf: *mut f64,
        a: *mut f64,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn dtgevc_(
        side: *mut c_char,
        howmny: *mut c_char,
        select: *mut logical,
        n: *mut integer,
        s: *mut f64,
        lds: *mut integer,
        p: *mut f64,
        ldp: *mut integer,
        vl: *mut f64,
        ldvl: *mut integer,
        vr: *mut f64,
        ldvr: *mut integer,
        mm: *mut integer,
        m: *mut integer,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dtgex2_(
        wantq: *mut logical,
        wantz: *mut logical,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        q: *mut f64,
        ldq: *mut integer,
        z: *mut f64,
        ldz: *mut integer,
        j1: *mut integer,
        n1: *mut integer,
        n2: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dtgexc_(
        wantq: *mut logical,
        wantz: *mut logical,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        q: *mut f64,
        ldq: *mut integer,
        z: *mut f64,
        ldz: *mut integer,
        ifst: *mut integer,
        ilst: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dtgsen_(
        ijob: *mut integer,
        wantq: *mut logical,
        wantz: *mut logical,
        select: *mut logical,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        alphar: *mut f64,
        alphai: *mut f64,
        beta: *mut f64,
        q: *mut f64,
        ldq: *mut integer,
        z: *mut f64,
        ldz: *mut integer,
        m: *mut integer,
        pl: *mut f64,
        pr: *mut f64,
        dif: *mut f64,
        work: *mut f64,
        lwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn dtgsja_(
        jobu: *mut c_char,
        jobv: *mut c_char,
        jobq: *mut c_char,
        m: *mut integer,
        p: *mut integer,
        n: *mut integer,
        k: *mut integer,
        l: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        tola: *mut f64,
        tolb: *mut f64,
        alpha: *mut f64,
        beta: *mut f64,
        u: *mut f64,
        ldu: *mut integer,
        v: *mut f64,
        ldv: *mut integer,
        q: *mut f64,
        ldq: *mut integer,
        work: *mut f64,
        ncycle: *mut integer,
        info: *mut integer,
    );
    pub fn dtgsna_(
        job: *mut c_char,
        howmny: *mut c_char,
        select: *mut logical,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        vl: *mut f64,
        ldvl: *mut integer,
        vr: *mut f64,
        ldvr: *mut integer,
        s: *mut f64,
        dif: *mut f64,
        mm: *mut integer,
        m: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dtgsy2_(
        trans: *mut c_char,
        ijob: *mut integer,
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        c: *mut f64,
        ldc: *mut integer,
        d: *mut f64,
        ldd: *mut integer,
        e: *mut f64,
        lde: *mut integer,
        f: *mut f64,
        ldf: *mut integer,
        scale: *mut f64,
        rdsum: *mut f64,
        rdscal: *mut f64,
        iwork: *mut integer,
        pq: *mut integer,
        info: *mut integer,
    );
    pub fn dtgsyl_(
        trans: *mut c_char,
        ijob: *mut integer,
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        c: *mut f64,
        ldc: *mut integer,
        d: *mut f64,
        ldd: *mut integer,
        e: *mut f64,
        lde: *mut integer,
        f: *mut f64,
        ldf: *mut integer,
        scale: *mut f64,
        dif: *mut f64,
        work: *mut f64,
        lwork: *mut integer,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dtpcon_(
        norm: *mut c_char,
        uplo: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        ap: *mut f64,
        rcond: *mut f64,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dtplqt2_(
        m: *mut integer,
        n: *mut integer,
        l: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        t: *mut f64,
        ldt: *mut integer,
        info: *mut integer,
    );
    pub fn dtplqt_(
        m: *mut integer,
        n: *mut integer,
        l: *mut integer,
        mb: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        t: *mut f64,
        ldt: *mut integer,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dtpmlqt_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        l: *mut integer,
        mb: *mut integer,
        v: *mut f64,
        ldv: *mut integer,
        t: *mut f64,
        ldt: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dtpmqrt_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        l: *mut integer,
        nb: *mut integer,
        v: *mut f64,
        ldv: *mut integer,
        t: *mut f64,
        ldt: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dtpqrt2_(
        m: *mut integer,
        n: *mut integer,
        l: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        t: *mut f64,
        ldt: *mut integer,
        info: *mut integer,
    );
    pub fn dtpqrt_(
        m: *mut integer,
        n: *mut integer,
        l: *mut integer,
        nb: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        t: *mut f64,
        ldt: *mut integer,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dtprfb_(
        side: *mut c_char,
        trans: *mut c_char,
        direct: *mut c_char,
        storev: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        l: *mut integer,
        v: *mut f64,
        ldv: *mut integer,
        t: *mut f64,
        ldt: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        work: *mut f64,
        ldwork: *mut integer,
    );
    pub fn dtprfs_(
        uplo: *mut c_char,
        trans: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut f64,
        b: *mut f64,
        ldb: *mut integer,
        x: *mut f64,
        ldx: *mut integer,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dtptri_(
        uplo: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        ap: *mut f64,
        info: *mut integer,
    );
    pub fn dtptrs_(
        uplo: *mut c_char,
        trans: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut f64,
        b: *mut f64,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn dtpttf_(
        transr: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut f64,
        arf: *mut f64,
        info: *mut integer,
    );
    pub fn dtpttr_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut f64,
        a: *mut f64,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn dtrcon_(
        norm: *mut c_char,
        uplo: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        rcond: *mut f64,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dtrevc3_(
        side: *mut c_char,
        howmny: *mut c_char,
        select: *mut logical,
        n: *mut integer,
        t: *mut f64,
        ldt: *mut integer,
        vl: *mut f64,
        ldvl: *mut integer,
        vr: *mut f64,
        ldvr: *mut integer,
        mm: *mut integer,
        m: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dtrevc_(
        side: *mut c_char,
        howmny: *mut c_char,
        select: *mut logical,
        n: *mut integer,
        t: *mut f64,
        ldt: *mut integer,
        vl: *mut f64,
        ldvl: *mut integer,
        vr: *mut f64,
        ldvr: *mut integer,
        mm: *mut integer,
        m: *mut integer,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dtrexc_(
        compq: *mut c_char,
        n: *mut integer,
        t: *mut f64,
        ldt: *mut integer,
        q: *mut f64,
        ldq: *mut integer,
        ifst: *mut integer,
        ilst: *mut integer,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn dtrrfs_(
        uplo: *mut c_char,
        trans: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        x: *mut f64,
        ldx: *mut integer,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dtrsen_(
        job: *mut c_char,
        compq: *mut c_char,
        select: *mut logical,
        n: *mut integer,
        t: *mut f64,
        ldt: *mut integer,
        q: *mut f64,
        ldq: *mut integer,
        wr: *mut f64,
        wi: *mut f64,
        m: *mut integer,
        s: *mut f64,
        sep: *mut f64,
        work: *mut f64,
        lwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn dtrsna_(
        job: *mut c_char,
        howmny: *mut c_char,
        select: *mut logical,
        n: *mut integer,
        t: *mut f64,
        ldt: *mut integer,
        vl: *mut f64,
        ldvl: *mut integer,
        vr: *mut f64,
        ldvr: *mut integer,
        s: *mut f64,
        sep: *mut f64,
        mm: *mut integer,
        m: *mut integer,
        work: *mut f64,
        ldwork: *mut integer,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dtrsyl_(
        trana: *mut c_char,
        tranb: *mut c_char,
        isgn: *mut integer,
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        c: *mut f64,
        ldc: *mut integer,
        scale: *mut f64,
        info: *mut integer,
    );
    pub fn dtrti2_(
        uplo: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn dtrtri_(
        uplo: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn dtrtrs_(
        uplo: *mut c_char,
        trans: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn dtrttf_(
        transr: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        arf: *mut f64,
        info: *mut integer,
    );
    pub fn dtrttp_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        ap: *mut f64,
        info: *mut integer,
    );
    pub fn dtzrqf_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        tau: *mut f64,
        info: *mut integer,
    );
    pub fn dtzrzf_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        tau: *mut f64,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn icmax1_(n: *mut integer, cx: *mut scomplex, incx: *mut integer) -> integer;
    pub fn ilaclc_(
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
    ) -> integer;
    pub fn ilaclr_(
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
    ) -> integer;
    pub fn iladiag_(diag: *mut c_char) -> integer;
    pub fn iladlc_(m: *mut integer, n: *mut integer, a: *mut f64, lda: *mut integer) -> integer;
    pub fn iladlr_(m: *mut integer, n: *mut integer, a: *mut f64, lda: *mut integer) -> integer;
    pub fn ilaenv2stage_(
        ispec: *mut integer,
        name: *mut c_char,
        opts: *mut c_char,
        n1: *mut integer,
        n2: *mut integer,
        n3: *mut integer,
        n4: *mut integer,
    ) -> integer;
    pub fn ilaprec_(prec: *mut c_char) -> integer;
    pub fn ilaslc_(m: *mut integer, n: *mut integer, a: *mut f32, lda: *mut integer) -> integer;
    pub fn ilaslr_(m: *mut integer, n: *mut integer, a: *mut f32, lda: *mut integer) -> integer;
    pub fn ilatrans_(trans: *mut c_char) -> integer;
    pub fn ilauplo_(uplo: *mut c_char) -> integer;
    pub fn ilaver_(vers_major: *mut integer, vers_minor: *mut integer, vers_patch__: *mut integer);
    pub fn ilazlc_(
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
    ) -> integer;
    pub fn ilazlr_(
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
    ) -> integer;
    pub fn iparam2stage_(
        ispec: *mut integer,
        name: *mut c_char,
        opts: *mut c_char,
        ni: *mut integer,
        nbi: *mut integer,
        ibi: *mut integer,
        nxi: *mut integer,
    ) -> integer;
    pub fn izmax1_(n: *mut integer, cx: *mut dcomplex, incx: *mut integer) -> integer;
    pub fn sbbcsd_(
        jobu1: *mut c_char,
        jobu2: *mut c_char,
        jobv1t: *mut c_char,
        jobv2t: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        p: *mut integer,
        q: *mut integer,
        theta: *mut f32,
        phi: *mut f32,
        u1: *mut f32,
        ldu1: *mut integer,
        u2: *mut f32,
        ldu2: *mut integer,
        v1t: *mut f32,
        ldv1t: *mut integer,
        v2t: *mut f32,
        ldv2t: *mut integer,
        b11d: *mut f32,
        b11e: *mut f32,
        b12d: *mut f32,
        b12e: *mut f32,
        b21d: *mut f32,
        b21e: *mut f32,
        b22d: *mut f32,
        b22e: *mut f32,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sbdsdc_(
        uplo: *mut c_char,
        compq: *mut c_char,
        n: *mut integer,
        d: *mut f32,
        e: *mut f32,
        u: *mut f32,
        ldu: *mut integer,
        vt: *mut f32,
        ldvt: *mut integer,
        q: *mut f32,
        iq: *mut f32,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn sbdsqr_(
        uplo: *mut c_char,
        n: *mut integer,
        ncvt: *mut integer,
        nru: *mut integer,
        ncc: *mut integer,
        d: *mut f32,
        e: *mut f32,
        vt: *mut f32,
        ldvt: *mut integer,
        u: *mut f32,
        ldu: *mut integer,
        c: *mut f32,
        ldc: *mut integer,
        rwork: *mut f32,
        info: *mut integer,
    );
    pub fn sbdsvdx_(
        uplo: *mut c_char,
        jobz: *mut c_char,
        range: *mut c_char,
        n: *mut integer,
        d: *mut f32,
        e: *mut f32,
        vl: *mut f32,
        vu: *mut f32,
        il: *mut integer,
        iu: *mut integer,
        ns: *mut integer,
        s: *mut f32,
        z: *mut f32,
        ldz: *mut integer,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn scombssq_(v1: *mut f32, v2: *mut f32);
    pub fn sdisna_(
        job: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        d: *mut f32,
        sep: *mut f32,
        info: *mut integer,
    );
    pub fn sgbbrd_(
        vect: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        ncc: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        ab: *mut f32,
        ldab: *mut integer,
        d: *mut f32,
        e: *mut f32,
        q: *mut f32,
        ldq: *mut integer,
        pt: *mut f32,
        ldpt: *mut integer,
        c: *mut f32,
        ldc: *mut integer,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn sgbcon_(
        norm: *mut c_char,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        ab: *mut f32,
        ldab: *mut integer,
        ipiv: *mut integer,
        anorm: *mut f32,
        rcond: *mut f32,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn sgbequb_(
        m: *mut integer,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        ab: *mut f32,
        ldab: *mut integer,
        r: *mut f32,
        c: *mut f32,
        rowcnd: *mut f32,
        colcnd: *mut f32,
        amax: *mut f32,
        info: *mut integer,
    );
    pub fn sgbequ_(
        m: *mut integer,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        ab: *mut f32,
        ldab: *mut integer,
        r: *mut f32,
        c: *mut f32,
        rowcnd: *mut f32,
        colcnd: *mut f32,
        amax: *mut f32,
        info: *mut integer,
    );
    pub fn sgbrfs_(
        trans: *mut c_char,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        nrhs: *mut integer,
        ab: *mut f32,
        ldab: *mut integer,
        afb: *mut f32,
        ldafb: *mut integer,
        ipiv: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        x: *mut f32,
        ldx: *mut integer,
        ferr: *mut f32,
        berr: *mut f32,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn sgbrfsx_(
        trans: *mut c_char,
        equed: *mut c_char,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        nrhs: *mut integer,
        ab: *mut f32,
        ldab: *mut integer,
        afb: *mut f32,
        ldafb: *mut integer,
        ipiv: *mut integer,
        r: *mut f32,
        c: *mut f32,
        b: *mut f32,
        ldb: *mut integer,
        x: *mut f32,
        ldx: *mut integer,
        rcond: *mut f32,
        berr: *mut f32,
        n_err_bnds: *mut integer,
        err_bnds_norm: *mut f32,
        err_bnds_comp: *mut f32,
        nparams: *mut integer,
        params: *mut f32,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn sgbsv_(
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        nrhs: *mut integer,
        ab: *mut f32,
        ldab: *mut integer,
        ipiv: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn sgbsvx_(
        fact: *mut c_char,
        trans: *mut c_char,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        nrhs: *mut integer,
        ab: *mut f32,
        ldab: *mut integer,
        afb: *mut f32,
        ldafb: *mut integer,
        ipiv: *mut integer,
        equed: *mut c_char,
        r: *mut f32,
        c: *mut f32,
        b: *mut f32,
        ldb: *mut integer,
        x: *mut f32,
        ldx: *mut integer,
        rcond: *mut f32,
        ferr: *mut f32,
        berr: *mut f32,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn sgbsvxx_(
        fact: *mut c_char,
        trans: *mut c_char,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        nrhs: *mut integer,
        ab: *mut f32,
        ldab: *mut integer,
        afb: *mut f32,
        ldafb: *mut integer,
        ipiv: *mut integer,
        equed: *mut c_char,
        r: *mut f32,
        c: *mut f32,
        b: *mut f32,
        ldb: *mut integer,
        x: *mut f32,
        ldx: *mut integer,
        rcond: *mut f32,
        rpvgrw: *mut f32,
        berr: *mut f32,
        n_err_bnds: *mut integer,
        err_bnds_norm: *mut f32,
        err_bnds_comp: *mut f32,
        nparams: *mut integer,
        params: *mut f32,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn sgbtf2_(
        m: *mut integer,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        ab: *mut f32,
        ldab: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn sgbtrf_(
        m: *mut integer,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        ab: *mut f32,
        ldab: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn sgbtrs_(
        trans: *mut c_char,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        nrhs: *mut integer,
        ab: *mut f32,
        ldab: *mut integer,
        ipiv: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn sgebak_(
        job: *mut c_char,
        side: *mut c_char,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        scale: *mut f32,
        m: *mut integer,
        v: *mut f32,
        ldv: *mut integer,
        info: *mut integer,
    );
    pub fn sgebal_(
        job: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        scale: *mut f32,
        info: *mut integer,
    );
    pub fn sgebd2_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        d: *mut f32,
        e: *mut f32,
        tauq: *mut f32,
        taup: *mut f32,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn sgebrd_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        d: *mut f32,
        e: *mut f32,
        tauq: *mut f32,
        taup: *mut f32,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sgecon_(
        norm: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        anorm: *mut f32,
        rcond: *mut f32,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn sgeequb_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        r: *mut f32,
        c: *mut f32,
        rowcnd: *mut f32,
        colcnd: *mut f32,
        amax: *mut f32,
        info: *mut integer,
    );
    pub fn sgeequ_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        r: *mut f32,
        c: *mut f32,
        rowcnd: *mut f32,
        colcnd: *mut f32,
        amax: *mut f32,
        info: *mut integer,
    );
    pub fn sgees_(
        jobvs: *mut c_char,
        sort: *mut c_char,
        select: L_fp,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        sdim: *mut integer,
        wr: *mut f32,
        wi: *mut f32,
        vs: *mut f32,
        ldvs: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        bwork: *mut logical,
        info: *mut integer,
    );
    pub fn sgeesx_(
        jobvs: *mut c_char,
        sort: *mut c_char,
        select: L_fp,
        sense: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        sdim: *mut integer,
        wr: *mut f32,
        wi: *mut f32,
        vs: *mut f32,
        ldvs: *mut integer,
        rconde: *mut f32,
        rcondv: *mut f32,
        work: *mut f32,
        lwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        bwork: *mut logical,
        info: *mut integer,
    );
    pub fn sgeev_(
        jobvl: *mut c_char,
        jobvr: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        wr: *mut f32,
        wi: *mut f32,
        vl: *mut f32,
        ldvl: *mut integer,
        vr: *mut f32,
        ldvr: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sgeevx_(
        balanc: *mut c_char,
        jobvl: *mut c_char,
        jobvr: *mut c_char,
        sense: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        wr: *mut f32,
        wi: *mut f32,
        vl: *mut f32,
        ldvl: *mut integer,
        vr: *mut f32,
        ldvr: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        scale: *mut f32,
        abnrm: *mut f32,
        rconde: *mut f32,
        rcondv: *mut f32,
        work: *mut f32,
        lwork: *mut integer,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn sgegs_(
        jobvsl: *mut c_char,
        jobvsr: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        alphar: *mut f32,
        alphai: *mut f32,
        beta: *mut f32,
        vsl: *mut f32,
        ldvsl: *mut integer,
        vsr: *mut f32,
        ldvsr: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sgegv_(
        jobvl: *mut c_char,
        jobvr: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        alphar: *mut f32,
        alphai: *mut f32,
        beta: *mut f32,
        vl: *mut f32,
        ldvl: *mut integer,
        vr: *mut f32,
        ldvr: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sgehd2_(
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        tau: *mut f32,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn sgehrd_(
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        tau: *mut f32,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sgejsv_(
        joba: *mut c_char,
        jobu: *mut c_char,
        jobv: *mut c_char,
        jobr: *mut c_char,
        jobt: *mut c_char,
        jobp: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        sva: *mut f32,
        u: *mut f32,
        ldu: *mut integer,
        v: *mut f32,
        ldv: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn sgelq2_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        tau: *mut f32,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn sgelqf_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        tau: *mut f32,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sgelq_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        t: *mut f32,
        tsize: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sgelqt3_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        t: *mut f32,
        ldt: *mut integer,
        info: *mut integer,
    );
    pub fn sgelqt_(
        m: *mut integer,
        n: *mut integer,
        mb: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        t: *mut f32,
        ldt: *mut integer,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn sgels_(
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sgelsd_(
        m: *mut integer,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        s: *mut f32,
        rcond: *mut f32,
        rank: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn sgelss_(
        m: *mut integer,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        s: *mut f32,
        rcond: *mut f32,
        rank: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sgelsx_(
        m: *mut integer,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        jpvt: *mut integer,
        rcond: *mut f32,
        rank: *mut integer,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn sgelsy_(
        m: *mut integer,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        jpvt: *mut integer,
        rcond: *mut f32,
        rank: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sgemlq_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        t: *mut f32,
        tsize: *mut integer,
        c: *mut f32,
        ldc: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sgemlqt_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        mb: *mut integer,
        v: *mut f32,
        ldv: *mut integer,
        t: *mut f32,
        ldt: *mut integer,
        c: *mut f32,
        ldc: *mut integer,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn sgemqr_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        t: *mut f32,
        tsize: *mut integer,
        c: *mut f32,
        ldc: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sgemqrt_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        nb: *mut integer,
        v: *mut f32,
        ldv: *mut integer,
        t: *mut f32,
        ldt: *mut integer,
        c: *mut f32,
        ldc: *mut integer,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn sgeql2_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        tau: *mut f32,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn sgeqlf_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        tau: *mut f32,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sgeqp3_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        jpvt: *mut integer,
        tau: *mut f32,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sgeqpf_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        jpvt: *mut integer,
        tau: *mut f32,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn sgeqr2_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        tau: *mut f32,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn sgeqr2p_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        tau: *mut f32,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn sgeqrf_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        tau: *mut f32,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sgeqrfp_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        tau: *mut f32,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sgeqr_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        t: *mut f32,
        tsize: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sgeqrt2_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        t: *mut f32,
        ldt: *mut integer,
        info: *mut integer,
    );
    pub fn sgeqrt3_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        t: *mut f32,
        ldt: *mut integer,
        info: *mut integer,
    );
    pub fn sgeqrt_(
        m: *mut integer,
        n: *mut integer,
        nb: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        t: *mut f32,
        ldt: *mut integer,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn sgerfs_(
        trans: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        af: *mut f32,
        ldaf: *mut integer,
        ipiv: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        x: *mut f32,
        ldx: *mut integer,
        ferr: *mut f32,
        berr: *mut f32,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn sgerfsx_(
        trans: *mut c_char,
        equed: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        af: *mut f32,
        ldaf: *mut integer,
        ipiv: *mut integer,
        r: *mut f32,
        c: *mut f32,
        b: *mut f32,
        ldb: *mut integer,
        x: *mut f32,
        ldx: *mut integer,
        rcond: *mut f32,
        berr: *mut f32,
        n_err_bnds: *mut integer,
        err_bnds_norm: *mut f32,
        err_bnds_comp: *mut f32,
        nparams: *mut integer,
        params: *mut f32,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn sgerq2_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        tau: *mut f32,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn sgerqf_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        tau: *mut f32,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sgesc2_(
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        rhs: *mut f32,
        ipiv: *mut integer,
        jpiv: *mut integer,
        scale: *mut f32,
    );
    pub fn sgesdd_(
        jobz: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        s: *mut f32,
        u: *mut f32,
        ldu: *mut integer,
        vt: *mut f32,
        ldvt: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn sgesvd_(
        jobu: *mut c_char,
        jobv: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        s: *mut f32,
        u: *mut f32,
        ldu: *mut integer,
        vt: *mut f32,
        ldvt: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sgesvdq_(
        joba: *mut c_char,
        jobp: *mut c_char,
        jobr: *mut c_char,
        jobu: *mut c_char,
        jobv: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        s: *mut f32,
        u: *mut f32,
        ldu: *mut integer,
        v: *mut f32,
        ldv: *mut integer,
        numrank: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        rwork: *mut f32,
        lrwork: *mut integer,
        info: *mut integer,
    );
    pub fn sgesvdx_(
        jobu: *mut c_char,
        jobvt: *mut c_char,
        range: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        vl: *mut f32,
        vu: *mut f32,
        il: *mut integer,
        iu: *mut integer,
        ns: *mut integer,
        s: *mut f32,
        u: *mut f32,
        ldu: *mut integer,
        vt: *mut f32,
        ldvt: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn sgesv_(
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn sgesvj_(
        joba: *mut c_char,
        jobu: *mut c_char,
        jobv: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        sva: *mut f32,
        mv: *mut integer,
        v: *mut f32,
        ldv: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sgesvx_(
        fact: *mut c_char,
        trans: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        af: *mut f32,
        ldaf: *mut integer,
        ipiv: *mut integer,
        equed: *mut c_char,
        r: *mut f32,
        c: *mut f32,
        b: *mut f32,
        ldb: *mut integer,
        x: *mut f32,
        ldx: *mut integer,
        rcond: *mut f32,
        ferr: *mut f32,
        berr: *mut f32,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn sgesvxx_(
        fact: *mut c_char,
        trans: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        af: *mut f32,
        ldaf: *mut integer,
        ipiv: *mut integer,
        equed: *mut c_char,
        r: *mut f32,
        c: *mut f32,
        b: *mut f32,
        ldb: *mut integer,
        x: *mut f32,
        ldx: *mut integer,
        rcond: *mut f32,
        rpvgrw: *mut f32,
        berr: *mut f32,
        n_err_bnds: *mut integer,
        err_bnds_norm: *mut f32,
        err_bnds_comp: *mut f32,
        nparams: *mut integer,
        params: *mut f32,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn sgetc2_(
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        ipiv: *mut integer,
        jpiv: *mut integer,
        info: *mut integer,
    );
    pub fn sgetf2_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn sgetrf2_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn sgetrf_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn sgetri_(
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sgetrs_(
        trans: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn sgetsls_(
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sggbak_(
        job: *mut c_char,
        side: *mut c_char,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        lscale: *mut f32,
        rscale: *mut f32,
        m: *mut integer,
        v: *mut f32,
        ldv: *mut integer,
        info: *mut integer,
    );
    pub fn sggbal_(
        job: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        lscale: *mut f32,
        rscale: *mut f32,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn sgges3_(
        jobvsl: *mut c_char,
        jobvsr: *mut c_char,
        sort: *mut c_char,
        selctg: L_fp,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        sdim: *mut integer,
        alphar: *mut f32,
        alphai: *mut f32,
        beta: *mut f32,
        vsl: *mut f32,
        ldvsl: *mut integer,
        vsr: *mut f32,
        ldvsr: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        bwork: *mut logical,
        info: *mut integer,
    );
    pub fn sgges_(
        jobvsl: *mut c_char,
        jobvsr: *mut c_char,
        sort: *mut c_char,
        selctg: L_fp,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        sdim: *mut integer,
        alphar: *mut f32,
        alphai: *mut f32,
        beta: *mut f32,
        vsl: *mut f32,
        ldvsl: *mut integer,
        vsr: *mut f32,
        ldvsr: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        bwork: *mut logical,
        info: *mut integer,
    );
    pub fn sggesx_(
        jobvsl: *mut c_char,
        jobvsr: *mut c_char,
        sort: *mut c_char,
        selctg: L_fp,
        sense: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        sdim: *mut integer,
        alphar: *mut f32,
        alphai: *mut f32,
        beta: *mut f32,
        vsl: *mut f32,
        ldvsl: *mut integer,
        vsr: *mut f32,
        ldvsr: *mut integer,
        rconde: *mut f32,
        rcondv: *mut f32,
        work: *mut f32,
        lwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        bwork: *mut logical,
        info: *mut integer,
    );
    pub fn sggev3_(
        jobvl: *mut c_char,
        jobvr: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        alphar: *mut f32,
        alphai: *mut f32,
        beta: *mut f32,
        vl: *mut f32,
        ldvl: *mut integer,
        vr: *mut f32,
        ldvr: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sggev_(
        jobvl: *mut c_char,
        jobvr: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        alphar: *mut f32,
        alphai: *mut f32,
        beta: *mut f32,
        vl: *mut f32,
        ldvl: *mut integer,
        vr: *mut f32,
        ldvr: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sggevx_(
        balanc: *mut c_char,
        jobvl: *mut c_char,
        jobvr: *mut c_char,
        sense: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        alphar: *mut f32,
        alphai: *mut f32,
        beta: *mut f32,
        vl: *mut f32,
        ldvl: *mut integer,
        vr: *mut f32,
        ldvr: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        lscale: *mut f32,
        rscale: *mut f32,
        abnrm: *mut f32,
        bbnrm: *mut f32,
        rconde: *mut f32,
        rcondv: *mut f32,
        work: *mut f32,
        lwork: *mut integer,
        iwork: *mut integer,
        bwork: *mut logical,
        info: *mut integer,
    );
    pub fn sggglm_(
        n: *mut integer,
        m: *mut integer,
        p: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        d: *mut f32,
        x: *mut f32,
        y: *mut f32,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sgghd3_(
        compq: *mut c_char,
        compz: *mut c_char,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        q: *mut f32,
        ldq: *mut integer,
        z: *mut f32,
        ldz: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sgghrd_(
        compq: *mut c_char,
        compz: *mut c_char,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        q: *mut f32,
        ldq: *mut integer,
        z: *mut f32,
        ldz: *mut integer,
        info: *mut integer,
    );
    pub fn sgglse_(
        m: *mut integer,
        n: *mut integer,
        p: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        c: *mut f32,
        d: *mut f32,
        x: *mut f32,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sggqrf_(
        n: *mut integer,
        m: *mut integer,
        p: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        taua: *mut f32,
        b: *mut f32,
        ldb: *mut integer,
        taub: *mut f32,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sggrqf_(
        m: *mut integer,
        p: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        taua: *mut f32,
        b: *mut f32,
        ldb: *mut integer,
        taub: *mut f32,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sggsvd3_(
        jobu: *mut c_char,
        jobv: *mut c_char,
        jobq: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        p: *mut integer,
        k: *mut integer,
        l: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        alpha: *mut f32,
        beta: *mut f32,
        u: *mut f32,
        ldu: *mut integer,
        v: *mut f32,
        ldv: *mut integer,
        q: *mut f32,
        ldq: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn sggsvd_(
        jobu: *mut c_char,
        jobv: *mut c_char,
        jobq: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        p: *mut integer,
        k: *mut integer,
        l: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        alpha: *mut f32,
        beta: *mut f32,
        u: *mut f32,
        ldu: *mut integer,
        v: *mut f32,
        ldv: *mut integer,
        q: *mut f32,
        ldq: *mut integer,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn sggsvp3_(
        jobu: *mut c_char,
        jobv: *mut c_char,
        jobq: *mut c_char,
        m: *mut integer,
        p: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        tola: *mut f32,
        tolb: *mut f32,
        k: *mut integer,
        l: *mut integer,
        u: *mut f32,
        ldu: *mut integer,
        v: *mut f32,
        ldv: *mut integer,
        q: *mut f32,
        ldq: *mut integer,
        iwork: *mut integer,
        tau: *mut f32,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sggsvp_(
        jobu: *mut c_char,
        jobv: *mut c_char,
        jobq: *mut c_char,
        m: *mut integer,
        p: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        tola: *mut f32,
        tolb: *mut f32,
        k: *mut integer,
        l: *mut integer,
        u: *mut f32,
        ldu: *mut integer,
        v: *mut f32,
        ldv: *mut integer,
        q: *mut f32,
        ldq: *mut integer,
        iwork: *mut integer,
        tau: *mut f32,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn sgsvj0_(
        jobv: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        d: *mut f32,
        sva: *mut f32,
        mv: *mut integer,
        v: *mut f32,
        ldv: *mut integer,
        eps: *mut f32,
        sfmin: *mut f32,
        tol: *mut f32,
        nsweep: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sgsvj1_(
        jobv: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        n1: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        d: *mut f32,
        sva: *mut f32,
        mv: *mut integer,
        v: *mut f32,
        ldv: *mut integer,
        eps: *mut f32,
        sfmin: *mut f32,
        tol: *mut f32,
        nsweep: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sgtcon_(
        norm: *mut c_char,
        n: *mut integer,
        dl: *mut f32,
        d: *mut f32,
        du: *mut f32,
        du2: *mut f32,
        ipiv: *mut integer,
        anorm: *mut f32,
        rcond: *mut f32,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn sgtrfs_(
        trans: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        dl: *mut f32,
        d: *mut f32,
        du: *mut f32,
        dlf: *mut f32,
        df: *mut f32,
        duf: *mut f32,
        du2: *mut f32,
        ipiv: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        x: *mut f32,
        ldx: *mut integer,
        ferr: *mut f32,
        berr: *mut f32,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn sgtsv_(
        n: *mut integer,
        nrhs: *mut integer,
        dl: *mut f32,
        d: *mut f32,
        du: *mut f32,
        b: *mut f32,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn sgtsvx_(
        fact: *mut c_char,
        trans: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        dl: *mut f32,
        d: *mut f32,
        du: *mut f32,
        dlf: *mut f32,
        df: *mut f32,
        duf: *mut f32,
        du2: *mut f32,
        ipiv: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        x: *mut f32,
        ldx: *mut integer,
        rcond: *mut f32,
        ferr: *mut f32,
        berr: *mut f32,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn sgttrf_(
        n: *mut integer,
        dl: *mut f32,
        d: *mut f32,
        du: *mut f32,
        du2: *mut f32,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn sgttrs_(
        trans: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        dl: *mut f32,
        d: *mut f32,
        du: *mut f32,
        du2: *mut f32,
        ipiv: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn sgtts2_(
        itrans: *mut integer,
        n: *mut integer,
        nrhs: *mut integer,
        dl: *mut f32,
        d: *mut f32,
        du: *mut f32,
        du2: *mut f32,
        ipiv: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
    );
    pub fn shgeqz_(
        job: *mut c_char,
        compq: *mut c_char,
        compz: *mut c_char,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        h: *mut f32,
        ldh: *mut integer,
        t: *mut f32,
        ldt: *mut integer,
        alphar: *mut f32,
        alphai: *mut f32,
        beta: *mut f32,
        q: *mut f32,
        ldq: *mut integer,
        z: *mut f32,
        ldz: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn shsein_(
        side: *mut c_char,
        eigsrc: *mut c_char,
        initv: *mut c_char,
        select: *mut logical,
        n: *mut integer,
        h: *mut f32,
        ldh: *mut integer,
        wr: *mut f32,
        wi: *mut f32,
        vl: *mut f32,
        ldvl: *mut integer,
        vr: *mut f32,
        ldvr: *mut integer,
        mm: *mut integer,
        m: *mut integer,
        work: *mut f32,
        ifaill: *mut integer,
        ifailr: *mut integer,
        info: *mut integer,
    );
    pub fn shseqr_(
        job: *mut c_char,
        compz: *mut c_char,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        h: *mut f32,
        ldh: *mut integer,
        wr: *mut f32,
        wi: *mut f32,
        z: *mut f32,
        ldz: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn slabad_(small_: *mut f32, large: *mut f32);
    pub fn slabrd_(
        m: *mut integer,
        n: *mut integer,
        nb: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        d: *mut f32,
        e: *mut f32,
        tauq: *mut f32,
        taup: *mut f32,
        x: *mut f32,
        ldx: *mut integer,
        y: *mut f32,
        ldy: *mut integer,
    );
    pub fn slacn2_(
        n: *mut integer,
        v: *mut f32,
        x: *mut f32,
        isgn: *mut integer,
        est: *mut f32,
        kase: *mut integer,
        isave: *mut integer,
    );
    pub fn slacon_(
        n: *mut integer,
        v: *mut f32,
        x: *mut f32,
        isgn: *mut integer,
        est: *mut f32,
        kase: *mut integer,
    );
    pub fn slacpy_(
        uplo: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
    );
    pub fn sladiv_(a: *mut f32, b: *mut f32, c: *mut f32, d: *mut f32, p: *mut f32, q: *mut f32);
    pub fn slae2_(a: *mut f32, b: *mut f32, c: *mut f32, rt1: *mut f32, rt2: *mut f32);
    pub fn slaebz_(
        ijob: *mut integer,
        nitmax: *mut integer,
        n: *mut integer,
        mmax: *mut integer,
        minp: *mut integer,
        nbmin: *mut integer,
        abstol: *mut f32,
        reltol: *mut f32,
        pivmin: *mut f32,
        d: *mut f32,
        e: *mut f32,
        e2: *mut f32,
        nval: *mut integer,
        ab: *mut f32,
        c: *mut f32,
        mout: *mut integer,
        nab: *mut integer,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn slaed0_(
        icompq: *mut integer,
        qsiz: *mut integer,
        n: *mut integer,
        d: *mut f32,
        e: *mut f32,
        q: *mut f32,
        ldq: *mut integer,
        qstore: *mut f32,
        ldqs: *mut integer,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn slaed1_(
        n: *mut integer,
        d: *mut f32,
        q: *mut f32,
        ldq: *mut integer,
        indxq: *mut integer,
        rho: *mut f32,
        cutpnt: *mut integer,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn slaed2_(
        k: *mut integer,
        n: *mut integer,
        n1: *mut integer,
        d: *mut f32,
        q: *mut f32,
        ldq: *mut integer,
        indxq: *mut integer,
        rho: *mut f32,
        z: *mut f32,
        dlamda: *mut f32,
        w: *mut f32,
        q2: *mut f32,
        indx: *mut integer,
        indxc: *mut integer,
        indxp: *mut integer,
        coltyp: *mut integer,
        info: *mut integer,
    );
    pub fn slaed3_(
        k: *mut integer,
        n: *mut integer,
        n1: *mut integer,
        d: *mut f32,
        q: *mut f32,
        ldq: *mut integer,
        rho: *mut f32,
        dlamda: *mut f32,
        q2: *mut f32,
        indx: *mut integer,
        ctot: *mut integer,
        w: *mut f32,
        s: *mut f32,
        info: *mut integer,
    );
    pub fn slaed4_(
        n: *mut integer,
        i: *mut integer,
        d: *mut f32,
        z: *mut f32,
        delta: *mut f32,
        rho: *mut f32,
        dlam: *mut f32,
        info: *mut integer,
    );
    pub fn slaed5_(
        i: *mut integer,
        d: *mut f32,
        z: *mut f32,
        delta: *mut f32,
        rho: *mut f32,
        dlam: *mut f32,
    );
    pub fn slaed6_(
        kniter: *mut integer,
        orgati: *mut logical,
        rho: *mut f32,
        d: *mut f32,
        z: *mut f32,
        finit: *mut f32,
        tau: *mut f32,
        info: *mut integer,
    );
    pub fn slaed7_(
        icompq: *mut integer,
        n: *mut integer,
        qsiz: *mut integer,
        tlvls: *mut integer,
        curlvl: *mut integer,
        curpbm: *mut integer,
        d: *mut f32,
        q: *mut f32,
        ldq: *mut integer,
        indxq: *mut integer,
        rho: *mut f32,
        cutpnt: *mut integer,
        qstore: *mut f32,
        qptr: *mut integer,
        prmptr: *mut integer,
        perm: *mut integer,
        givptr: *mut integer,
        givcol: *mut integer,
        givnum: *mut f32,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn slaed8_(
        icompq: *mut integer,
        k: *mut integer,
        n: *mut integer,
        qsiz: *mut integer,
        d: *mut f32,
        q: *mut f32,
        ldq: *mut integer,
        indxq: *mut integer,
        rho: *mut f32,
        cutpnt: *mut integer,
        z: *mut f32,
        dlamda: *mut f32,
        q2: *mut f32,
        ldq2: *mut integer,
        w: *mut f32,
        perm: *mut integer,
        givptr: *mut integer,
        givcol: *mut integer,
        givnum: *mut f32,
        indxp: *mut integer,
        indx: *mut integer,
        info: *mut integer,
    );
    pub fn slaed9_(
        k: *mut integer,
        kstart: *mut integer,
        kstop: *mut integer,
        n: *mut integer,
        d: *mut f32,
        q: *mut f32,
        ldq: *mut integer,
        rho: *mut f32,
        dlamda: *mut f32,
        w: *mut f32,
        s: *mut f32,
        lds: *mut integer,
        info: *mut integer,
    );
    pub fn slaeda_(
        n: *mut integer,
        tlvls: *mut integer,
        curlvl: *mut integer,
        curpbm: *mut integer,
        prmptr: *mut integer,
        perm: *mut integer,
        givptr: *mut integer,
        givcol: *mut integer,
        givnum: *mut f32,
        q: *mut f32,
        qptr: *mut integer,
        z: *mut f32,
        ztemp: *mut f32,
        info: *mut integer,
    );
    pub fn slaein_(
        rightv: *mut logical,
        noinit: *mut logical,
        n: *mut integer,
        h: *mut f32,
        ldh: *mut integer,
        wr: *mut f32,
        wi: *mut f32,
        vr: *mut f32,
        vi: *mut f32,
        b: *mut f32,
        ldb: *mut integer,
        work: *mut f32,
        eps3: *mut f32,
        smlnum: *mut f32,
        bignum: *mut f32,
        info: *mut integer,
    );
    pub fn slaev2_(
        a: *mut f32,
        b: *mut f32,
        c: *mut f32,
        rt1: *mut f32,
        rt2: *mut f32,
        cs1: *mut f32,
        sn1: *mut f32,
    );
    pub fn slaexc_(
        wantq: *mut logical,
        n: *mut integer,
        t: *mut f32,
        ldt: *mut integer,
        q: *mut f32,
        ldq: *mut integer,
        j1: *mut integer,
        n1: *mut integer,
        n2: *mut integer,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn slag2d_(
        m: *mut integer,
        n: *mut integer,
        sa: *mut f32,
        ldsa: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn slag2_(
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        safmin: *mut f32,
        scale1: *mut f32,
        scale2: *mut f32,
        wr1: *mut f32,
        wr2: *mut f32,
        wi: *mut f32,
    );
    pub fn sla_gbamv_(
        trans: *mut integer,
        m: *mut integer,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        alpha: *mut f32,
        ab: *mut f32,
        ldab: *mut integer,
        x: *mut f32,
        incx: *mut integer,
        beta: *mut f32,
        y: *mut f32,
        incy: *mut integer,
    );
    pub fn sla_gbrfsx_extended_(
        prec_type: *mut integer,
        trans_type: *mut integer,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        nrhs: *mut integer,
        ab: *mut f32,
        ldab: *mut integer,
        afb: *mut f32,
        ldafb: *mut integer,
        ipiv: *mut integer,
        colequ: *mut logical,
        c: *mut f32,
        b: *mut f32,
        ldb: *mut integer,
        y: *mut f32,
        ldy: *mut integer,
        berr_out: *mut f32,
        n_norms: *mut integer,
        err_bnds_norm: *mut f32,
        err_bnds_comp: *mut f32,
        res: *mut f32,
        ayb: *mut f32,
        dy: *mut f32,
        y_tail: *mut f32,
        rcond: *mut f32,
        ithresh: *mut integer,
        rthresh: *mut f32,
        dz_ub: *mut f32,
        ignore_cwise: *mut logical,
        info: *mut integer,
    );
    pub fn sla_geamv_(
        trans: *mut integer,
        m: *mut integer,
        n: *mut integer,
        alpha: *mut f32,
        a: *mut f32,
        lda: *mut integer,
        x: *mut f32,
        incx: *mut integer,
        beta: *mut f32,
        y: *mut f32,
        incy: *mut integer,
    );
    pub fn sla_gerfsx_extended_(
        prec_type: *mut integer,
        trans_type: *mut integer,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        af: *mut f32,
        ldaf: *mut integer,
        ipiv: *mut integer,
        colequ: *mut logical,
        c: *mut f32,
        b: *mut f32,
        ldb: *mut integer,
        y: *mut f32,
        ldy: *mut integer,
        berr_out: *mut f32,
        n_norms: *mut integer,
        errs_n: *mut f32,
        errs_c: *mut f32,
        res: *mut f32,
        ayb: *mut f32,
        dy: *mut f32,
        y_tail: *mut f32,
        rcond: *mut f32,
        ithresh: *mut integer,
        rthresh: *mut f32,
        dz_ub: *mut f32,
        ignore_cwise: *mut logical,
        info: *mut integer,
    );
    pub fn slags2_(
        upper: *mut logical,
        a1: *mut f32,
        a2: *mut f32,
        a3: *mut f32,
        b1: *mut f32,
        b2: *mut f32,
        b3: *mut f32,
        csu: *mut f32,
        snu: *mut f32,
        csv: *mut f32,
        snv: *mut f32,
        csq: *mut f32,
        snq: *mut f32,
    );
    pub fn slagtf_(
        n: *mut integer,
        a: *mut f32,
        lambda: *mut f32,
        b: *mut f32,
        c: *mut f32,
        tol: *mut f32,
        d: *mut f32,
        in_: *mut integer,
        info: *mut integer,
    );
    pub fn slagtm_(
        trans: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        alpha: *mut f32,
        dl: *mut f32,
        d: *mut f32,
        du: *mut f32,
        x: *mut f32,
        ldx: *mut integer,
        beta: *mut f32,
        b: *mut f32,
        ldb: *mut integer,
    );
    pub fn slagts_(
        job: *mut integer,
        n: *mut integer,
        a: *mut f32,
        b: *mut f32,
        c: *mut f32,
        d: *mut f32,
        in_: *mut integer,
        y: *mut f32,
        tol: *mut f32,
        info: *mut integer,
    );
    pub fn slagv2_(
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        alphar: *mut f32,
        alphai: *mut f32,
        beta: *mut f32,
        csl: *mut f32,
        snl: *mut f32,
        csr: *mut f32,
        snr: *mut f32,
    );
    pub fn slahqr_(
        wantt: *mut logical,
        wantz: *mut logical,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        h: *mut f32,
        ldh: *mut integer,
        wr: *mut f32,
        wi: *mut f32,
        iloz: *mut integer,
        ihiz: *mut integer,
        z: *mut f32,
        ldz: *mut integer,
        info: *mut integer,
    );
    pub fn slahr2_(
        n: *mut integer,
        k: *mut integer,
        nb: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        tau: *mut f32,
        t: *mut f32,
        ldt: *mut integer,
        y: *mut f32,
        ldy: *mut integer,
    );
    pub fn slahrd_(
        n: *mut integer,
        k: *mut integer,
        nb: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        tau: *mut f32,
        t: *mut f32,
        ldt: *mut integer,
        y: *mut f32,
        ldy: *mut integer,
    );
    pub fn slaic1_(
        job: *mut integer,
        j: *mut integer,
        x: *mut f32,
        sest: *mut f32,
        w: *mut f32,
        gamma: *mut f32,
        sestpr: *mut f32,
        s: *mut f32,
        c__: *mut f32,
    );
    pub fn sla_lin_berr_(
        n: *mut integer,
        nz: *mut integer,
        nrhs: *mut integer,
        res: *mut f32,
        ayb: *mut f32,
        berr: *mut f32,
    );
    pub fn slaln2_(
        ltrans: *mut logical,
        na: *mut integer,
        nw: *mut integer,
        smin: *mut f32,
        ca: *mut f32,
        a: *mut f32,
        lda: *mut integer,
        d1: *mut f32,
        d2: *mut f32,
        b: *mut f32,
        ldb: *mut integer,
        wr: *mut f32,
        wi: *mut f32,
        x: *mut f32,
        ldx: *mut integer,
        scale: *mut f32,
        xnorm: *mut f32,
        info: *mut integer,
    );
    pub fn slals0_(
        icompq: *mut integer,
        nl: *mut integer,
        nr: *mut integer,
        sqre: *mut integer,
        nrhs: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        bx: *mut f32,
        ldbx: *mut integer,
        perm: *mut integer,
        givptr: *mut integer,
        givcol: *mut integer,
        ldgcol: *mut integer,
        givnum: *mut f32,
        ldgnum: *mut integer,
        poles: *mut f32,
        difl: *mut f32,
        difr: *mut f32,
        z: *mut f32,
        k: *mut integer,
        c: *mut f32,
        s: *mut f32,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn slalsa_(
        icompq: *mut integer,
        smlsiz: *mut integer,
        n: *mut integer,
        nrhs: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        bx: *mut f32,
        ldbx: *mut integer,
        u: *mut f32,
        ldu: *mut integer,
        vt: *mut f32,
        k: *mut integer,
        difl: *mut f32,
        difr: *mut f32,
        z: *mut f32,
        poles: *mut f32,
        givptr: *mut integer,
        givcol: *mut integer,
        ldgcol: *mut integer,
        perm: *mut integer,
        givnum: *mut f32,
        c: *mut f32,
        s: *mut f32,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn slalsd_(
        uplo: *mut c_char,
        smlsiz: *mut integer,
        n: *mut integer,
        nrhs: *mut integer,
        d: *mut f32,
        e: *mut f32,
        b: *mut f32,
        ldb: *mut integer,
        rcond: *mut f32,
        rank: *mut integer,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn slamrg_(
        n1: *mut integer,
        n2: *mut integer,
        a: *mut f32,
        strd1: *mut integer,
        strd2: *mut integer,
        index: *mut integer,
    );
    pub fn slamswlq_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        mb: *mut integer,
        nb: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        t: *mut f32,
        ldt: *mut integer,
        c: *mut f32,
        ldc: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn slamtsqr_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        mb: *mut integer,
        nb: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        t: *mut f32,
        ldt: *mut integer,
        c: *mut f32,
        ldc: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn slaneg_(
        n: *mut integer,
        d: *mut f32,
        lld: *mut f32,
        sigma: *mut f32,
        pivmin: *mut f32,
        r__: *mut integer,
    ) -> integer;
    pub fn slanv2_(
        a: *mut f32,
        b: *mut f32,
        c: *mut f32,
        d: *mut f32,
        rt1r: *mut f32,
        rt1i: *mut f32,
        rt2r: *mut f32,
        rt2i: *mut f32,
        cs: *mut f32,
        sn: *mut f32,
    );
    pub fn slaorhr_col_getrfnp2_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        d: *mut f32,
        info: *mut integer,
    );
    pub fn slaorhr_col_getrfnp_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        d: *mut f32,
        info: *mut integer,
    );
    pub fn slapll_(
        n: *mut integer,
        x: *mut f32,
        incx: *mut integer,
        y: *mut f32,
        incy: *mut integer,
        ssmin: *mut f32,
    );
    pub fn slapmr_(
        forwrd: *mut logical,
        m: *mut integer,
        n: *mut integer,
        x: *mut f32,
        ldx: *mut integer,
        k: *mut integer,
    );
    pub fn slapmt_(
        forwrd: *mut logical,
        m: *mut integer,
        n: *mut integer,
        x: *mut f32,
        ldx: *mut integer,
        k: *mut integer,
    );
    pub fn sla_porfsx_extended_(
        prec_type: *mut integer,
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        af: *mut f32,
        ldaf: *mut integer,
        colequ: *mut logical,
        c: *mut f32,
        b: *mut f32,
        ldb: *mut integer,
        y: *mut f32,
        ldy: *mut integer,
        berr_out: *mut f32,
        n_norms: *mut integer,
        err_bnds_norm: *mut f32,
        err_bnds_comp: *mut f32,
        res: *mut f32,
        ayb: *mut f32,
        dy: *mut f32,
        y_tail: *mut f32,
        rcond: *mut f32,
        ithresh: *mut integer,
        rthresh: *mut f32,
        dz_ub: *mut f32,
        ignore_cwise: *mut logical,
        info: *mut integer,
    );
    pub fn slaqgb_(
        m: *mut integer,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        ab: *mut f32,
        ldab: *mut integer,
        r: *mut f32,
        c: *mut f32,
        rowcnd: *mut f32,
        colcnd: *mut f32,
        amax: *mut f32,
        equed: *mut c_char,
    );
    pub fn slaqge_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        r: *mut f32,
        c: *mut f32,
        rowcnd: *mut f32,
        colcnd: *mut f32,
        amax: *mut f32,
        equed: *mut c_char,
    );
    pub fn slaqp2_(
        m: *mut integer,
        n: *mut integer,
        offset: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        jpvt: *mut integer,
        tau: *mut f32,
        vn1: *mut f32,
        vn2: *mut f32,
        work: *mut f32,
    );
    pub fn slaqps_(
        m: *mut integer,
        n: *mut integer,
        offset: *mut integer,
        nb: *mut integer,
        kb: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        jpvt: *mut integer,
        tau: *mut f32,
        vn1: *mut f32,
        vn2: *mut f32,
        auxv: *mut f32,
        f: *mut f32,
        ldf: *mut integer,
    );
    pub fn slaqr0_(
        wantt: *mut logical,
        wantz: *mut logical,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        h: *mut f32,
        ldh: *mut integer,
        wr: *mut f32,
        wi: *mut f32,
        iloz: *mut integer,
        ihiz: *mut integer,
        z: *mut f32,
        ldz: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn slaqr1_(
        n: *mut integer,
        h: *mut f32,
        ldh: *mut integer,
        sr1: *mut f32,
        si1: *mut f32,
        sr2: *mut f32,
        si2: *mut f32,
        v: *mut f32,
    );
    pub fn slaqr2_(
        wantt: *mut logical,
        wantz: *mut logical,
        n: *mut integer,
        ktop: *mut integer,
        kbot: *mut integer,
        nw: *mut integer,
        h: *mut f32,
        ldh: *mut integer,
        iloz: *mut integer,
        ihiz: *mut integer,
        z: *mut f32,
        ldz: *mut integer,
        ns: *mut integer,
        nd: *mut integer,
        sr: *mut f32,
        si: *mut f32,
        v: *mut f32,
        ldv: *mut integer,
        nh: *mut integer,
        t: *mut f32,
        ldt: *mut integer,
        nv: *mut integer,
        wv: *mut f32,
        ldwv: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
    );
    pub fn slaqr3_(
        wantt: *mut logical,
        wantz: *mut logical,
        n: *mut integer,
        ktop: *mut integer,
        kbot: *mut integer,
        nw: *mut integer,
        h: *mut f32,
        ldh: *mut integer,
        iloz: *mut integer,
        ihiz: *mut integer,
        z: *mut f32,
        ldz: *mut integer,
        ns: *mut integer,
        nd: *mut integer,
        sr: *mut f32,
        si: *mut f32,
        v: *mut f32,
        ldv: *mut integer,
        nh: *mut integer,
        t: *mut f32,
        ldt: *mut integer,
        nv: *mut integer,
        wv: *mut f32,
        ldwv: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
    );
    pub fn slaqr4_(
        wantt: *mut logical,
        wantz: *mut logical,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        h: *mut f32,
        ldh: *mut integer,
        wr: *mut f32,
        wi: *mut f32,
        iloz: *mut integer,
        ihiz: *mut integer,
        z: *mut f32,
        ldz: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn slaqr5_(
        wantt: *mut logical,
        wantz: *mut logical,
        kacc22: *mut integer,
        n: *mut integer,
        ktop: *mut integer,
        kbot: *mut integer,
        nshfts: *mut integer,
        sr: *mut f32,
        si: *mut f32,
        h: *mut f32,
        ldh: *mut integer,
        iloz: *mut integer,
        ihiz: *mut integer,
        z: *mut f32,
        ldz: *mut integer,
        v: *mut f32,
        ldv: *mut integer,
        u: *mut f32,
        ldu: *mut integer,
        nv: *mut integer,
        wv: *mut f32,
        ldwv: *mut integer,
        nh: *mut integer,
        wh: *mut f32,
        ldwh: *mut integer,
    );
    pub fn slaqsb_(
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut f32,
        ldab: *mut integer,
        s: *mut f32,
        scond: *mut f32,
        amax: *mut f32,
        equed: *mut c_char,
    );
    pub fn slaqsp_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut f32,
        s: *mut f32,
        scond: *mut f32,
        amax: *mut f32,
        equed: *mut c_char,
    );
    pub fn slaqsy_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        s: *mut f32,
        scond: *mut f32,
        amax: *mut f32,
        equed: *mut c_char,
    );
    pub fn slaqtr_(
        ltran: *mut logical,
        lfloat: *mut logical,
        n: *mut integer,
        t: *mut f32,
        ldt: *mut integer,
        b: *mut f32,
        w: *mut f32,
        scale: *mut f32,
        x: *mut f32,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn slar1v_(
        n: *mut integer,
        b1: *mut integer,
        bn: *mut integer,
        lambda: *mut f32,
        d: *mut f32,
        l: *mut f32,
        ld: *mut f32,
        lld: *mut f32,
        pivmin: *mut f32,
        gaptol: *mut f32,
        z: *mut f32,
        wantnc: *mut logical,
        negcnt: *mut integer,
        ztz: *mut f32,
        mingma: *mut f32,
        r: *mut integer,
        isuppz: *mut integer,
        nrminv: *mut f32,
        resid: *mut f32,
        rqcorr: *mut f32,
        work: *mut f32,
    );
    pub fn slar2v_(
        n: *mut integer,
        x: *mut f32,
        y: *mut f32,
        z: *mut f32,
        incx: *mut integer,
        c: *mut f32,
        s: *mut f32,
        incc: *mut integer,
    );
    pub fn slarfb_(
        side: *mut c_char,
        trans: *mut c_char,
        direct: *mut c_char,
        storev: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        v: *mut f32,
        ldv: *mut integer,
        t: *mut f32,
        ldt: *mut integer,
        c: *mut f32,
        ldc: *mut integer,
        work: *mut f32,
        ldwork: *mut integer,
    );
    pub fn slarf_(
        side: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        v: *mut f32,
        incv: *mut integer,
        tau: *mut f32,
        c: *mut f32,
        ldc: *mut integer,
        work: *mut f32,
    );
    pub fn slarfg_(
        n: *mut integer,
        alpha: *mut f32,
        x: *mut f32,
        incx: *mut integer,
        tau: *mut f32,
    );
    pub fn slarfgp_(
        n: *mut integer,
        alpha: *mut f32,
        x: *mut f32,
        incx: *mut integer,
        tau: *mut f32,
    );
    pub fn slarft_(
        direct: *mut c_char,
        storev: *mut c_char,
        n: *mut integer,
        k: *mut integer,
        v: *mut f32,
        ldv: *mut integer,
        tau: *mut f32,
        t: *mut f32,
        ldt: *mut integer,
    );
    pub fn slarfx_(
        side: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        v: *mut f32,
        tau: *mut f32,
        c: *mut f32,
        ldc: *mut integer,
        work: *mut f32,
    );
    pub fn slarfy_(
        uplo: *mut c_char,
        n: *mut integer,
        v: *mut f32,
        incv: *mut integer,
        tau: *mut f32,
        c: *mut f32,
        ldc: *mut integer,
        work: *mut f32,
    );
    pub fn slargv_(
        n: *mut integer,
        x: *mut f32,
        incx: *mut integer,
        y: *mut f32,
        incy: *mut integer,
        c: *mut f32,
        incc: *mut integer,
    );
    pub fn slarnv_(idist: *mut integer, iseed: *mut integer, n: *mut integer, x: *mut f32);
    pub fn slarra_(
        n: *mut integer,
        d: *mut f32,
        e: *mut f32,
        e2: *mut f32,
        spltol: *mut f32,
        tnrm: *mut f32,
        nsplit: *mut integer,
        isplit: *mut integer,
        info: *mut integer,
    );
    pub fn slarrb_(
        n: *mut integer,
        d: *mut f32,
        lld: *mut f32,
        ifirst: *mut integer,
        ilast: *mut integer,
        rtol1: *mut f32,
        rtol2: *mut f32,
        offset: *mut integer,
        w: *mut f32,
        wgap: *mut f32,
        werr: *mut f32,
        work: *mut f32,
        iwork: *mut integer,
        pivmin: *mut f32,
        spdiam: *mut f32,
        twist: *mut integer,
        info: *mut integer,
    );
    pub fn slarrc_(
        jobt: *mut c_char,
        n: *mut integer,
        vl: *mut f32,
        vu: *mut f32,
        d: *mut f32,
        e: *mut f32,
        pivmin: *mut f32,
        eigcnt: *mut integer,
        lcnt: *mut integer,
        rcnt: *mut integer,
        info: *mut integer,
    );
    pub fn slarrd_(
        range: *mut c_char,
        order: *mut c_char,
        n: *mut integer,
        vl: *mut f32,
        vu: *mut f32,
        il: *mut integer,
        iu: *mut integer,
        gers: *mut f32,
        reltol: *mut f32,
        d: *mut f32,
        e: *mut f32,
        e2: *mut f32,
        pivmin: *mut f32,
        nsplit: *mut integer,
        isplit: *mut integer,
        m: *mut integer,
        w: *mut f32,
        werr: *mut f32,
        wl: *mut f32,
        wu: *mut f32,
        iblock: *mut integer,
        indexw: *mut integer,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn slarre_(
        range: *mut c_char,
        n: *mut integer,
        vl: *mut f32,
        vu: *mut f32,
        il: *mut integer,
        iu: *mut integer,
        d: *mut f32,
        e: *mut f32,
        e2: *mut f32,
        rtol1: *mut f32,
        rtol2: *mut f32,
        spltol: *mut f32,
        nsplit: *mut integer,
        isplit: *mut integer,
        m: *mut integer,
        w: *mut f32,
        werr: *mut f32,
        wgap: *mut f32,
        iblock: *mut integer,
        indexw: *mut integer,
        gers: *mut f32,
        pivmin: *mut f32,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn slarrf_(
        n: *mut integer,
        d: *mut f32,
        l: *mut f32,
        ld: *mut f32,
        clstrt: *mut integer,
        clend: *mut integer,
        w: *mut f32,
        wgap: *mut f32,
        werr: *mut f32,
        spdiam: *mut f32,
        clgapl: *mut f32,
        clgapr: *mut f32,
        pivmin: *mut f32,
        sigma: *mut f32,
        dplus: *mut f32,
        lplus: *mut f32,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn slarrj_(
        n: *mut integer,
        d: *mut f32,
        e2: *mut f32,
        ifirst: *mut integer,
        ilast: *mut integer,
        rtol: *mut f32,
        offset: *mut integer,
        w: *mut f32,
        werr: *mut f32,
        work: *mut f32,
        iwork: *mut integer,
        pivmin: *mut f32,
        spdiam: *mut f32,
        info: *mut integer,
    );
    pub fn slarrk_(
        n: *mut integer,
        iw: *mut integer,
        gl: *mut f32,
        gu: *mut f32,
        d: *mut f32,
        e2: *mut f32,
        pivmin: *mut f32,
        reltol: *mut f32,
        w: *mut f32,
        werr: *mut f32,
        info: *mut integer,
    );
    pub fn slarrr_(n: *mut integer, d: *mut f32, e: *mut f32, info: *mut integer);
    pub fn slarrv_(
        n: *mut integer,
        vl: *mut f32,
        vu: *mut f32,
        d: *mut f32,
        l: *mut f32,
        pivmin: *mut f32,
        isplit: *mut integer,
        m: *mut integer,
        dol: *mut integer,
        dou: *mut integer,
        minrgp: *mut f32,
        rtol1: *mut f32,
        rtol2: *mut f32,
        w: *mut f32,
        werr: *mut f32,
        wgap: *mut f32,
        iblock: *mut integer,
        indexw: *mut integer,
        gers: *mut f32,
        z: *mut f32,
        ldz: *mut integer,
        isuppz: *mut integer,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn slarscl2_(m: *mut integer, n: *mut integer, d: *mut f32, x: *mut f32, ldx: *mut integer);
    pub fn slartg_(f: *mut f32, g: *mut f32, cs: *mut f32, sn: *mut f32, r__: *mut f32);
    pub fn slartgp_(f: *mut f32, g: *mut f32, cs: *mut f32, sn: *mut f32, r__: *mut f32);
    pub fn slartgs_(x: *mut f32, y: *mut f32, sigma: *mut f32, cs: *mut f32, sn: *mut f32);
    pub fn slartv_(
        n: *mut integer,
        x: *mut f32,
        incx: *mut integer,
        y: *mut f32,
        incy: *mut integer,
        c: *mut f32,
        s: *mut f32,
        incc: *mut integer,
    );
    pub fn slaruv_(iseed: *mut integer, n: *mut integer, x: *mut f32);
    pub fn slarzb_(
        side: *mut c_char,
        trans: *mut c_char,
        direct: *mut c_char,
        storev: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        l: *mut integer,
        v: *mut f32,
        ldv: *mut integer,
        t: *mut f32,
        ldt: *mut integer,
        c: *mut f32,
        ldc: *mut integer,
        work: *mut f32,
        ldwork: *mut integer,
    );
    pub fn slarz_(
        side: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        l: *mut integer,
        v: *mut f32,
        incv: *mut integer,
        tau: *mut f32,
        c: *mut f32,
        ldc: *mut integer,
        work: *mut f32,
    );
    pub fn slarzt_(
        direct: *mut c_char,
        storev: *mut c_char,
        n: *mut integer,
        k: *mut integer,
        v: *mut f32,
        ldv: *mut integer,
        tau: *mut f32,
        t: *mut f32,
        ldt: *mut integer,
    );
    pub fn slas2_(f: *mut f32, g: *mut f32, h: *mut f32, ssmin: *mut f32, ssmax: *mut f32);
    pub fn slascl2_(m: *mut integer, n: *mut integer, d: *mut f32, x: *mut f32, ldx: *mut integer);
    pub fn slascl_(
        type_: *mut c_char,
        kl: *mut integer,
        ku: *mut integer,
        cfrom: *mut f32,
        cto: *mut f32,
        m: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn slasd0_(
        n: *mut integer,
        sqre: *mut integer,
        d: *mut f32,
        e: *mut f32,
        u: *mut f32,
        ldu: *mut integer,
        vt: *mut f32,
        ldvt: *mut integer,
        smlsiz: *mut integer,
        iwork: *mut integer,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn slasd1_(
        nl: *mut integer,
        nr: *mut integer,
        sqre: *mut integer,
        d: *mut f32,
        alpha: *mut f32,
        beta: *mut f32,
        u: *mut f32,
        ldu: *mut integer,
        vt: *mut f32,
        ldvt: *mut integer,
        idxq: *mut integer,
        iwork: *mut integer,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn slasd2_(
        nl: *mut integer,
        nr: *mut integer,
        sqre: *mut integer,
        k: *mut integer,
        d: *mut f32,
        z: *mut f32,
        alpha: *mut f32,
        beta: *mut f32,
        u: *mut f32,
        ldu: *mut integer,
        vt: *mut f32,
        ldvt: *mut integer,
        dsigma: *mut f32,
        u2: *mut f32,
        ldu2: *mut integer,
        vt2: *mut f32,
        ldvt2: *mut integer,
        idxp: *mut integer,
        idx: *mut integer,
        idxc: *mut integer,
        idxq: *mut integer,
        coltyp: *mut integer,
        info: *mut integer,
    );
    pub fn slasd3_(
        nl: *mut integer,
        nr: *mut integer,
        sqre: *mut integer,
        k: *mut integer,
        d: *mut f32,
        q: *mut f32,
        ldq: *mut integer,
        dsigma: *mut f32,
        u: *mut f32,
        ldu: *mut integer,
        u2: *mut f32,
        ldu2: *mut integer,
        vt: *mut f32,
        ldvt: *mut integer,
        vt2: *mut f32,
        ldvt2: *mut integer,
        idxc: *mut integer,
        ctot: *mut integer,
        z: *mut f32,
        info: *mut integer,
    );
    pub fn slasd4_(
        n: *mut integer,
        i: *mut integer,
        d: *mut f32,
        z: *mut f32,
        delta: *mut f32,
        rho: *mut f32,
        sigma: *mut f32,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn slasd5_(
        i: *mut integer,
        d: *mut f32,
        z: *mut f32,
        delta: *mut f32,
        rho: *mut f32,
        dsigma: *mut f32,
        work: *mut f32,
    );
    pub fn slasd6_(
        icompq: *mut integer,
        nl: *mut integer,
        nr: *mut integer,
        sqre: *mut integer,
        d: *mut f32,
        vf: *mut f32,
        vl: *mut f32,
        alpha: *mut f32,
        beta: *mut f32,
        idxq: *mut integer,
        perm: *mut integer,
        givptr: *mut integer,
        givcol: *mut integer,
        ldgcol: *mut integer,
        givnum: *mut f32,
        ldgnum: *mut integer,
        poles: *mut f32,
        difl: *mut f32,
        difr: *mut f32,
        z: *mut f32,
        k: *mut integer,
        c: *mut f32,
        s: *mut f32,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn slasd7_(
        icompq: *mut integer,
        nl: *mut integer,
        nr: *mut integer,
        sqre: *mut integer,
        k: *mut integer,
        d: *mut f32,
        z: *mut f32,
        zw: *mut f32,
        vf: *mut f32,
        vfw: *mut f32,
        vl: *mut f32,
        vlw: *mut f32,
        alpha: *mut f32,
        beta: *mut f32,
        dsigma: *mut f32,
        idx: *mut integer,
        idxp: *mut integer,
        idxq: *mut integer,
        perm: *mut integer,
        givptr: *mut integer,
        givcol: *mut integer,
        ldgcol: *mut integer,
        givnum: *mut f32,
        ldgnum: *mut integer,
        c: *mut f32,
        s: *mut f32,
        info: *mut integer,
    );
    pub fn slasd8_(
        icompq: *mut integer,
        k: *mut integer,
        d: *mut f32,
        z: *mut f32,
        vf: *mut f32,
        vl: *mut f32,
        difl: *mut f32,
        difr: *mut f32,
        lddifr: *mut integer,
        dsigma: *mut f32,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn slasda_(
        icompq: *mut integer,
        smlsiz: *mut integer,
        n: *mut integer,
        sqre: *mut integer,
        d: *mut f32,
        e: *mut f32,
        u: *mut f32,
        ldu: *mut integer,
        vt: *mut f32,
        k: *mut integer,
        difl: *mut f32,
        difr: *mut f32,
        z: *mut f32,
        poles: *mut f32,
        givptr: *mut integer,
        givcol: *mut integer,
        ldgcol: *mut integer,
        perm: *mut integer,
        givnum: *mut f32,
        c: *mut f32,
        s: *mut f32,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn slasdq_(
        uplo: *mut c_char,
        sqre: *mut integer,
        n: *mut integer,
        ncvt: *mut integer,
        nru: *mut integer,
        ncc: *mut integer,
        d: *mut f32,
        e: *mut f32,
        vt: *mut f32,
        ldvt: *mut integer,
        u: *mut f32,
        ldu: *mut integer,
        c: *mut f32,
        ldc: *mut integer,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn slasdt_(
        n: *mut integer,
        lvl: *mut integer,
        nd: *mut integer,
        inode: *mut integer,
        ndiml: *mut integer,
        ndimr: *mut integer,
        msub: *mut integer,
    );
    pub fn slaset_(
        uplo: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        alpha: *mut f32,
        beta: *mut f32,
        a: *mut f32,
        lda: *mut integer,
    );
    pub fn slasq1_(n: *mut integer, d: *mut f32, e: *mut f32, work: *mut f32, info: *mut integer);
    pub fn slasq2_(n: *mut integer, z: *mut f32, info: *mut integer);
    pub fn slasq3_(
        i0: *mut integer,
        n0: *mut integer,
        z: *mut f32,
        pp: *mut integer,
        dmin: *mut f32,
        sigma: *mut f32,
        desig: *mut f32,
        qmax: *mut f32,
        nfail: *mut integer,
        iter: *mut integer,
        ndiv: *mut integer,
        ieee: *mut logical,
        ttype: *mut integer,
        dmin1: *mut f32,
        dmin2: *mut f32,
        dn: *mut f32,
        dn1: *mut f32,
        dn2: *mut f32,
        g: *mut f32,
        tau: *mut f32,
    );
    pub fn slasq4_(
        i0: *mut integer,
        n0: *mut integer,
        z: *mut f32,
        pp: *mut integer,
        n0in: *mut integer,
        dmin: *mut f32,
        dmin1: *mut f32,
        dmin2: *mut f32,
        dn: *mut f32,
        dn1: *mut f32,
        dn2: *mut f32,
        tau: *mut f32,
        ttype: *mut integer,
        g: *mut f32,
    );
    pub fn slasq5_(
        i0: *mut integer,
        n0: *mut integer,
        z: *mut f32,
        pp: *mut integer,
        tau: *mut f32,
        sigma: *mut f32,
        dmin: *mut f32,
        dmin1: *mut f32,
        dmin2: *mut f32,
        dn: *mut f32,
        dnm1: *mut f32,
        dnm2: *mut f32,
        ieee: *mut logical,
        eps: *mut f32,
    );
    pub fn slasq6_(
        i0: *mut integer,
        n0: *mut integer,
        z: *mut f32,
        pp: *mut integer,
        dmin: *mut f32,
        dmin1: *mut f32,
        dmin2: *mut f32,
        dn: *mut f32,
        dnm1: *mut f32,
        dnm2: *mut f32,
    );
    pub fn slasr_(
        side: *mut c_char,
        pivot: *mut c_char,
        direct: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        c: *mut f32,
        s: *mut f32,
        a: *mut f32,
        lda: *mut integer,
    );
    pub fn slasrt_(id: *mut c_char, n: *mut integer, d: *mut f32, info: *mut integer);
    pub fn slassq_(
        n: *mut integer,
        x: *mut f32,
        incx: *mut integer,
        scale: *mut f32,
        sumsq: *mut f32,
    );
    pub fn slasv2_(
        f: *mut f32,
        g: *mut f32,
        h: *mut f32,
        ssmin: *mut f32,
        ssmax: *mut f32,
        snr: *mut f32,
        csr: *mut f32,
        snl: *mut f32,
        csl: *mut f32,
    );
    pub fn slaswlq_(
        m: *mut integer,
        n: *mut integer,
        mb: *mut integer,
        nb: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        t: *mut f32,
        ldt: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn slaswp_(
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        k1: *mut integer,
        k2: *mut integer,
        ipiv: *mut integer,
        incx: *mut integer,
    );
    pub fn slasy2_(
        ltranl: *mut logical,
        ltranr: *mut logical,
        isgn: *mut integer,
        n1: *mut integer,
        n2: *mut integer,
        tl: *mut f32,
        ldtl: *mut integer,
        tr: *mut f32,
        ldtr: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        scale: *mut f32,
        x: *mut f32,
        ldx: *mut integer,
        xnorm: *mut f32,
        info: *mut integer,
    );
    pub fn sla_syamv_(
        uplo: *mut integer,
        n: *mut integer,
        alpha: *mut f32,
        a: *mut f32,
        lda: *mut integer,
        x: *mut f32,
        incx: *mut integer,
        beta: *mut f32,
        y: *mut f32,
        incy: *mut integer,
    );
    pub fn slasyf_aa_(
        uplo: *mut c_char,
        j1: *mut integer,
        m: *mut integer,
        nb: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        ipiv: *mut integer,
        h: *mut f32,
        ldh: *mut integer,
        work: *mut f32,
    );
    pub fn slasyf_(
        uplo: *mut c_char,
        n: *mut integer,
        nb: *mut integer,
        kb: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        ipiv: *mut integer,
        w: *mut f32,
        ldw: *mut integer,
        info: *mut integer,
    );
    pub fn slasyf_rk_(
        uplo: *mut c_char,
        n: *mut integer,
        nb: *mut integer,
        kb: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        e: *mut f32,
        ipiv: *mut integer,
        w: *mut f32,
        ldw: *mut integer,
        info: *mut integer,
    );
    pub fn slasyf_rook_(
        uplo: *mut c_char,
        n: *mut integer,
        nb: *mut integer,
        kb: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        ipiv: *mut integer,
        w: *mut f32,
        ldw: *mut integer,
        info: *mut integer,
    );
    pub fn sla_syrfsx_extended_(
        prec_type: *mut integer,
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        af: *mut f32,
        ldaf: *mut integer,
        ipiv: *mut integer,
        colequ: *mut logical,
        c: *mut f32,
        b: *mut f32,
        ldb: *mut integer,
        y: *mut f32,
        ldy: *mut integer,
        berr_out: *mut f32,
        n_norms: *mut integer,
        err_bnds_norm: *mut f32,
        err_bnds_comp: *mut f32,
        res: *mut f32,
        ayb: *mut f32,
        dy: *mut f32,
        y_tail: *mut f32,
        rcond: *mut f32,
        ithresh: *mut integer,
        rthresh: *mut f32,
        dz_ub: *mut f32,
        ignore_cwise: *mut logical,
        info: *mut integer,
    );
    pub fn slatbs_(
        uplo: *mut c_char,
        trans: *mut c_char,
        diag: *mut c_char,
        normin: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut f32,
        ldab: *mut integer,
        x: *mut f32,
        scale: *mut f32,
        cnorm: *mut f32,
        info: *mut integer,
    );
    pub fn slatdf_(
        ijob: *mut integer,
        n: *mut integer,
        z: *mut f32,
        ldz: *mut integer,
        rhs: *mut f32,
        rdsum: *mut f32,
        rdscal: *mut f32,
        ipiv: *mut integer,
        jpiv: *mut integer,
    );
    pub fn slatps_(
        uplo: *mut c_char,
        trans: *mut c_char,
        diag: *mut c_char,
        normin: *mut c_char,
        n: *mut integer,
        ap: *mut f32,
        x: *mut f32,
        scale: *mut f32,
        cnorm: *mut f32,
        info: *mut integer,
    );
    pub fn slatrd_(
        uplo: *mut c_char,
        n: *mut integer,
        nb: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        e: *mut f32,
        tau: *mut f32,
        w: *mut f32,
        ldw: *mut integer,
    );
    pub fn slatrs_(
        uplo: *mut c_char,
        trans: *mut c_char,
        diag: *mut c_char,
        normin: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        x: *mut f32,
        scale: *mut f32,
        cnorm: *mut f32,
        info: *mut integer,
    );
    pub fn slatrz_(
        m: *mut integer,
        n: *mut integer,
        l: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        tau: *mut f32,
        work: *mut f32,
    );
    pub fn slatsqr_(
        m: *mut integer,
        n: *mut integer,
        mb: *mut integer,
        nb: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        t: *mut f32,
        ldt: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn slatzm_(
        side: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        v: *mut f32,
        incv: *mut integer,
        tau: *mut f32,
        c1: *mut f32,
        c2: *mut f32,
        ldc: *mut integer,
        work: *mut f32,
    );
    pub fn slauu2_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn slauum_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn sla_wwaddw_(n: *mut integer, x: *mut f32, y: *mut f32, w: *mut f32);
    pub fn sopmtr_(
        side: *mut c_char,
        uplo: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        ap: *mut f32,
        tau: *mut f32,
        c: *mut f32,
        ldc: *mut integer,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn sorbdb1_(
        m: *mut integer,
        p: *mut integer,
        q: *mut integer,
        x11: *mut f32,
        ldx11: *mut integer,
        x21: *mut f32,
        ldx21: *mut integer,
        theta: *mut f32,
        phi: *mut f32,
        taup1: *mut f32,
        taup2: *mut f32,
        tauq1: *mut f32,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sorbdb2_(
        m: *mut integer,
        p: *mut integer,
        q: *mut integer,
        x11: *mut f32,
        ldx11: *mut integer,
        x21: *mut f32,
        ldx21: *mut integer,
        theta: *mut f32,
        phi: *mut f32,
        taup1: *mut f32,
        taup2: *mut f32,
        tauq1: *mut f32,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sorbdb3_(
        m: *mut integer,
        p: *mut integer,
        q: *mut integer,
        x11: *mut f32,
        ldx11: *mut integer,
        x21: *mut f32,
        ldx21: *mut integer,
        theta: *mut f32,
        phi: *mut f32,
        taup1: *mut f32,
        taup2: *mut f32,
        tauq1: *mut f32,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sorbdb4_(
        m: *mut integer,
        p: *mut integer,
        q: *mut integer,
        x11: *mut f32,
        ldx11: *mut integer,
        x21: *mut f32,
        ldx21: *mut integer,
        theta: *mut f32,
        phi: *mut f32,
        taup1: *mut f32,
        taup2: *mut f32,
        tauq1: *mut f32,
        phantom: *mut f32,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sorbdb5_(
        m1: *mut integer,
        m2: *mut integer,
        n: *mut integer,
        x1: *mut f32,
        incx1: *mut integer,
        x2: *mut f32,
        incx2: *mut integer,
        q1: *mut f32,
        ldq1: *mut integer,
        q2: *mut f32,
        ldq2: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sorbdb6_(
        m1: *mut integer,
        m2: *mut integer,
        n: *mut integer,
        x1: *mut f32,
        incx1: *mut integer,
        x2: *mut f32,
        incx2: *mut integer,
        q1: *mut f32,
        ldq1: *mut integer,
        q2: *mut f32,
        ldq2: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sorbdb_(
        trans: *mut c_char,
        signs: *mut c_char,
        m: *mut integer,
        p: *mut integer,
        q: *mut integer,
        x11: *mut f32,
        ldx11: *mut integer,
        x12: *mut f32,
        ldx12: *mut integer,
        x21: *mut f32,
        ldx21: *mut integer,
        x22: *mut f32,
        ldx22: *mut integer,
        theta: *mut f32,
        phi: *mut f32,
        taup1: *mut f32,
        taup2: *mut f32,
        tauq1: *mut f32,
        tauq2: *mut f32,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sorg2l_(
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        tau: *mut f32,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn sorgl2_(
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        tau: *mut f32,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn sorg2r_(
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        tau: *mut f32,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn sorgbr_(
        vect: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        tau: *mut f32,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sorglq_(
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        tau: *mut f32,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sorgql_(
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        tau: *mut f32,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sorgqr_(
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        tau: *mut f32,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sorgr2_(
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        tau: *mut f32,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn sorgrq_(
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        tau: *mut f32,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sorgtr_(
        uplo: *mut c_char,
        m: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        tau: *mut f32,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sorgtsqr_(
        m: *mut integer,
        n: *mut integer,
        mb: *mut integer,
        nb: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        t: *mut f32,
        ldt: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sorhr_col_(
        m: *mut integer,
        n: *mut integer,
        nb: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        t: *mut f32,
        ldt: *mut integer,
        d: *mut f32,
        info: *mut integer,
    );
    pub fn sorm22_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        n1: *mut integer,
        n2: *mut integer,
        q: *mut f32,
        ldq: *mut integer,
        c: *mut f32,
        ldc: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sorm2l_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        tau: *mut f32,
        c: *mut f32,
        ldc: *mut integer,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn sorm2r_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        tau: *mut f32,
        c: *mut f32,
        ldc: *mut integer,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn sormbr_(
        vect: *mut c_char,
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        tau: *mut f32,
        c: *mut f32,
        ldc: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sorml2_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        tau: *mut f32,
        c: *mut f32,
        ldc: *mut integer,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn sormlq_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        tau: *mut f32,
        c: *mut f32,
        ldc: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sormql_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        tau: *mut f32,
        c: *mut f32,
        ldc: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sormqr_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        tau: *mut f32,
        c: *mut f32,
        ldc: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sormr2_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        tau: *mut f32,
        c: *mut f32,
        ldc: *mut integer,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn sormr3_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        l: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        tau: *mut f32,
        c: *mut f32,
        ldc: *mut integer,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn sormrq_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        tau: *mut f32,
        c: *mut f32,
        ldc: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sormrz_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        l: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        tau: *mut f32,
        c: *mut f32,
        ldc: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sormtr_(
        side: *mut c_char,
        uplo: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        tau: *mut f32,
        c: *mut f32,
        ldc: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn spbcon_(
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut f32,
        ldab: *mut integer,
        anorm: *mut f32,
        rcond: *mut f32,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn spbequ_(
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut f32,
        ldab: *mut integer,
        s: *mut f32,
        scond: *mut f32,
        amax: *mut f32,
        info: *mut integer,
    );
    pub fn spbrfs_(
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        nrhs: *mut integer,
        ab: *mut f32,
        ldab: *mut integer,
        afb: *mut f32,
        ldafb: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        x: *mut f32,
        ldx: *mut integer,
        ferr: *mut f32,
        berr: *mut f32,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn spbstf_(
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut f32,
        ldab: *mut integer,
        info: *mut integer,
    );
    pub fn spbsv_(
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        nrhs: *mut integer,
        ab: *mut f32,
        ldab: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn spbsvx_(
        fact: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        nrhs: *mut integer,
        ab: *mut f32,
        ldab: *mut integer,
        afb: *mut f32,
        ldafb: *mut integer,
        equed: *mut c_char,
        s: *mut f32,
        b: *mut f32,
        ldb: *mut integer,
        x: *mut f32,
        ldx: *mut integer,
        rcond: *mut f32,
        ferr: *mut f32,
        berr: *mut f32,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn spbtf2_(
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut f32,
        ldab: *mut integer,
        info: *mut integer,
    );
    pub fn spbtrf_(
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut f32,
        ldab: *mut integer,
        info: *mut integer,
    );
    pub fn spbtrs_(
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        nrhs: *mut integer,
        ab: *mut f32,
        ldab: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn spftrf_(
        transr: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        info: *mut integer,
    );
    pub fn spftri_(
        transr: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        info: *mut integer,
    );
    pub fn spftrs_(
        transr: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f32,
        b: *mut f32,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn spocon_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        anorm: *mut f32,
        rcond: *mut f32,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn spoequb_(
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        s: *mut f32,
        scond: *mut f32,
        amax: *mut f32,
        info: *mut integer,
    );
    pub fn spoequ_(
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        s: *mut f32,
        scond: *mut f32,
        amax: *mut f32,
        info: *mut integer,
    );
    pub fn sporfs_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        af: *mut f32,
        ldaf: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        x: *mut f32,
        ldx: *mut integer,
        ferr: *mut f32,
        berr: *mut f32,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn sporfsx_(
        uplo: *mut c_char,
        equed: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        af: *mut f32,
        ldaf: *mut integer,
        s: *mut f32,
        b: *mut f32,
        ldb: *mut integer,
        x: *mut f32,
        ldx: *mut integer,
        rcond: *mut f32,
        berr: *mut f32,
        n_err_bnds: *mut integer,
        err_bnds_norm: *mut f32,
        err_bnds_comp: *mut f32,
        nparams: *mut integer,
        params: *mut f32,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn sposv_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn sposvx_(
        fact: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        af: *mut f32,
        ldaf: *mut integer,
        equed: *mut c_char,
        s: *mut f32,
        b: *mut f32,
        ldb: *mut integer,
        x: *mut f32,
        ldx: *mut integer,
        rcond: *mut f32,
        ferr: *mut f32,
        berr: *mut f32,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn sposvxx_(
        fact: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        af: *mut f32,
        ldaf: *mut integer,
        equed: *mut c_char,
        s: *mut f32,
        b: *mut f32,
        ldb: *mut integer,
        x: *mut f32,
        ldx: *mut integer,
        rcond: *mut f32,
        rpvgrw: *mut f32,
        berr: *mut f32,
        n_err_bnds: *mut integer,
        err_bnds_norm: *mut f32,
        err_bnds_comp: *mut f32,
        nparams: *mut integer,
        params: *mut f32,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn spotf2_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn spotrf2_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn spotrf_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn spotri_(
        uplo: *mut c_char,
        n: *mut integer,
        buff_A: *mut f32,
        ldim_A: *mut integer,
        info: *mut integer,
    );
    pub fn spotrs_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn sppcon_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut f32,
        anorm: *mut f32,
        rcond: *mut f32,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn sppequ_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut f32,
        s: *mut f32,
        scond: *mut f32,
        amax: *mut f32,
        info: *mut integer,
    );
    pub fn spprfs_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut f32,
        afp: *mut f32,
        b: *mut f32,
        ldb: *mut integer,
        x: *mut f32,
        ldx: *mut integer,
        ferr: *mut f32,
        berr: *mut f32,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn sppsv_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut f32,
        b: *mut f32,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn sppsvx_(
        fact: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut f32,
        afp: *mut f32,
        equed: *mut c_char,
        s: *mut f32,
        b: *mut f32,
        ldb: *mut integer,
        x: *mut f32,
        ldx: *mut integer,
        rcond: *mut f32,
        ferr: *mut f32,
        berr: *mut f32,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn spptrf_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut f32,
        info: *mut integer,
    );
    pub fn spptri_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut f32,
        info: *mut integer,
    );
    pub fn spptrs_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut f32,
        b: *mut f32,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn spstf2_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        piv: *mut integer,
        rank: *mut integer,
        tol: *mut f32,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn spstrf_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        piv: *mut integer,
        rank: *mut integer,
        tol: *mut f32,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn sptcon_(
        n: *mut integer,
        d: *mut f32,
        e: *mut f32,
        anorm: *mut f32,
        rcond: *mut f32,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn spteqr_(
        compz: *mut c_char,
        n: *mut integer,
        d: *mut f32,
        e: *mut f32,
        z: *mut f32,
        ldz: *mut integer,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn sptrfs_(
        n: *mut integer,
        nrhs: *mut integer,
        d: *mut f32,
        e: *mut f32,
        df: *mut f32,
        ef: *mut f32,
        b: *mut f32,
        ldb: *mut integer,
        x: *mut f32,
        ldx: *mut integer,
        ferr: *mut f32,
        berr: *mut f32,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn sptsv_(
        n: *mut integer,
        nrhs: *mut integer,
        d: *mut f32,
        e: *mut f32,
        b: *mut f32,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn sptsvx_(
        fact: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        d: *mut f32,
        e: *mut f32,
        df: *mut f32,
        ef: *mut f32,
        b: *mut f32,
        ldb: *mut integer,
        x: *mut f32,
        ldx: *mut integer,
        rcond: *mut f32,
        ferr: *mut f32,
        berr: *mut f32,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn spttrf_(n: *mut integer, d: *mut f32, e: *mut f32, info: *mut integer);
    pub fn spttrs_(
        n: *mut integer,
        nrhs: *mut integer,
        d: *mut f32,
        e: *mut f32,
        b: *mut f32,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn sptts2_(
        n: *mut integer,
        nrhs: *mut integer,
        d: *mut f32,
        e: *mut f32,
        b: *mut f32,
        ldb: *mut integer,
    );
    pub fn srscl_(n: *mut integer, sa: *mut f32, sx: *mut f32, incx: *mut integer);
    pub fn ssb2st_kernels_(
        uplo: *mut c_char,
        wantz: *mut logical,
        ttype: *mut integer,
        st: *mut integer,
        ed: *mut integer,
        sweep: *mut integer,
        n: *mut integer,
        nb: *mut integer,
        ib: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        v: *mut f32,
        tau: *mut f32,
        ldvt: *mut integer,
        work: *mut f32,
    );
    pub fn ssbev_2stage_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut f32,
        ldab: *mut integer,
        w: *mut f32,
        z: *mut f32,
        ldz: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn ssbev_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut f32,
        ldab: *mut integer,
        w: *mut f32,
        z: *mut f32,
        ldz: *mut integer,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn ssbevd_2stage_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut f32,
        ldab: *mut integer,
        w: *mut f32,
        z: *mut f32,
        ldz: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn ssbevd_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut f32,
        ldab: *mut integer,
        w: *mut f32,
        z: *mut f32,
        ldz: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn ssbevx_2stage_(
        jobz: *mut c_char,
        range: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut f32,
        ldab: *mut integer,
        q: *mut f32,
        ldq: *mut integer,
        vl: *mut f32,
        vu: *mut f32,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f32,
        m: *mut integer,
        w: *mut f32,
        z: *mut f32,
        ldz: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        iwork: *mut integer,
        ifail: *mut integer,
        info: *mut integer,
    );
    pub fn ssbevx_(
        jobz: *mut c_char,
        range: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut f32,
        ldab: *mut integer,
        q: *mut f32,
        ldq: *mut integer,
        vl: *mut f32,
        vu: *mut f32,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f32,
        m: *mut integer,
        w: *mut f32,
        z: *mut f32,
        ldz: *mut integer,
        work: *mut f32,
        iwork: *mut integer,
        ifail: *mut integer,
        info: *mut integer,
    );
    pub fn ssbgst_(
        vect: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ka: *mut integer,
        kb: *mut integer,
        ab: *mut f32,
        ldab: *mut integer,
        bb: *mut f32,
        ldbb: *mut integer,
        x: *mut f32,
        ldx: *mut integer,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn ssbgv_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ka: *mut integer,
        kb: *mut integer,
        ab: *mut f32,
        ldab: *mut integer,
        bb: *mut f32,
        ldbb: *mut integer,
        w: *mut f32,
        z: *mut f32,
        ldz: *mut integer,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn ssbgvd_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ka: *mut integer,
        kb: *mut integer,
        ab: *mut f32,
        ldab: *mut integer,
        bb: *mut f32,
        ldbb: *mut integer,
        w: *mut f32,
        z: *mut f32,
        ldz: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn ssbgvx_(
        jobz: *mut c_char,
        range: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ka: *mut integer,
        kb: *mut integer,
        ab: *mut f32,
        ldab: *mut integer,
        bb: *mut f32,
        ldbb: *mut integer,
        q: *mut f32,
        ldq: *mut integer,
        vl: *mut f32,
        vu: *mut f32,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f32,
        m: *mut integer,
        w: *mut f32,
        z: *mut f32,
        ldz: *mut integer,
        work: *mut f32,
        iwork: *mut integer,
        ifail: *mut integer,
        info: *mut integer,
    );
    pub fn ssbtrd_(
        vect: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut f32,
        ldab: *mut integer,
        d: *mut f32,
        e: *mut f32,
        q: *mut f32,
        ldq: *mut integer,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn ssfrk_(
        transr: *mut c_char,
        uplo: *mut c_char,
        trans: *mut c_char,
        n: *mut integer,
        k: *mut integer,
        alpha: *mut f32,
        a: *mut f32,
        lda: *mut integer,
        beta: *mut f32,
        c__: *mut f32,
    );
    pub fn sspcon_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut f32,
        ipiv: *mut integer,
        anorm: *mut f32,
        rcond: *mut f32,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn sspev_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut f32,
        w: *mut f32,
        z: *mut f32,
        ldz: *mut integer,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn sspevd_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut f32,
        w: *mut f32,
        z: *mut f32,
        ldz: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn sspevx_(
        jobz: *mut c_char,
        range: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut f32,
        vl: *mut f32,
        vu: *mut f32,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f32,
        m: *mut integer,
        w: *mut f32,
        z: *mut f32,
        ldz: *mut integer,
        work: *mut f32,
        iwork: *mut integer,
        ifail: *mut integer,
        info: *mut integer,
    );
    pub fn sspgst_(
        itype: *mut integer,
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut f32,
        bp: *mut f32,
        info: *mut integer,
    );
    pub fn sspgvd_(
        itype: *mut integer,
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut f32,
        bp: *mut f32,
        w: *mut f32,
        z: *mut f32,
        ldz: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn sspgv_(
        itype: *mut integer,
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut f32,
        bp: *mut f32,
        w: *mut f32,
        z: *mut f32,
        ldz: *mut integer,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn sspgvx_(
        itype: *mut integer,
        jobz: *mut c_char,
        range: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut f32,
        bp: *mut f32,
        vl: *mut f32,
        vu: *mut f32,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f32,
        m: *mut integer,
        w: *mut f32,
        z: *mut f32,
        ldz: *mut integer,
        work: *mut f32,
        iwork: *mut integer,
        ifail: *mut integer,
        info: *mut integer,
    );
    pub fn ssprfs_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut f32,
        afp: *mut f32,
        ipiv: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        x: *mut f32,
        ldx: *mut integer,
        ferr: *mut f32,
        berr: *mut f32,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn sspsv_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut f32,
        ipiv: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn sspsvx_(
        fact: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut f32,
        afp: *mut f32,
        ipiv: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        x: *mut f32,
        ldx: *mut integer,
        rcond: *mut f32,
        ferr: *mut f32,
        berr: *mut f32,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn ssptrd_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut f32,
        d: *mut f32,
        e: *mut f32,
        tau: *mut f32,
        info: *mut integer,
    );
    pub fn ssptrf_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut f32,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn ssptri_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut f32,
        ipiv: *mut integer,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn ssptrs_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut f32,
        ipiv: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn sstebz_(
        range: *mut c_char,
        order: *mut c_char,
        n: *mut integer,
        vl: *mut f32,
        vu: *mut f32,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f32,
        d: *mut f32,
        e: *mut f32,
        m: *mut integer,
        nsplit: *mut integer,
        w: *mut f32,
        iblock: *mut integer,
        isplit: *mut integer,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn sstedc_(
        compz: *mut c_char,
        n: *mut integer,
        d: *mut f32,
        e: *mut f32,
        z: *mut f32,
        ldz: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn sstegr_(
        jobz: *mut c_char,
        range: *mut c_char,
        n: *mut integer,
        d: *mut f32,
        e: *mut f32,
        vl: *mut f32,
        vu: *mut f32,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f32,
        m: *mut integer,
        w: *mut f32,
        z: *mut f32,
        ldz: *mut integer,
        isuppz: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn sstein_(
        n: *mut integer,
        d: *mut f32,
        e: *mut f32,
        m: *mut integer,
        w: *mut f32,
        iblock: *mut integer,
        isplit: *mut integer,
        z: *mut f32,
        ldz: *mut integer,
        work: *mut f32,
        iwork: *mut integer,
        ifail: *mut integer,
        info: *mut integer,
    );
    pub fn sstemr_(
        jobz: *mut c_char,
        range: *mut c_char,
        n: *mut integer,
        d: *mut f32,
        e: *mut f32,
        vl: *mut f32,
        vu: *mut f32,
        il: *mut integer,
        iu: *mut integer,
        m: *mut integer,
        w: *mut f32,
        z: *mut f32,
        ldz: *mut integer,
        nzc: *mut integer,
        isuppz: *mut integer,
        tryrac: *mut logical,
        work: *mut f32,
        lwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn ssteqr_(
        compz: *mut c_char,
        n: *mut integer,
        d: *mut f32,
        e: *mut f32,
        z: *mut f32,
        ldz: *mut integer,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn ssterf_(n: *mut integer, d: *mut f32, e: *mut f32, info: *mut integer);
    pub fn sstev_(
        jobz: *mut c_char,
        n: *mut integer,
        d: *mut f32,
        e: *mut f32,
        z: *mut f32,
        ldz: *mut integer,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn sstevd_(
        jobz: *mut c_char,
        n: *mut integer,
        d: *mut f32,
        e: *mut f32,
        z: *mut f32,
        ldz: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn sstevr_(
        jobz: *mut c_char,
        range: *mut c_char,
        n: *mut integer,
        d: *mut f32,
        e: *mut f32,
        vl: *mut f32,
        vu: *mut f32,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f32,
        m: *mut integer,
        w: *mut f32,
        z: *mut f32,
        ldz: *mut integer,
        isuppz: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn sstevx_(
        jobz: *mut c_char,
        range: *mut c_char,
        n: *mut integer,
        d: *mut f32,
        e: *mut f32,
        vl: *mut f32,
        vu: *mut f32,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f32,
        m: *mut integer,
        w: *mut f32,
        z: *mut f32,
        ldz: *mut integer,
        work: *mut f32,
        iwork: *mut integer,
        ifail: *mut integer,
        info: *mut integer,
    );
    pub fn ssycon_3_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        e: *mut f32,
        ipiv: *mut integer,
        anorm: *mut f32,
        rcond: *mut f32,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn ssycon_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        ipiv: *mut integer,
        anorm: *mut f32,
        rcond: *mut f32,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn ssycon_rook_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        ipiv: *mut integer,
        anorm: *mut f32,
        rcond: *mut f32,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn ssyconv_(
        uplo: *mut c_char,
        way: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn ssyconvf_(
        uplo: *mut c_char,
        way: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        e: *mut f32,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn ssyconvf_rook_(
        uplo: *mut c_char,
        way: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        e: *mut f32,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn ssyequb_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        s: *mut f32,
        scond: *mut f32,
        amax: *mut f32,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn ssyev_2stage_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        w: *mut f32,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn ssyev_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        w: *mut f32,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn ssyevd_2stage_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        w: *mut f32,
        work: *mut f32,
        lwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn ssyevd_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        w: *mut f32,
        work: *mut f32,
        lwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn ssyevr_2stage_(
        jobz: *mut c_char,
        range: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        vl: *mut f32,
        vu: *mut f32,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f32,
        m: *mut integer,
        w: *mut f32,
        z: *mut f32,
        ldz: *mut integer,
        isuppz: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn ssyevr_(
        jobz: *mut c_char,
        range: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        vl: *mut f32,
        vu: *mut f32,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f32,
        m: *mut integer,
        w: *mut f32,
        z: *mut f32,
        ldz: *mut integer,
        isuppz: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn ssyevx_2stage_(
        jobz: *mut c_char,
        range: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        vl: *mut f32,
        vu: *mut f32,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f32,
        m: *mut integer,
        w: *mut f32,
        z: *mut f32,
        ldz: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        iwork: *mut integer,
        ifail: *mut integer,
        info: *mut integer,
    );
    pub fn ssyevx_(
        jobz: *mut c_char,
        range: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        vl: *mut f32,
        vu: *mut f32,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f32,
        m: *mut integer,
        w: *mut f32,
        z: *mut f32,
        ldz: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        iwork: *mut integer,
        ifail: *mut integer,
        info: *mut integer,
    );
    pub fn ssygs2_(
        itype: *mut integer,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn ssygst_(
        itype: *mut integer,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn ssygv_2stage_(
        itype: *mut integer,
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        w: *mut f32,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn ssygvd_(
        itype: *mut integer,
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        w: *mut f32,
        work: *mut f32,
        lwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn ssygv_(
        itype: *mut integer,
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        w: *mut f32,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn ssygvx_(
        itype: *mut integer,
        jobz: *mut c_char,
        range: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        vl: *mut f32,
        vu: *mut f32,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f32,
        m: *mut integer,
        w: *mut f32,
        z: *mut f32,
        ldz: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        iwork: *mut integer,
        ifail: *mut integer,
        info: *mut integer,
    );
    pub fn ssyrfs_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        af: *mut f32,
        ldaf: *mut integer,
        ipiv: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        x: *mut f32,
        ldx: *mut integer,
        ferr: *mut f32,
        berr: *mut f32,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn ssyrfsx_(
        uplo: *mut c_char,
        equed: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        af: *mut f32,
        ldaf: *mut integer,
        ipiv: *mut integer,
        s: *mut f32,
        b: *mut f32,
        ldb: *mut integer,
        x: *mut f32,
        ldx: *mut integer,
        rcond: *mut f32,
        berr: *mut f32,
        n_err_bnds: *mut integer,
        err_bnds_norm: *mut f32,
        err_bnds_comp: *mut f32,
        nparams: *mut integer,
        params: *mut f32,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn ssysv_aa_2stage_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        tb: *mut f32,
        ltb: *mut integer,
        ipiv: *mut integer,
        ipiv2: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn ssysv_aa_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn ssysv_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn ssysv_rk_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        e: *mut f32,
        ipiv: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn ssysv_rook_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn ssysvx_(
        fact: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        af: *mut f32,
        ldaf: *mut integer,
        ipiv: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        x: *mut f32,
        ldx: *mut integer,
        rcond: *mut f32,
        ferr: *mut f32,
        berr: *mut f32,
        work: *mut f32,
        lwork: *mut integer,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn ssysvxx_(
        fact: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        af: *mut f32,
        ldaf: *mut integer,
        ipiv: *mut integer,
        equed: *mut c_char,
        s: *mut f32,
        b: *mut f32,
        ldb: *mut integer,
        x: *mut f32,
        ldx: *mut integer,
        rcond: *mut f32,
        rpvgrw: *mut f32,
        berr: *mut f32,
        n_err_bnds: *mut integer,
        err_bnds_norm: *mut f32,
        err_bnds_comp: *mut f32,
        nparams: *mut integer,
        params: *mut f32,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn ssyswapr_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        i1: *mut integer,
        i2: *mut integer,
    );
    pub fn ssytd2_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        d: *mut f32,
        e: *mut f32,
        tau: *mut f32,
        info: *mut integer,
    );
    pub fn ssytf2_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn ssytf2_rk_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        e: *mut f32,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn ssytf2_rook_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn ssytrd_2stage_(
        vect: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        d: *mut f32,
        e: *mut f32,
        tau: *mut f32,
        hous2: *mut f32,
        lhous2: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn ssytrd_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        d: *mut f32,
        e: *mut f32,
        tau: *mut f32,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn ssytrd_sb2st_(
        stage1: *mut c_char,
        vect: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut f32,
        ldab: *mut integer,
        d: *mut f32,
        e: *mut f32,
        hous: *mut f32,
        lhous: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn ssytrd_sy2sb_(
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        ab: *mut f32,
        ldab: *mut integer,
        tau: *mut f32,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn ssytrf_aa_2stage_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        tb: *mut f32,
        ltb: *mut integer,
        ipiv: *mut integer,
        ipiv2: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn ssytrf_aa_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn ssytrf_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn ssytrf_rk_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        e: *mut f32,
        ipiv: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn ssytrf_rook_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn ssytri2_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn ssytri2x_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut f32,
        nb: *mut integer,
        info: *mut integer,
    );
    pub fn ssytri_3_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        e: *mut f32,
        ipiv: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn ssytri_3x_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        e: *mut f32,
        ipiv: *mut integer,
        work: *mut f32,
        nb: *mut integer,
        info: *mut integer,
    );
    pub fn ssytri_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn ssytri_rook_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn ssytrs2_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn ssytrs_3_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        e: *mut f32,
        ipiv: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn ssytrs_aa_2stage_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        tb: *mut f32,
        ltb: *mut integer,
        ipiv: *mut integer,
        ipiv2: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn ssytrs_aa_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn ssytrs_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn ssytrs_rook_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn stbcon_(
        norm: *mut c_char,
        uplo: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut f32,
        ldab: *mut integer,
        rcond: *mut f32,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn stbrfs_(
        uplo: *mut c_char,
        trans: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        nrhs: *mut integer,
        ab: *mut f32,
        ldab: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        x: *mut f32,
        ldx: *mut integer,
        ferr: *mut f32,
        berr: *mut f32,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn stbtrs_(
        uplo: *mut c_char,
        trans: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        nrhs: *mut integer,
        ab: *mut f32,
        ldab: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn stfsm_(
        transr: *mut c_char,
        side: *mut c_char,
        uplo: *mut c_char,
        trans: *mut c_char,
        diag: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        alpha: *mut f32,
        a: *mut f32,
        b: *mut f32,
        ldb: *mut integer,
    );
    pub fn stftri_(
        transr: *mut c_char,
        uplo: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        info: *mut integer,
    );
    pub fn stfttp_(
        transr: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        arf: *mut f32,
        ap: *mut f32,
        info: *mut integer,
    );
    pub fn stfttr_(
        transr: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        arf: *mut f32,
        a: *mut f32,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn stgevc_(
        side: *mut c_char,
        howmny: *mut c_char,
        select: *mut logical,
        n: *mut integer,
        s: *mut f32,
        lds: *mut integer,
        p: *mut f32,
        ldp: *mut integer,
        vl: *mut f32,
        ldvl: *mut integer,
        vr: *mut f32,
        ldvr: *mut integer,
        mm: *mut integer,
        m: *mut integer,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn stgex2_(
        wantq: *mut logical,
        wantz: *mut logical,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        q: *mut f32,
        ldq: *mut integer,
        z: *mut f32,
        ldz: *mut integer,
        j1: *mut integer,
        n1: *mut integer,
        n2: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn stgexc_(
        wantq: *mut logical,
        wantz: *mut logical,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        q: *mut f32,
        ldq: *mut integer,
        z: *mut f32,
        ldz: *mut integer,
        ifst: *mut integer,
        ilst: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn stgsen_(
        ijob: *mut integer,
        wantq: *mut logical,
        wantz: *mut logical,
        select: *mut logical,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        alphar: *mut f32,
        alphai: *mut f32,
        beta: *mut f32,
        q: *mut f32,
        ldq: *mut integer,
        z: *mut f32,
        ldz: *mut integer,
        m: *mut integer,
        pl: *mut f32,
        pr: *mut f32,
        dif: *mut f32,
        work: *mut f32,
        lwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn stgsja_(
        jobu: *mut c_char,
        jobv: *mut c_char,
        jobq: *mut c_char,
        m: *mut integer,
        p: *mut integer,
        n: *mut integer,
        k: *mut integer,
        l: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        tola: *mut f32,
        tolb: *mut f32,
        alpha: *mut f32,
        beta: *mut f32,
        u: *mut f32,
        ldu: *mut integer,
        v: *mut f32,
        ldv: *mut integer,
        q: *mut f32,
        ldq: *mut integer,
        work: *mut f32,
        ncycle: *mut integer,
        info: *mut integer,
    );
    pub fn stgsna_(
        job: *mut c_char,
        howmny: *mut c_char,
        select: *mut logical,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        vl: *mut f32,
        ldvl: *mut integer,
        vr: *mut f32,
        ldvr: *mut integer,
        s: *mut f32,
        dif: *mut f32,
        mm: *mut integer,
        m: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn stgsy2_(
        trans: *mut c_char,
        ijob: *mut integer,
        m: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        c: *mut f32,
        ldc: *mut integer,
        d: *mut f32,
        ldd: *mut integer,
        e: *mut f32,
        lde: *mut integer,
        f: *mut f32,
        ldf: *mut integer,
        scale: *mut f32,
        rdsum: *mut f32,
        rdscal: *mut f32,
        iwork: *mut integer,
        pq: *mut integer,
        info: *mut integer,
    );
    pub fn stgsyl_(
        trans: *mut c_char,
        ijob: *mut integer,
        m: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        c: *mut f32,
        ldc: *mut integer,
        d: *mut f32,
        ldd: *mut integer,
        e: *mut f32,
        lde: *mut integer,
        f: *mut f32,
        ldf: *mut integer,
        scale: *mut f32,
        dif: *mut f32,
        work: *mut f32,
        lwork: *mut integer,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn stpcon_(
        norm: *mut c_char,
        uplo: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        ap: *mut f32,
        rcond: *mut f32,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn stplqt2_(
        m: *mut integer,
        n: *mut integer,
        l: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        t: *mut f32,
        ldt: *mut integer,
        info: *mut integer,
    );
    pub fn stplqt_(
        m: *mut integer,
        n: *mut integer,
        l: *mut integer,
        mb: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        t: *mut f32,
        ldt: *mut integer,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn stpmlqt_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        l: *mut integer,
        mb: *mut integer,
        v: *mut f32,
        ldv: *mut integer,
        t: *mut f32,
        ldt: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn stpmqrt_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        l: *mut integer,
        nb: *mut integer,
        v: *mut f32,
        ldv: *mut integer,
        t: *mut f32,
        ldt: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn stpqrt2_(
        m: *mut integer,
        n: *mut integer,
        l: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        t: *mut f32,
        ldt: *mut integer,
        info: *mut integer,
    );
    pub fn stpqrt_(
        m: *mut integer,
        n: *mut integer,
        l: *mut integer,
        nb: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        t: *mut f32,
        ldt: *mut integer,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn stprfb_(
        side: *mut c_char,
        trans: *mut c_char,
        direct: *mut c_char,
        storev: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        l: *mut integer,
        v: *mut f32,
        ldv: *mut integer,
        t: *mut f32,
        ldt: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        work: *mut f32,
        ldwork: *mut integer,
    );
    pub fn stprfs_(
        uplo: *mut c_char,
        trans: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut f32,
        b: *mut f32,
        ldb: *mut integer,
        x: *mut f32,
        ldx: *mut integer,
        ferr: *mut f32,
        berr: *mut f32,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn stptri_(
        uplo: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        ap: *mut f32,
        info: *mut integer,
    );
    pub fn stptrs_(
        uplo: *mut c_char,
        trans: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut f32,
        b: *mut f32,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn stpttf_(
        transr: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut f32,
        arf: *mut f32,
        info: *mut integer,
    );
    pub fn stpttr_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut f32,
        a: *mut f32,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn strcon_(
        norm: *mut c_char,
        uplo: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        rcond: *mut f32,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn strevc3_(
        side: *mut c_char,
        howmny: *mut c_char,
        select: *mut logical,
        n: *mut integer,
        t: *mut f32,
        ldt: *mut integer,
        vl: *mut f32,
        ldvl: *mut integer,
        vr: *mut f32,
        ldvr: *mut integer,
        mm: *mut integer,
        m: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn strevc_(
        side: *mut c_char,
        howmny: *mut c_char,
        select: *mut logical,
        n: *mut integer,
        t: *mut f32,
        ldt: *mut integer,
        vl: *mut f32,
        ldvl: *mut integer,
        vr: *mut f32,
        ldvr: *mut integer,
        mm: *mut integer,
        m: *mut integer,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn strexc_(
        compq: *mut c_char,
        n: *mut integer,
        t: *mut f32,
        ldt: *mut integer,
        q: *mut f32,
        ldq: *mut integer,
        ifst: *mut integer,
        ilst: *mut integer,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn strrfs_(
        uplo: *mut c_char,
        trans: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        x: *mut f32,
        ldx: *mut integer,
        ferr: *mut f32,
        berr: *mut f32,
        work: *mut f32,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn strsen_(
        job: *mut c_char,
        compq: *mut c_char,
        select: *mut logical,
        n: *mut integer,
        t: *mut f32,
        ldt: *mut integer,
        q: *mut f32,
        ldq: *mut integer,
        wr: *mut f32,
        wi: *mut f32,
        m: *mut integer,
        s: *mut f32,
        sep: *mut f32,
        work: *mut f32,
        lwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn strsna_(
        job: *mut c_char,
        howmny: *mut c_char,
        select: *mut logical,
        n: *mut integer,
        t: *mut f32,
        ldt: *mut integer,
        vl: *mut f32,
        ldvl: *mut integer,
        vr: *mut f32,
        ldvr: *mut integer,
        s: *mut f32,
        sep: *mut f32,
        mm: *mut integer,
        m: *mut integer,
        work: *mut f32,
        ldwork: *mut integer,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn strsyl_(
        trana: *mut c_char,
        tranb: *mut c_char,
        isgn: *mut integer,
        m: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        c: *mut f32,
        ldc: *mut integer,
        scale: *mut f32,
        info: *mut integer,
    );
    pub fn strti2_(
        uplo: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn strtri_(
        uplo: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn strtrs_(
        uplo: *mut c_char,
        trans: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        b: *mut f32,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn strttf_(
        transr: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        arf: *mut f32,
        info: *mut integer,
    );
    pub fn strttp_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        ap: *mut f32,
        info: *mut integer,
    );
    pub fn stzrqf_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        tau: *mut f32,
        info: *mut integer,
    );
    pub fn stzrzf_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        tau: *mut f32,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zbbcsd_(
        jobu1: *mut c_char,
        jobu2: *mut c_char,
        jobv1t: *mut c_char,
        jobv2t: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        p: *mut integer,
        q: *mut integer,
        theta: *mut f64,
        phi: *mut f64,
        u1: *mut dcomplex,
        ldu1: *mut integer,
        u2: *mut dcomplex,
        ldu2: *mut integer,
        v1t: *mut dcomplex,
        ldv1t: *mut integer,
        v2t: *mut dcomplex,
        ldv2t: *mut integer,
        b11d: *mut f64,
        b11e: *mut f64,
        b12d: *mut f64,
        b12e: *mut f64,
        b21d: *mut f64,
        b21e: *mut f64,
        b22d: *mut f64,
        b22e: *mut f64,
        rwork: *mut f64,
        lrwork: *mut integer,
        info: *mut integer,
    );
    pub fn zbdsqr_(
        uplo: *mut c_char,
        n: *mut integer,
        ncvt: *mut integer,
        nru: *mut integer,
        ncc: *mut integer,
        d: *mut f64,
        e: *mut f64,
        vt: *mut dcomplex,
        ldvt: *mut integer,
        u: *mut dcomplex,
        ldu: *mut integer,
        c: *mut dcomplex,
        ldc: *mut integer,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zcgesv_(
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        x: *mut dcomplex,
        ldx: *mut integer,
        work: *mut dcomplex,
        swork: *mut scomplex,
        rwork: *mut f64,
        iter: *mut integer,
        info: *mut integer,
    );
    pub fn zcposv_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        x: *mut dcomplex,
        ldx: *mut integer,
        work: *mut dcomplex,
        swork: *mut scomplex,
        rwork: *mut f64,
        iter: *mut integer,
        info: *mut integer,
    );
    pub fn zdrscl_(n: *mut integer, sa: *mut f64, sx: *mut dcomplex, incx: *mut integer);
    pub fn zgbbrd_(
        vect: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        ncc: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        d: *mut f64,
        e: *mut f64,
        q: *mut dcomplex,
        ldq: *mut integer,
        pt: *mut dcomplex,
        ldpt: *mut integer,
        c: *mut dcomplex,
        ldc: *mut integer,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zgbcon_(
        norm: *mut c_char,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        ipiv: *mut integer,
        anorm: *mut f64,
        rcond: *mut f64,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zgbequb_(
        m: *mut integer,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        r: *mut f64,
        c: *mut f64,
        rowcnd: *mut f64,
        colcnd: *mut f64,
        amax: *mut f64,
        info: *mut integer,
    );
    pub fn zgbequ_(
        m: *mut integer,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        r: *mut f64,
        c: *mut f64,
        rowcnd: *mut f64,
        colcnd: *mut f64,
        amax: *mut f64,
        info: *mut integer,
    );
    pub fn zgbrfs_(
        trans: *mut c_char,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        nrhs: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        afb: *mut dcomplex,
        ldafb: *mut integer,
        ipiv: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        x: *mut dcomplex,
        ldx: *mut integer,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zgbrfsx_(
        trans: *mut c_char,
        equed: *mut c_char,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        nrhs: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        afb: *mut dcomplex,
        ldafb: *mut integer,
        ipiv: *mut integer,
        r: *mut f64,
        c: *mut f64,
        b: *mut dcomplex,
        ldb: *mut integer,
        x: *mut dcomplex,
        ldx: *mut integer,
        rcond: *mut f64,
        berr: *mut f64,
        n_err_bnds: *mut integer,
        err_bnds_norm: *mut f64,
        err_bnds_comp: *mut f64,
        nparams: *mut integer,
        params: *mut f64,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zgbsv_(
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        nrhs: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        ipiv: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn zgbsvx_(
        fact: *mut c_char,
        trans: *mut c_char,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        nrhs: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        afb: *mut dcomplex,
        ldafb: *mut integer,
        ipiv: *mut integer,
        equed: *mut c_char,
        r: *mut f64,
        c: *mut f64,
        b: *mut dcomplex,
        ldb: *mut integer,
        x: *mut dcomplex,
        ldx: *mut integer,
        rcond: *mut f64,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zgbsvxx_(
        fact: *mut c_char,
        trans: *mut c_char,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        nrhs: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        afb: *mut dcomplex,
        ldafb: *mut integer,
        ipiv: *mut integer,
        equed: *mut c_char,
        r: *mut f64,
        c: *mut f64,
        b: *mut dcomplex,
        ldb: *mut integer,
        x: *mut dcomplex,
        ldx: *mut integer,
        rcond: *mut f64,
        rpvgrw: *mut f64,
        berr: *mut f64,
        n_err_bnds: *mut integer,
        err_bnds_norm: *mut f64,
        err_bnds_comp: *mut f64,
        nparams: *mut integer,
        params: *mut f64,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zgbtf2_(
        m: *mut integer,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn zgbtrf_(
        m: *mut integer,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn zgbtrs_(
        trans: *mut c_char,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        nrhs: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        ipiv: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn zgebak_(
        job: *mut c_char,
        side: *mut c_char,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        scale: *mut f64,
        m: *mut integer,
        v: *mut dcomplex,
        ldv: *mut integer,
        info: *mut integer,
    );
    pub fn zgebal_(
        job: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        scale: *mut f64,
        info: *mut integer,
    );
    pub fn zgebd2_(
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        d: *mut f64,
        e: *mut f64,
        tauq: *mut dcomplex,
        taup: *mut dcomplex,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zgebrd_(
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        d: *mut f64,
        e: *mut f64,
        tauq: *mut dcomplex,
        taup: *mut dcomplex,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zgecon_(
        norm: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        anorm: *mut f64,
        rcond: *mut f64,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zgeequb_(
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        r: *mut f64,
        c: *mut f64,
        rowcnd: *mut f64,
        colcnd: *mut f64,
        amax: *mut f64,
        info: *mut integer,
    );
    pub fn zgeequ_(
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        r: *mut f64,
        c: *mut f64,
        rowcnd: *mut f64,
        colcnd: *mut f64,
        amax: *mut f64,
        info: *mut integer,
    );
    pub fn zgees_(
        jobvs: *mut c_char,
        sort: *mut c_char,
        select: L_fp,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        sdim: *mut integer,
        w: *mut dcomplex,
        vs: *mut dcomplex,
        ldvs: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        bwork: *mut logical,
        info: *mut integer,
    );
    pub fn zgeesx_(
        jobvs: *mut c_char,
        sort: *mut c_char,
        select: L_fp,
        sense: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        sdim: *mut integer,
        w: *mut dcomplex,
        vs: *mut dcomplex,
        ldvs: *mut integer,
        rconde: *mut f64,
        rcondv: *mut f64,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        bwork: *mut logical,
        info: *mut integer,
    );
    pub fn zgeev_(
        jobvl: *mut c_char,
        jobvr: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        w: *mut dcomplex,
        vl: *mut dcomplex,
        ldvl: *mut integer,
        vr: *mut dcomplex,
        ldvr: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zgeevx_(
        balanc: *mut c_char,
        jobvl: *mut c_char,
        jobvr: *mut c_char,
        sense: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        w: *mut dcomplex,
        vl: *mut dcomplex,
        ldvl: *mut integer,
        vr: *mut dcomplex,
        ldvr: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        scale: *mut f64,
        abnrm: *mut f64,
        rconde: *mut f64,
        rcondv: *mut f64,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zgegs_(
        jobvsl: *mut c_char,
        jobvsr: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        alpha: *mut dcomplex,
        beta: *mut dcomplex,
        vsl: *mut dcomplex,
        ldvsl: *mut integer,
        vsr: *mut dcomplex,
        ldvsr: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zgegv_(
        jobvl: *mut c_char,
        jobvr: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        alpha: *mut dcomplex,
        beta: *mut dcomplex,
        vl: *mut dcomplex,
        ldvl: *mut integer,
        vr: *mut dcomplex,
        ldvr: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zgehd2_(
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        tau: *mut dcomplex,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zgehrd_(
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        tau: *mut dcomplex,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zgejsv_(
        joba: *mut c_char,
        jobu: *mut c_char,
        jobv: *mut c_char,
        jobr: *mut c_char,
        jobt: *mut c_char,
        jobp: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        sva: *mut f64,
        u: *mut dcomplex,
        ldu: *mut integer,
        v: *mut dcomplex,
        ldv: *mut integer,
        cwork: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        lrwork: *mut integer,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn zgelq2_(
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        tau: *mut dcomplex,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zgelqf_(
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        tau: *mut dcomplex,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zgelq_(
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        t: *mut dcomplex,
        tsize: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zgelqt3_(
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        t: *mut dcomplex,
        ldt: *mut integer,
        info: *mut integer,
    );
    pub fn zgelqt_(
        m: *mut integer,
        n: *mut integer,
        mb: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        t: *mut dcomplex,
        ldt: *mut integer,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zgels_(
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zgelsd_(
        m: *mut integer,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        s: *mut f64,
        rcond: *mut f64,
        rank: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn zgelss_(
        m: *mut integer,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        s: *mut f64,
        rcond: *mut f64,
        rank: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zgelsx_(
        m: *mut integer,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        jpvt: *mut integer,
        rcond: *mut f64,
        rank: *mut integer,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zgelsy_(
        m: *mut integer,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        jpvt: *mut integer,
        rcond: *mut f64,
        rank: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zgemlq_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        t: *mut dcomplex,
        tsize: *mut integer,
        c: *mut dcomplex,
        ldc: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zgemlqt_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        mb: *mut integer,
        v: *mut dcomplex,
        ldv: *mut integer,
        t: *mut dcomplex,
        ldt: *mut integer,
        c: *mut dcomplex,
        ldc: *mut integer,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zgemqr_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        t: *mut dcomplex,
        tsize: *mut integer,
        c: *mut dcomplex,
        ldc: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zgemqrt_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        nb: *mut integer,
        v: *mut dcomplex,
        ldv: *mut integer,
        t: *mut dcomplex,
        ldt: *mut integer,
        c: *mut dcomplex,
        ldc: *mut integer,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zgeql2_(
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        tau: *mut dcomplex,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zgeqlf_(
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        tau: *mut dcomplex,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zgeqp3_(
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        jpvt: *mut integer,
        tau: *mut dcomplex,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zgeqpf_(
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        jpvt: *mut integer,
        tau: *mut dcomplex,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zgeqr2_(
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        tau: *mut dcomplex,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zgeqr2p_(
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        tau: *mut dcomplex,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zgeqrf_(
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        tau: *mut dcomplex,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zgeqrfp_(
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        tau: *mut dcomplex,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zgeqr_(
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        t: *mut dcomplex,
        tsize: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zgeqrt2_(
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        t: *mut dcomplex,
        ldt: *mut integer,
        info: *mut integer,
    );
    pub fn zgeqrt3_(
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        t: *mut dcomplex,
        ldt: *mut integer,
        info: *mut integer,
    );
    pub fn zgeqrt_(
        m: *mut integer,
        n: *mut integer,
        nb: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        t: *mut dcomplex,
        ldt: *mut integer,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zgerfs_(
        trans: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        af: *mut dcomplex,
        ldaf: *mut integer,
        ipiv: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        x: *mut dcomplex,
        ldx: *mut integer,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zgerfsx_(
        trans: *mut c_char,
        equed: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        af: *mut dcomplex,
        ldaf: *mut integer,
        ipiv: *mut integer,
        r: *mut f64,
        c: *mut f64,
        b: *mut dcomplex,
        ldb: *mut integer,
        x: *mut dcomplex,
        ldx: *mut integer,
        rcond: *mut f64,
        berr: *mut f64,
        n_err_bnds: *mut integer,
        err_bnds_norm: *mut f64,
        err_bnds_comp: *mut f64,
        nparams: *mut integer,
        params: *mut f64,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zgerq2_(
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        tau: *mut dcomplex,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zgerqf_(
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        tau: *mut dcomplex,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zgesc2_(
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        rhs: *mut dcomplex,
        ipiv: *mut integer,
        jpiv: *mut integer,
        scale: *mut f64,
    );
    pub fn zgesdd_(
        jobz: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        s: *mut f64,
        u: *mut dcomplex,
        ldu: *mut integer,
        vt: *mut dcomplex,
        ldvt: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn zgesvd_(
        jobu: *mut c_char,
        jobv: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        s: *mut f64,
        u: *mut dcomplex,
        ldu: *mut integer,
        vt: *mut dcomplex,
        ldvt: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zgesvdq_(
        joba: *mut c_char,
        jobp: *mut c_char,
        jobr: *mut c_char,
        jobu: *mut c_char,
        jobv: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        s: *mut f64,
        u: *mut dcomplex,
        ldu: *mut integer,
        v: *mut dcomplex,
        ldv: *mut integer,
        numrank: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        cwork: *mut dcomplex,
        lcwork: *mut integer,
        rwork: *mut f64,
        lrwork: *mut integer,
        info: *mut integer,
    );
    pub fn zgesvdx_(
        jobu: *mut c_char,
        jobvt: *mut c_char,
        range: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        vl: *mut f64,
        vu: *mut f64,
        il: *mut integer,
        iu: *mut integer,
        ns: *mut integer,
        s: *mut f64,
        u: *mut dcomplex,
        ldu: *mut integer,
        vt: *mut dcomplex,
        ldvt: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn zgesv_(
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn zgesvj_(
        joba: *mut c_char,
        jobu: *mut c_char,
        jobv: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        sva: *mut f64,
        mv: *mut integer,
        v: *mut dcomplex,
        ldv: *mut integer,
        cwork: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        lrwork: *mut integer,
        info: *mut integer,
    );
    pub fn zgesvx_(
        fact: *mut c_char,
        trans: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        af: *mut dcomplex,
        ldaf: *mut integer,
        ipiv: *mut integer,
        equed: *mut c_char,
        r: *mut f64,
        c: *mut f64,
        b: *mut dcomplex,
        ldb: *mut integer,
        x: *mut dcomplex,
        ldx: *mut integer,
        rcond: *mut f64,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zgesvxx_(
        fact: *mut c_char,
        trans: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        af: *mut dcomplex,
        ldaf: *mut integer,
        ipiv: *mut integer,
        equed: *mut c_char,
        r: *mut f64,
        c: *mut f64,
        b: *mut dcomplex,
        ldb: *mut integer,
        x: *mut dcomplex,
        ldx: *mut integer,
        rcond: *mut f64,
        rpvgrw: *mut f64,
        berr: *mut f64,
        n_err_bnds: *mut integer,
        err_bnds_norm: *mut f64,
        err_bnds_comp: *mut f64,
        nparams: *mut integer,
        params: *mut f64,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zgetc2_(
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        jpiv: *mut integer,
        info: *mut integer,
    );
    pub fn zgetf2_(
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn zgetrf2_(
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn zgetrf_(
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn zgetri_(
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zgetrs_(
        trans: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn zgetsls_(
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zggbak_(
        job: *mut c_char,
        side: *mut c_char,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        lscale: *mut f64,
        rscale: *mut f64,
        m: *mut integer,
        v: *mut dcomplex,
        ldv: *mut integer,
        info: *mut integer,
    );
    pub fn zggbal_(
        job: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        lscale: *mut f64,
        rscale: *mut f64,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn zgges3_(
        jobvsl: *mut c_char,
        jobvsr: *mut c_char,
        sort: *mut c_char,
        selctg: L_fp,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        sdim: *mut integer,
        alpha: *mut dcomplex,
        beta: *mut dcomplex,
        vsl: *mut dcomplex,
        ldvsl: *mut integer,
        vsr: *mut dcomplex,
        ldvsr: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        bwork: *mut logical,
        info: *mut integer,
    );
    pub fn zgges_(
        jobvsl: *mut c_char,
        jobvsr: *mut c_char,
        sort: *mut c_char,
        selctg: L_fp,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        sdim: *mut integer,
        alpha: *mut dcomplex,
        beta: *mut dcomplex,
        vsl: *mut dcomplex,
        ldvsl: *mut integer,
        vsr: *mut dcomplex,
        ldvsr: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        bwork: *mut logical,
        info: *mut integer,
    );
    pub fn zggesx_(
        jobvsl: *mut c_char,
        jobvsr: *mut c_char,
        sort: *mut c_char,
        selctg: L_fp,
        sense: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        sdim: *mut integer,
        alpha: *mut dcomplex,
        beta: *mut dcomplex,
        vsl: *mut dcomplex,
        ldvsl: *mut integer,
        vsr: *mut dcomplex,
        ldvsr: *mut integer,
        rconde: *mut f64,
        rcondv: *mut f64,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        iwork: *mut integer,
        liwork: *mut integer,
        bwork: *mut logical,
        info: *mut integer,
    );
    pub fn zggev3_(
        jobvl: *mut c_char,
        jobvr: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        alpha: *mut dcomplex,
        beta: *mut dcomplex,
        vl: *mut dcomplex,
        ldvl: *mut integer,
        vr: *mut dcomplex,
        ldvr: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zggev_(
        jobvl: *mut c_char,
        jobvr: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        alpha: *mut dcomplex,
        beta: *mut dcomplex,
        vl: *mut dcomplex,
        ldvl: *mut integer,
        vr: *mut dcomplex,
        ldvr: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zggevx_(
        balanc: *mut c_char,
        jobvl: *mut c_char,
        jobvr: *mut c_char,
        sense: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        alpha: *mut dcomplex,
        beta: *mut dcomplex,
        vl: *mut dcomplex,
        ldvl: *mut integer,
        vr: *mut dcomplex,
        ldvr: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        lscale: *mut f64,
        rscale: *mut f64,
        abnrm: *mut f64,
        bbnrm: *mut f64,
        rconde: *mut f64,
        rcondv: *mut f64,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        iwork: *mut integer,
        bwork: *mut logical,
        info: *mut integer,
    );
    pub fn zggglm_(
        n: *mut integer,
        m: *mut integer,
        p: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        d: *mut dcomplex,
        x: *mut dcomplex,
        y: *mut dcomplex,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zgghd3_(
        compq: *mut c_char,
        compz: *mut c_char,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        q: *mut dcomplex,
        ldq: *mut integer,
        z: *mut dcomplex,
        ldz: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zgghrd_(
        compq: *mut c_char,
        compz: *mut c_char,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        q: *mut dcomplex,
        ldq: *mut integer,
        z: *mut dcomplex,
        ldz: *mut integer,
        info: *mut integer,
    );
    pub fn zgglse_(
        m: *mut integer,
        n: *mut integer,
        p: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        c: *mut dcomplex,
        d: *mut dcomplex,
        x: *mut dcomplex,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zggqrf_(
        n: *mut integer,
        m: *mut integer,
        p: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        taua: *mut dcomplex,
        b: *mut dcomplex,
        ldb: *mut integer,
        taub: *mut dcomplex,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zggrqf_(
        m: *mut integer,
        p: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        taua: *mut dcomplex,
        b: *mut dcomplex,
        ldb: *mut integer,
        taub: *mut dcomplex,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zggsvd3_(
        jobu: *mut c_char,
        jobv: *mut c_char,
        jobq: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        p: *mut integer,
        k: *mut integer,
        l: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        alpha: *mut f64,
        beta: *mut f64,
        u: *mut dcomplex,
        ldu: *mut integer,
        v: *mut dcomplex,
        ldv: *mut integer,
        q: *mut dcomplex,
        ldq: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn zggsvd_(
        jobu: *mut c_char,
        jobv: *mut c_char,
        jobq: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        p: *mut integer,
        k: *mut integer,
        l: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        alpha: *mut f64,
        beta: *mut f64,
        u: *mut dcomplex,
        ldu: *mut integer,
        v: *mut dcomplex,
        ldv: *mut integer,
        q: *mut dcomplex,
        ldq: *mut integer,
        work: *mut dcomplex,
        rwork: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn zggsvp3_(
        jobu: *mut c_char,
        jobv: *mut c_char,
        jobq: *mut c_char,
        m: *mut integer,
        p: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        tola: *mut f64,
        tolb: *mut f64,
        k: *mut integer,
        l: *mut integer,
        u: *mut dcomplex,
        ldu: *mut integer,
        v: *mut dcomplex,
        ldv: *mut integer,
        q: *mut dcomplex,
        ldq: *mut integer,
        iwork: *mut integer,
        rwork: *mut f64,
        tau: *mut dcomplex,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zggsvp_(
        jobu: *mut c_char,
        jobv: *mut c_char,
        jobq: *mut c_char,
        m: *mut integer,
        p: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        tola: *mut f64,
        tolb: *mut f64,
        k: *mut integer,
        l: *mut integer,
        u: *mut dcomplex,
        ldu: *mut integer,
        v: *mut dcomplex,
        ldv: *mut integer,
        q: *mut dcomplex,
        ldq: *mut integer,
        iwork: *mut integer,
        rwork: *mut f64,
        tau: *mut dcomplex,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zgsvj0_(
        jobv: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        d: *mut dcomplex,
        sva: *mut f64,
        mv: *mut integer,
        v: *mut dcomplex,
        ldv: *mut integer,
        eps: *mut f64,
        sfmin: *mut f64,
        tol: *mut f64,
        nsweep: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zgsvj1_(
        jobv: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        n1: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        d: *mut dcomplex,
        sva: *mut f64,
        mv: *mut integer,
        v: *mut dcomplex,
        ldv: *mut integer,
        eps: *mut f64,
        sfmin: *mut f64,
        tol: *mut f64,
        nsweep: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zgtcon_(
        norm: *mut c_char,
        n: *mut integer,
        dl: *mut dcomplex,
        d: *mut dcomplex,
        du: *mut dcomplex,
        du2: *mut dcomplex,
        ipiv: *mut integer,
        anorm: *mut f64,
        rcond: *mut f64,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zgtrfs_(
        trans: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        dl: *mut dcomplex,
        d: *mut dcomplex,
        du: *mut dcomplex,
        dlf: *mut dcomplex,
        df: *mut dcomplex,
        duf: *mut dcomplex,
        du2: *mut dcomplex,
        ipiv: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        x: *mut dcomplex,
        ldx: *mut integer,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zgtsv_(
        n: *mut integer,
        nrhs: *mut integer,
        dl: *mut dcomplex,
        d: *mut dcomplex,
        du: *mut dcomplex,
        b: *mut dcomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn zgtsvx_(
        fact: *mut c_char,
        trans: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        dl: *mut dcomplex,
        d: *mut dcomplex,
        du: *mut dcomplex,
        dlf: *mut dcomplex,
        df: *mut dcomplex,
        duf: *mut dcomplex,
        du2: *mut dcomplex,
        ipiv: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        x: *mut dcomplex,
        ldx: *mut integer,
        rcond: *mut f64,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zgttrf_(
        n: *mut integer,
        dl: *mut dcomplex,
        d: *mut dcomplex,
        du: *mut dcomplex,
        du2: *mut dcomplex,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn zgttrs_(
        trans: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        dl: *mut dcomplex,
        d: *mut dcomplex,
        du: *mut dcomplex,
        du2: *mut dcomplex,
        ipiv: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn zgtts2_(
        itrans: *mut integer,
        n: *mut integer,
        nrhs: *mut integer,
        dl: *mut dcomplex,
        d: *mut dcomplex,
        du: *mut dcomplex,
        du2: *mut dcomplex,
        ipiv: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
    );
    pub fn zhb2st_kernels_(
        uplo: *mut c_char,
        wantz: *mut logical,
        ttype: *mut integer,
        st: *mut integer,
        ed: *mut integer,
        sweep: *mut integer,
        n: *mut integer,
        nb: *mut integer,
        ib: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        v: *mut dcomplex,
        tau: *mut dcomplex,
        ldvt: *mut integer,
        work: *mut dcomplex,
    );
    pub fn zhbev_2stage_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        w: *mut f64,
        z: *mut dcomplex,
        ldz: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zhbev_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        w: *mut f64,
        z: *mut dcomplex,
        ldz: *mut integer,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zhbevd_2stage_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        w: *mut f64,
        z: *mut dcomplex,
        ldz: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        lrwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn zhbevd_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        w: *mut f64,
        z: *mut dcomplex,
        ldz: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        lrwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn zhbevx_2stage_(
        jobz: *mut c_char,
        range: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        q: *mut dcomplex,
        ldq: *mut integer,
        vl: *mut f64,
        vu: *mut f64,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f64,
        m: *mut integer,
        w: *mut f64,
        z: *mut dcomplex,
        ldz: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        iwork: *mut integer,
        ifail: *mut integer,
        info: *mut integer,
    );
    pub fn zhbevx_(
        jobz: *mut c_char,
        range: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        q: *mut dcomplex,
        ldq: *mut integer,
        vl: *mut f64,
        vu: *mut f64,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f64,
        m: *mut integer,
        w: *mut f64,
        z: *mut dcomplex,
        ldz: *mut integer,
        work: *mut dcomplex,
        rwork: *mut f64,
        iwork: *mut integer,
        ifail: *mut integer,
        info: *mut integer,
    );
    pub fn zhbgst_(
        vect: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ka: *mut integer,
        kb: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        bb: *mut dcomplex,
        ldbb: *mut integer,
        x: *mut dcomplex,
        ldx: *mut integer,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zhbgv_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ka: *mut integer,
        kb: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        bb: *mut dcomplex,
        ldbb: *mut integer,
        w: *mut f64,
        z: *mut dcomplex,
        ldz: *mut integer,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zhbgvd_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ka: *mut integer,
        kb: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        bb: *mut dcomplex,
        ldbb: *mut integer,
        w: *mut f64,
        z: *mut dcomplex,
        ldz: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        lrwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn zhbgvx_(
        jobz: *mut c_char,
        range: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ka: *mut integer,
        kb: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        bb: *mut dcomplex,
        ldbb: *mut integer,
        q: *mut dcomplex,
        ldq: *mut integer,
        vl: *mut f64,
        vu: *mut f64,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f64,
        m: *mut integer,
        w: *mut f64,
        z: *mut dcomplex,
        ldz: *mut integer,
        work: *mut dcomplex,
        rwork: *mut f64,
        iwork: *mut integer,
        ifail: *mut integer,
        info: *mut integer,
    );
    pub fn zhbtrd_(
        vect: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        d: *mut f64,
        e: *mut f64,
        q: *mut dcomplex,
        ldq: *mut integer,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zhecon_3_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        e: *mut dcomplex,
        ipiv: *mut integer,
        anorm: *mut f64,
        rcond: *mut f64,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zhecon_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        anorm: *mut f64,
        rcond: *mut f64,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zhecon_rook_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        anorm: *mut f64,
        rcond: *mut f64,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zheequb_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        s: *mut f64,
        scond: *mut f64,
        amax: *mut f64,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zheev_2stage_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        w: *mut f64,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zheev_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        w: *mut f64,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zheevd_2stage_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        w: *mut f64,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        lrwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn zheevd_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        w: *mut f64,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        lrwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn zheevr_2stage_(
        jobz: *mut c_char,
        range: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        vl: *mut f64,
        vu: *mut f64,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f64,
        m: *mut integer,
        w: *mut f64,
        z: *mut dcomplex,
        ldz: *mut integer,
        isuppz: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        lrwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn zheevr_(
        jobz: *mut c_char,
        range: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        vl: *mut f64,
        vu: *mut f64,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f64,
        m: *mut integer,
        w: *mut f64,
        z: *mut dcomplex,
        ldz: *mut integer,
        isuppz: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        lrwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn zheevx_2stage_(
        jobz: *mut c_char,
        range: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        vl: *mut f64,
        vu: *mut f64,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f64,
        m: *mut integer,
        w: *mut f64,
        z: *mut dcomplex,
        ldz: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        iwork: *mut integer,
        ifail: *mut integer,
        info: *mut integer,
    );
    pub fn zheevx_(
        jobz: *mut c_char,
        range: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        vl: *mut f64,
        vu: *mut f64,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f64,
        m: *mut integer,
        w: *mut f64,
        z: *mut dcomplex,
        ldz: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        iwork: *mut integer,
        ifail: *mut integer,
        info: *mut integer,
    );
    pub fn zhegs2_(
        itype: *mut integer,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn zhegst_(
        itype: *mut integer,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn zhegv_2stage_(
        itype: *mut integer,
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        w: *mut f64,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zhegvd_(
        itype: *mut integer,
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        w: *mut f64,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        lrwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn zhegv_(
        itype: *mut integer,
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        w: *mut f64,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zhegvx_(
        itype: *mut integer,
        jobz: *mut c_char,
        range: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        vl: *mut f64,
        vu: *mut f64,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f64,
        m: *mut integer,
        w: *mut f64,
        z: *mut dcomplex,
        ldz: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        iwork: *mut integer,
        ifail: *mut integer,
        info: *mut integer,
    );
    pub fn zherfs_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        af: *mut dcomplex,
        ldaf: *mut integer,
        ipiv: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        x: *mut dcomplex,
        ldx: *mut integer,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zherfsx_(
        uplo: *mut c_char,
        equed: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        af: *mut dcomplex,
        ldaf: *mut integer,
        ipiv: *mut integer,
        s: *mut f64,
        b: *mut dcomplex,
        ldb: *mut integer,
        x: *mut dcomplex,
        ldx: *mut integer,
        rcond: *mut f64,
        berr: *mut f64,
        n_err_bnds: *mut integer,
        err_bnds_norm: *mut f64,
        err_bnds_comp: *mut f64,
        nparams: *mut integer,
        params: *mut f64,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zhesv_aa_2stage_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        tb: *mut dcomplex,
        ltb: *mut integer,
        ipiv: *mut integer,
        ipiv2: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zhesv_aa_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zhesv_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zhesv_rk_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        e: *mut dcomplex,
        ipiv: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zhesv_rook_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zhesvx_(
        fact: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        af: *mut dcomplex,
        ldaf: *mut integer,
        ipiv: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        x: *mut dcomplex,
        ldx: *mut integer,
        rcond: *mut f64,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zhesvxx_(
        fact: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        af: *mut dcomplex,
        ldaf: *mut integer,
        ipiv: *mut integer,
        equed: *mut c_char,
        s: *mut f64,
        b: *mut dcomplex,
        ldb: *mut integer,
        x: *mut dcomplex,
        ldx: *mut integer,
        rcond: *mut f64,
        rpvgrw: *mut f64,
        berr: *mut f64,
        n_err_bnds: *mut integer,
        err_bnds_norm: *mut f64,
        err_bnds_comp: *mut f64,
        nparams: *mut integer,
        params: *mut f64,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zheswapr_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        i1: *mut integer,
        i2: *mut integer,
    );
    pub fn zhetd2_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        d: *mut f64,
        e: *mut f64,
        tau: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zhetf2_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn zhetf2_rk_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        e: *mut dcomplex,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn zhetf2_rook_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn zhetrd_2stage_(
        vect: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        d: *mut f64,
        e: *mut f64,
        tau: *mut dcomplex,
        hous2: *mut dcomplex,
        lhous2: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zhetrd_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        d: *mut f64,
        e: *mut f64,
        tau: *mut dcomplex,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zhetrd_hb2st_(
        stage1: *mut c_char,
        vect: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        d: *mut f64,
        e: *mut f64,
        hous: *mut dcomplex,
        lhous: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zhetrd_he2hb_(
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        tau: *mut dcomplex,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zhetrf_aa_2stage_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        tb: *mut dcomplex,
        ltb: *mut integer,
        ipiv: *mut integer,
        ipiv2: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zhetrf_aa_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zhetrf_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zhetrf_rk_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        e: *mut dcomplex,
        ipiv: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zhetrf_rook_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zhetri2_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zhetri2x_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut dcomplex,
        nb: *mut integer,
        info: *mut integer,
    );
    pub fn zhetri_3_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        e: *mut dcomplex,
        ipiv: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zhetri_3x_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        e: *mut dcomplex,
        ipiv: *mut integer,
        work: *mut dcomplex,
        nb: *mut integer,
        info: *mut integer,
    );
    pub fn zhetri_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zhetri_rook_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zhetrs2_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zhetrs_3_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        e: *mut dcomplex,
        ipiv: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn zhetrs_aa_2stage_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        tb: *mut dcomplex,
        ltb: *mut integer,
        ipiv: *mut integer,
        ipiv2: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn zhetrs_aa_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zhetrs_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn zhetrs_rook_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn zhfrk_(
        transr: *mut c_char,
        uplo: *mut c_char,
        trans: *mut c_char,
        n: *mut integer,
        k: *mut integer,
        alpha: *mut f64,
        a: *mut dcomplex,
        lda: *mut integer,
        beta: *mut f64,
        c__: *mut dcomplex,
    );
    pub fn zhgeqz_(
        job: *mut c_char,
        compq: *mut c_char,
        compz: *mut c_char,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        h: *mut dcomplex,
        ldh: *mut integer,
        t: *mut dcomplex,
        ldt: *mut integer,
        alpha: *mut dcomplex,
        beta: *mut dcomplex,
        q: *mut dcomplex,
        ldq: *mut integer,
        z: *mut dcomplex,
        ldz: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zhpcon_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut dcomplex,
        ipiv: *mut integer,
        anorm: *mut f64,
        rcond: *mut f64,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zhpev_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut dcomplex,
        w: *mut f64,
        z: *mut dcomplex,
        ldz: *mut integer,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zhpevd_(
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut dcomplex,
        w: *mut f64,
        z: *mut dcomplex,
        ldz: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        lrwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn zhpevx_(
        jobz: *mut c_char,
        range: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut dcomplex,
        vl: *mut f64,
        vu: *mut f64,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f64,
        m: *mut integer,
        w: *mut f64,
        z: *mut dcomplex,
        ldz: *mut integer,
        work: *mut dcomplex,
        rwork: *mut f64,
        iwork: *mut integer,
        ifail: *mut integer,
        info: *mut integer,
    );
    pub fn zhpgst_(
        itype: *mut integer,
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut dcomplex,
        bp: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zhpgvd_(
        itype: *mut integer,
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut dcomplex,
        bp: *mut dcomplex,
        w: *mut f64,
        z: *mut dcomplex,
        ldz: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        lrwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn zhpgv_(
        itype: *mut integer,
        jobz: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut dcomplex,
        bp: *mut dcomplex,
        w: *mut f64,
        z: *mut dcomplex,
        ldz: *mut integer,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zhpgvx_(
        itype: *mut integer,
        jobz: *mut c_char,
        range: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut dcomplex,
        bp: *mut dcomplex,
        vl: *mut f64,
        vu: *mut f64,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f64,
        m: *mut integer,
        w: *mut f64,
        z: *mut dcomplex,
        ldz: *mut integer,
        work: *mut dcomplex,
        rwork: *mut f64,
        iwork: *mut integer,
        ifail: *mut integer,
        info: *mut integer,
    );
    pub fn zhprfs_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut dcomplex,
        afp: *mut dcomplex,
        ipiv: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        x: *mut dcomplex,
        ldx: *mut integer,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zhpsv_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut dcomplex,
        ipiv: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn zhpsvx_(
        fact: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut dcomplex,
        afp: *mut dcomplex,
        ipiv: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        x: *mut dcomplex,
        ldx: *mut integer,
        rcond: *mut f64,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zhptrd_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut dcomplex,
        d: *mut f64,
        e: *mut f64,
        tau: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zhptrf_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut dcomplex,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn zhptri_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut dcomplex,
        ipiv: *mut integer,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zhptrs_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut dcomplex,
        ipiv: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn zhsein_(
        side: *mut c_char,
        eigsrc: *mut c_char,
        initv: *mut c_char,
        select: *mut logical,
        n: *mut integer,
        h: *mut dcomplex,
        ldh: *mut integer,
        w: *mut dcomplex,
        vl: *mut dcomplex,
        ldvl: *mut integer,
        vr: *mut dcomplex,
        ldvr: *mut integer,
        mm: *mut integer,
        m: *mut integer,
        work: *mut dcomplex,
        rwork: *mut f64,
        ifaill: *mut integer,
        ifailr: *mut integer,
        info: *mut integer,
    );
    pub fn zhseqr_(
        job: *mut c_char,
        compz: *mut c_char,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        h: *mut dcomplex,
        ldh: *mut integer,
        w: *mut dcomplex,
        z: *mut dcomplex,
        ldz: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zlabrd_(
        m: *mut integer,
        n: *mut integer,
        nb: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        d: *mut f64,
        e: *mut f64,
        tauq: *mut dcomplex,
        taup: *mut dcomplex,
        x: *mut dcomplex,
        ldx: *mut integer,
        y: *mut dcomplex,
        ldy: *mut integer,
    );
    pub fn zlacgv_(n: *mut integer, x: *mut dcomplex, incx: *mut integer);
    pub fn zlacn2_(
        n: *mut integer,
        v: *mut dcomplex,
        x: *mut dcomplex,
        est: *mut f64,
        kase: *mut integer,
        isave: *mut integer,
    );
    pub fn zlacon_(
        n: *mut integer,
        v: *mut dcomplex,
        x: *mut dcomplex,
        est: *mut f64,
        kase: *mut integer,
    );
    pub fn zlacp2_(
        uplo: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
    );
    pub fn zlacpy_(
        uplo: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
    );
    pub fn zlacrm_(
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut f64,
        ldb: *mut integer,
        c: *mut dcomplex,
        ldc: *mut integer,
        rwork: *mut f64,
    );
    pub fn zlacrt_(
        n: *mut integer,
        cx: *mut dcomplex,
        incx: *mut integer,
        cy: *mut dcomplex,
        incy: *mut integer,
        c: *mut dcomplex,
        s: *mut dcomplex,
    );
    pub fn zlaed0_(
        qsiz: *mut integer,
        n: *mut integer,
        d: *mut f64,
        e: *mut f64,
        q: *mut dcomplex,
        ldq: *mut integer,
        qstore: *mut dcomplex,
        ldqs: *mut integer,
        rwork: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn zlaed7_(
        n: *mut integer,
        cutpnt: *mut integer,
        qsiz: *mut integer,
        tlvls: *mut integer,
        curlvl: *mut integer,
        curpbm: *mut integer,
        d: *mut f64,
        q: *mut dcomplex,
        ldq: *mut integer,
        rho: *mut f64,
        indxq: *mut integer,
        qstore: *mut f64,
        qptr: *mut integer,
        prmptr: *mut integer,
        perm: *mut integer,
        givptr: *mut integer,
        givcol: *mut integer,
        givnum: *mut f64,
        work: *mut dcomplex,
        rwork: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn zlaed8_(
        k: *mut integer,
        n: *mut integer,
        qsiz: *mut integer,
        q: *mut dcomplex,
        ldq: *mut integer,
        d: *mut f64,
        rho: *mut f64,
        cutpnt: *mut integer,
        z: *mut f64,
        dlamda: *mut f64,
        q2: *mut dcomplex,
        ldq2: *mut integer,
        w: *mut f64,
        indxp: *mut integer,
        indx: *mut integer,
        indxq: *mut integer,
        perm: *mut integer,
        givptr: *mut integer,
        givcol: *mut integer,
        givnum: *mut f64,
        info: *mut integer,
    );
    pub fn zlaein_(
        rightv: *mut logical,
        noinit: *mut logical,
        n: *mut integer,
        h: *mut dcomplex,
        ldh: *mut integer,
        w: *mut dcomplex,
        v: *mut dcomplex,
        b: *mut dcomplex,
        ldb: *mut integer,
        rwork: *mut f64,
        eps3: *mut f64,
        smlnum: *mut f64,
        info: *mut integer,
    );
    pub fn zlaesy_(
        a: *mut dcomplex,
        b: *mut dcomplex,
        c: *mut dcomplex,
        rt1: *mut dcomplex,
        rt2: *mut dcomplex,
        evscal: *mut dcomplex,
        cs1: *mut dcomplex,
        sn1: *mut dcomplex,
    );
    pub fn zlaev2_(
        a: *mut dcomplex,
        b: *mut dcomplex,
        c: *mut dcomplex,
        rt1: *mut f64,
        rt2: *mut f64,
        cs1: *mut f64,
        sn1: *mut dcomplex,
    );
    pub fn zlag2c_(
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        sa: *mut scomplex,
        ldsa: *mut integer,
        info: *mut integer,
    );
    pub fn zla_gbamv_(
        trans: *mut integer,
        m: *mut integer,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        alpha: *mut f64,
        ab: *mut dcomplex,
        ldab: *mut integer,
        x: *mut dcomplex,
        incx: *mut integer,
        beta: *mut f64,
        y: *mut f64,
        incy: *mut integer,
    );
    pub fn zla_gbrfsx_extended_(
        prec_type: *mut integer,
        trans_type: *mut integer,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        nrhs: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        afb: *mut dcomplex,
        ldafb: *mut integer,
        ipiv: *mut integer,
        colequ: *mut logical,
        c: *mut f64,
        b: *mut dcomplex,
        ldb: *mut integer,
        y: *mut dcomplex,
        ldy: *mut integer,
        berr_out: *mut f64,
        n_norms: *mut integer,
        err_bnds_norm: *mut f64,
        err_bnds_comp: *mut f64,
        res: *mut dcomplex,
        ayb: *mut f64,
        dy: *mut dcomplex,
        y_tail: *mut dcomplex,
        rcond: *mut f64,
        ithresh: *mut integer,
        rthresh: *mut f64,
        dz_ub: *mut f64,
        ignore_cwise: *mut logical,
        info: *mut integer,
    );
    pub fn zla_geamv_(
        trans: *mut integer,
        m: *mut integer,
        n: *mut integer,
        alpha: *mut f64,
        a: *mut dcomplex,
        lda: *mut integer,
        x: *mut dcomplex,
        incx: *mut integer,
        beta: *mut f64,
        y: *mut f64,
        incy: *mut integer,
    );
    pub fn zla_gerfsx_extended_(
        prec_type: *mut integer,
        trans_type: *mut integer,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        af: *mut dcomplex,
        ldaf: *mut integer,
        ipiv: *mut integer,
        colequ: *mut logical,
        c: *mut f64,
        b: *mut dcomplex,
        ldb: *mut integer,
        y: *mut dcomplex,
        ldy: *mut integer,
        berr_out: *mut f64,
        n_norms: *mut integer,
        errs_n: *mut f64,
        errs_c: *mut f64,
        res: *mut dcomplex,
        ayb: *mut f64,
        dy: *mut dcomplex,
        y_tail: *mut dcomplex,
        rcond: *mut f64,
        ithresh: *mut integer,
        rthresh: *mut f64,
        dz_ub: *mut f64,
        ignore_cwise: *mut logical,
        info: *mut integer,
    );
    pub fn zlags2_(
        upper: *mut logical,
        a1: *mut f64,
        a2: *mut dcomplex,
        a3: *mut f64,
        b1: *mut f64,
        b2: *mut dcomplex,
        b3: *mut f64,
        csu: *mut f64,
        snu: *mut dcomplex,
        csv: *mut f64,
        snv: *mut dcomplex,
        csq: *mut f64,
        snq: *mut dcomplex,
    );
    pub fn zlagtm_(
        trans: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        alpha: *mut f64,
        dl: *mut dcomplex,
        d: *mut dcomplex,
        du: *mut dcomplex,
        x: *mut dcomplex,
        ldx: *mut integer,
        beta: *mut f64,
        b: *mut dcomplex,
        ldb: *mut integer,
    );
    pub fn zla_heamv_(
        uplo: *mut integer,
        n: *mut integer,
        alpha: *mut f64,
        a: *mut dcomplex,
        lda: *mut integer,
        x: *mut dcomplex,
        incx: *mut integer,
        beta: *mut f64,
        y: *mut f64,
        incy: *mut integer,
    );
    pub fn zlahef_aa_(
        uplo: *mut c_char,
        j1: *mut integer,
        m: *mut integer,
        nb: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        h: *mut dcomplex,
        ldh: *mut integer,
        work: *mut dcomplex,
    );
    pub fn zlahef_(
        uplo: *mut c_char,
        n: *mut integer,
        nb: *mut integer,
        kb: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        w: *mut dcomplex,
        ldw: *mut integer,
        info: *mut integer,
    );
    pub fn zlahef_rk_(
        uplo: *mut c_char,
        n: *mut integer,
        nb: *mut integer,
        kb: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        e: *mut dcomplex,
        ipiv: *mut integer,
        w: *mut dcomplex,
        ldw: *mut integer,
        info: *mut integer,
    );
    pub fn zlahef_rook_(
        uplo: *mut c_char,
        n: *mut integer,
        nb: *mut integer,
        kb: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        w: *mut dcomplex,
        ldw: *mut integer,
        info: *mut integer,
    );
    pub fn zla_herfsx_extended_(
        prec_type: *mut integer,
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        af: *mut dcomplex,
        ldaf: *mut integer,
        ipiv: *mut integer,
        colequ: *mut logical,
        c: *mut f64,
        b: *mut dcomplex,
        ldb: *mut integer,
        y: *mut dcomplex,
        ldy: *mut integer,
        berr_out: *mut f64,
        n_norms: *mut integer,
        err_bnds_norm: *mut f64,
        err_bnds_comp: *mut f64,
        res: *mut dcomplex,
        ayb: *mut f64,
        dy: *mut dcomplex,
        y_tail: *mut dcomplex,
        rcond: *mut f64,
        ithresh: *mut integer,
        rthresh: *mut f64,
        dz_ub: *mut f64,
        ignore_cwise: *mut logical,
        info: *mut integer,
    );
    pub fn zlahqr_(
        wantt: *mut logical,
        wantz: *mut logical,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        h: *mut dcomplex,
        ldh: *mut integer,
        w: *mut dcomplex,
        iloz: *mut integer,
        ihiz: *mut integer,
        z: *mut dcomplex,
        ldz: *mut integer,
        info: *mut integer,
    );
    pub fn zlahr2_(
        n: *mut integer,
        k: *mut integer,
        nb: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        tau: *mut dcomplex,
        t: *mut dcomplex,
        ldt: *mut integer,
        y: *mut dcomplex,
        ldy: *mut integer,
    );
    pub fn zlahrd_(
        n: *mut integer,
        k: *mut integer,
        nb: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        tau: *mut dcomplex,
        t: *mut dcomplex,
        ldt: *mut integer,
        y: *mut dcomplex,
        ldy: *mut integer,
    );
    pub fn zlaic1_(
        job: *mut integer,
        j: *mut integer,
        x: *mut dcomplex,
        sest: *mut f64,
        w: *mut dcomplex,
        gamma: *mut dcomplex,
        sestpr: *mut f64,
        s: *mut dcomplex,
        c__: *mut dcomplex,
    );
    pub fn zla_lin_berr_(
        n: *mut integer,
        nz: *mut integer,
        nrhs: *mut integer,
        res: *mut dcomplex,
        ayb: *mut f64,
        berr: *mut f64,
    );
    pub fn zlals0_(
        icompq: *mut integer,
        nl: *mut integer,
        nr: *mut integer,
        sqre: *mut integer,
        nrhs: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        bx: *mut dcomplex,
        ldbx: *mut integer,
        perm: *mut integer,
        givptr: *mut integer,
        givcol: *mut integer,
        ldgcol: *mut integer,
        givnum: *mut f64,
        ldgnum: *mut integer,
        poles: *mut f64,
        difl: *mut f64,
        difr: *mut f64,
        z: *mut f64,
        k: *mut integer,
        c: *mut f64,
        s: *mut f64,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zlalsa_(
        icompq: *mut integer,
        smlsiz: *mut integer,
        n: *mut integer,
        nrhs: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        bx: *mut dcomplex,
        ldbx: *mut integer,
        u: *mut f64,
        ldu: *mut integer,
        vt: *mut f64,
        k: *mut integer,
        difl: *mut f64,
        difr: *mut f64,
        z: *mut f64,
        poles: *mut f64,
        givptr: *mut integer,
        givcol: *mut integer,
        ldgcol: *mut integer,
        perm: *mut integer,
        givnum: *mut f64,
        c: *mut f64,
        s: *mut f64,
        rwork: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn zlalsd_(
        uplo: *mut c_char,
        smlsiz: *mut integer,
        n: *mut integer,
        nrhs: *mut integer,
        d: *mut f64,
        e: *mut f64,
        b: *mut dcomplex,
        ldb: *mut integer,
        rcond: *mut f64,
        rank: *mut integer,
        work: *mut dcomplex,
        rwork: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn zlamswlq_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        mb: *mut integer,
        nb: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        t: *mut dcomplex,
        ldt: *mut integer,
        c: *mut dcomplex,
        ldc: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zlamtsqr_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        mb: *mut integer,
        nb: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        t: *mut dcomplex,
        ldt: *mut integer,
        c: *mut dcomplex,
        ldc: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zlapll_(
        n: *mut integer,
        x: *mut dcomplex,
        incx: *mut integer,
        y: *mut dcomplex,
        incy: *mut integer,
        ssmin: *mut f64,
    );
    pub fn zlapmr_(
        forwrd: *mut logical,
        m: *mut integer,
        n: *mut integer,
        x: *mut dcomplex,
        ldx: *mut integer,
        k: *mut integer,
    );
    pub fn zlapmt_(
        forwrd: *mut logical,
        m: *mut integer,
        n: *mut integer,
        x: *mut dcomplex,
        ldx: *mut integer,
        k: *mut integer,
    );
    pub fn zla_porfsx_extended_(
        prec_type: *mut integer,
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        af: *mut dcomplex,
        ldaf: *mut integer,
        colequ: *mut logical,
        c: *mut f64,
        b: *mut dcomplex,
        ldb: *mut integer,
        y: *mut dcomplex,
        ldy: *mut integer,
        berr_out: *mut f64,
        n_norms: *mut integer,
        err_bnds_norm: *mut f64,
        err_bnds_comp: *mut f64,
        res: *mut dcomplex,
        ayb: *mut f64,
        dy: *mut dcomplex,
        y_tail: *mut dcomplex,
        rcond: *mut f64,
        ithresh: *mut integer,
        rthresh: *mut f64,
        dz_ub: *mut f64,
        ignore_cwise: *mut logical,
        info: *mut integer,
    );
    pub fn zlaqgb_(
        m: *mut integer,
        n: *mut integer,
        kl: *mut integer,
        ku: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        r: *mut f64,
        c: *mut f64,
        rowcnd: *mut f64,
        colcnd: *mut f64,
        amax: *mut f64,
        equed: *mut c_char,
    );
    pub fn zlaqge_(
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        r: *mut f64,
        c: *mut f64,
        rowcnd: *mut f64,
        colcnd: *mut f64,
        amax: *mut f64,
        equed: *mut c_char,
    );
    pub fn zlaqhb_(
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        s: *mut f64,
        scond: *mut f64,
        amax: *mut f64,
        equed: *mut c_char,
    );
    pub fn zlaqhe_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        s: *mut f64,
        scond: *mut f64,
        amax: *mut f64,
        equed: *mut c_char,
    );
    pub fn zlaqhp_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut dcomplex,
        s: *mut f64,
        scond: *mut f64,
        amax: *mut f64,
        equed: *mut c_char,
    );
    pub fn zlaqp2_(
        m: *mut integer,
        n: *mut integer,
        offset: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        jpvt: *mut integer,
        tau: *mut dcomplex,
        vn1: *mut f64,
        vn2: *mut f64,
        work: *mut dcomplex,
    );
    pub fn zlaqps_(
        m: *mut integer,
        n: *mut integer,
        offset: *mut integer,
        nb: *mut integer,
        kb: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        jpvt: *mut integer,
        tau: *mut dcomplex,
        vn1: *mut f64,
        vn2: *mut f64,
        auxv: *mut dcomplex,
        f: *mut dcomplex,
        ldf: *mut integer,
    );
    pub fn zlaqr0_(
        wantt: *mut logical,
        wantz: *mut logical,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        h: *mut dcomplex,
        ldh: *mut integer,
        w: *mut dcomplex,
        iloz: *mut integer,
        ihiz: *mut integer,
        z: *mut dcomplex,
        ldz: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zlaqr1_(
        n: *mut integer,
        h: *mut dcomplex,
        ldh: *mut integer,
        s1: *mut dcomplex,
        s2: *mut dcomplex,
        v: *mut dcomplex,
    );
    pub fn zlaqr2_(
        wantt: *mut logical,
        wantz: *mut logical,
        n: *mut integer,
        ktop: *mut integer,
        kbot: *mut integer,
        nw: *mut integer,
        h: *mut dcomplex,
        ldh: *mut integer,
        iloz: *mut integer,
        ihiz: *mut integer,
        z: *mut dcomplex,
        ldz: *mut integer,
        ns: *mut integer,
        nd: *mut integer,
        sh: *mut dcomplex,
        v: *mut dcomplex,
        ldv: *mut integer,
        nh: *mut integer,
        t: *mut dcomplex,
        ldt: *mut integer,
        nv: *mut integer,
        wv: *mut dcomplex,
        ldwv: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
    );
    pub fn zlaqr3_(
        wantt: *mut logical,
        wantz: *mut logical,
        n: *mut integer,
        ktop: *mut integer,
        kbot: *mut integer,
        nw: *mut integer,
        h: *mut dcomplex,
        ldh: *mut integer,
        iloz: *mut integer,
        ihiz: *mut integer,
        z: *mut dcomplex,
        ldz: *mut integer,
        ns: *mut integer,
        nd: *mut integer,
        sh: *mut dcomplex,
        v: *mut dcomplex,
        ldv: *mut integer,
        nh: *mut integer,
        t: *mut dcomplex,
        ldt: *mut integer,
        nv: *mut integer,
        wv: *mut dcomplex,
        ldwv: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
    );
    pub fn zlaqr4_(
        wantt: *mut logical,
        wantz: *mut logical,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        h: *mut dcomplex,
        ldh: *mut integer,
        w: *mut dcomplex,
        iloz: *mut integer,
        ihiz: *mut integer,
        z: *mut dcomplex,
        ldz: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zlaqr5_(
        wantt: *mut logical,
        wantz: *mut logical,
        kacc22: *mut integer,
        n: *mut integer,
        ktop: *mut integer,
        kbot: *mut integer,
        nshfts: *mut integer,
        s: *mut dcomplex,
        h: *mut dcomplex,
        ldh: *mut integer,
        iloz: *mut integer,
        ihiz: *mut integer,
        z: *mut dcomplex,
        ldz: *mut integer,
        v: *mut dcomplex,
        ldv: *mut integer,
        u: *mut dcomplex,
        ldu: *mut integer,
        nv: *mut integer,
        wv: *mut dcomplex,
        ldwv: *mut integer,
        nh: *mut integer,
        wh: *mut dcomplex,
        ldwh: *mut integer,
    );
    pub fn zlaqsb_(
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        s: *mut f64,
        scond: *mut f64,
        amax: *mut f64,
        equed: *mut c_char,
    );
    pub fn zlaqsp_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut dcomplex,
        s: *mut f64,
        scond: *mut f64,
        amax: *mut f64,
        equed: *mut c_char,
    );
    pub fn zlaqsy_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        s: *mut f64,
        scond: *mut f64,
        amax: *mut f64,
        equed: *mut c_char,
    );
    pub fn zlar1v_(
        n: *mut integer,
        b1: *mut integer,
        bn: *mut integer,
        lambda: *mut f64,
        d: *mut f64,
        l: *mut f64,
        ld: *mut f64,
        lld: *mut f64,
        pivmin: *mut f64,
        gaptol: *mut f64,
        z: *mut dcomplex,
        wantnc: *mut logical,
        negcnt: *mut integer,
        ztz: *mut f64,
        mingma: *mut f64,
        r: *mut integer,
        isuppz: *mut integer,
        nrminv: *mut f64,
        resid: *mut f64,
        rqcorr: *mut f64,
        work: *mut f64,
    );
    pub fn zlar2v_(
        n: *mut integer,
        x: *mut dcomplex,
        y: *mut dcomplex,
        z: *mut dcomplex,
        incx: *mut integer,
        c: *mut f64,
        s: *mut dcomplex,
        incc: *mut integer,
    );
    pub fn zlarcm_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        c: *mut dcomplex,
        ldc: *mut integer,
        rwork: *mut f64,
    );
    pub fn zlarfb_(
        side: *mut c_char,
        trans: *mut c_char,
        direct: *mut c_char,
        storev: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        v: *mut dcomplex,
        ldv: *mut integer,
        t: *mut dcomplex,
        ldt: *mut integer,
        c: *mut dcomplex,
        ldc: *mut integer,
        work: *mut dcomplex,
        ldwork: *mut integer,
    );
    pub fn zlarf_(
        side: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        v: *mut dcomplex,
        incv: *mut integer,
        tau: *mut dcomplex,
        c: *mut dcomplex,
        ldc: *mut integer,
        work: *mut dcomplex,
    );
    pub fn zlarfg_(
        n: *mut integer,
        alpha: *mut dcomplex,
        x: *mut dcomplex,
        incx: *mut integer,
        tau: *mut dcomplex,
    );
    pub fn zlarfgp_(
        n: *mut integer,
        alpha: *mut dcomplex,
        x: *mut dcomplex,
        incx: *mut integer,
        tau: *mut dcomplex,
    );
    pub fn zlarft_(
        direct: *mut c_char,
        storev: *mut c_char,
        n: *mut integer,
        k: *mut integer,
        v: *mut dcomplex,
        ldv: *mut integer,
        tau: *mut dcomplex,
        t: *mut dcomplex,
        ldt: *mut integer,
    );
    pub fn zlarfx_(
        side: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        v: *mut dcomplex,
        tau: *mut dcomplex,
        c: *mut dcomplex,
        ldc: *mut integer,
        work: *mut dcomplex,
    );
    pub fn zlarfy_(
        uplo: *mut c_char,
        n: *mut integer,
        v: *mut dcomplex,
        incv: *mut integer,
        tau: *mut dcomplex,
        c: *mut dcomplex,
        ldc: *mut integer,
        work: *mut dcomplex,
    );
    pub fn zlargv_(
        n: *mut integer,
        x: *mut dcomplex,
        incx: *mut integer,
        y: *mut dcomplex,
        incy: *mut integer,
        c: *mut f64,
        incc: *mut integer,
    );
    pub fn zlarnv_(idist: *mut integer, iseed: *mut integer, n: *mut integer, x: *mut dcomplex);
    pub fn zlarrv_(
        n: *mut integer,
        vl: *mut f64,
        vu: *mut f64,
        d: *mut f64,
        l: *mut f64,
        pivmin: *mut f64,
        isplit: *mut integer,
        m: *mut integer,
        dol: *mut integer,
        dou: *mut integer,
        minrgp: *mut f64,
        rtol1: *mut f64,
        rtol2: *mut f64,
        w: *mut f64,
        werr: *mut f64,
        wgap: *mut f64,
        iblock: *mut integer,
        indexw: *mut integer,
        gers: *mut f64,
        z: *mut dcomplex,
        ldz: *mut integer,
        isuppz: *mut integer,
        work: *mut f64,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn zlarscl2_(
        m: *mut integer,
        n: *mut integer,
        d: *mut f64,
        x: *mut dcomplex,
        ldx: *mut integer,
    );
    pub fn zlartg_(
        f: *mut dcomplex,
        g: *mut dcomplex,
        cs: *mut f64,
        sn: *mut dcomplex,
        r__: *mut dcomplex,
    );
    pub fn zlartv_(
        n: *mut integer,
        x: *mut dcomplex,
        incx: *mut integer,
        y: *mut dcomplex,
        incy: *mut integer,
        c: *mut f64,
        s: *mut dcomplex,
        incc: *mut integer,
    );
    pub fn zlarzb_(
        side: *mut c_char,
        trans: *mut c_char,
        direct: *mut c_char,
        storev: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        l: *mut integer,
        v: *mut dcomplex,
        ldv: *mut integer,
        t: *mut dcomplex,
        ldt: *mut integer,
        c: *mut dcomplex,
        ldc: *mut integer,
        work: *mut dcomplex,
        ldwork: *mut integer,
    );
    pub fn zlarz_(
        side: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        l: *mut integer,
        v: *mut dcomplex,
        incv: *mut integer,
        tau: *mut dcomplex,
        c: *mut dcomplex,
        ldc: *mut integer,
        work: *mut dcomplex,
    );
    pub fn zlarzt_(
        direct: *mut c_char,
        storev: *mut c_char,
        n: *mut integer,
        k: *mut integer,
        v: *mut dcomplex,
        ldv: *mut integer,
        tau: *mut dcomplex,
        t: *mut dcomplex,
        ldt: *mut integer,
    );
    pub fn zlascl2_(
        m: *mut integer,
        n: *mut integer,
        d: *mut f64,
        x: *mut dcomplex,
        ldx: *mut integer,
    );
    pub fn zlascl_(
        type_: *mut c_char,
        kl: *mut integer,
        ku: *mut integer,
        cfrom: *mut f64,
        cto: *mut f64,
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn zlaset_(
        uplo: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        alpha: *mut dcomplex,
        beta: *mut dcomplex,
        a: *mut dcomplex,
        lda: *mut integer,
    );
    pub fn zlasr_(
        side: *mut c_char,
        pivot: *mut c_char,
        direct: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        c: *mut f64,
        s: *mut f64,
        a: *mut dcomplex,
        lda: *mut integer,
    );
    pub fn zlassq_(
        n: *mut integer,
        x: *mut dcomplex,
        incx: *mut integer,
        scale: *mut f64,
        sumsq: *mut f64,
    );
    pub fn zlaswlq_(
        m: *mut integer,
        n: *mut integer,
        mb: *mut integer,
        nb: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        t: *mut dcomplex,
        ldt: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zlaswp_(
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        k1: *mut integer,
        k2: *mut integer,
        ipiv: *mut integer,
        incx: *mut integer,
    );
    pub fn zla_syamv_(
        uplo: *mut integer,
        n: *mut integer,
        alpha: *mut f64,
        a: *mut dcomplex,
        lda: *mut integer,
        x: *mut dcomplex,
        incx: *mut integer,
        beta: *mut f64,
        y: *mut f64,
        incy: *mut integer,
    );
    pub fn zlasyf_aa_(
        uplo: *mut c_char,
        j1: *mut integer,
        m: *mut integer,
        nb: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        h: *mut dcomplex,
        ldh: *mut integer,
        work: *mut dcomplex,
    );
    pub fn zlasyf_(
        uplo: *mut c_char,
        n: *mut integer,
        nb: *mut integer,
        kb: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        w: *mut dcomplex,
        ldw: *mut integer,
        info: *mut integer,
    );
    pub fn zlasyf_rk_(
        uplo: *mut c_char,
        n: *mut integer,
        nb: *mut integer,
        kb: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        e: *mut dcomplex,
        ipiv: *mut integer,
        w: *mut dcomplex,
        ldw: *mut integer,
        info: *mut integer,
    );
    pub fn zlasyf_rook_(
        uplo: *mut c_char,
        n: *mut integer,
        nb: *mut integer,
        kb: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        w: *mut dcomplex,
        ldw: *mut integer,
        info: *mut integer,
    );
    pub fn zla_syrfsx_extended_(
        prec_type: *mut integer,
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        af: *mut dcomplex,
        ldaf: *mut integer,
        ipiv: *mut integer,
        colequ: *mut logical,
        c: *mut f64,
        b: *mut dcomplex,
        ldb: *mut integer,
        y: *mut dcomplex,
        ldy: *mut integer,
        berr_out: *mut f64,
        n_norms: *mut integer,
        err_bnds_norm: *mut f64,
        err_bnds_comp: *mut f64,
        res: *mut dcomplex,
        ayb: *mut f64,
        dy: *mut dcomplex,
        y_tail: *mut dcomplex,
        rcond: *mut f64,
        ithresh: *mut integer,
        rthresh: *mut f64,
        dz_ub: *mut f64,
        ignore_cwise: *mut logical,
        info: *mut integer,
    );
    pub fn zlat2c_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        sa: *mut scomplex,
        ldsa: *mut integer,
        info: *mut integer,
    );
    pub fn zlatbs_(
        uplo: *mut c_char,
        trans: *mut c_char,
        diag: *mut c_char,
        normin: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        x: *mut dcomplex,
        scale: *mut f64,
        cnorm: *mut f64,
        info: *mut integer,
    );
    pub fn zlatdf_(
        ijob: *mut integer,
        n: *mut integer,
        z: *mut dcomplex,
        ldz: *mut integer,
        rhs: *mut dcomplex,
        rdsum: *mut f64,
        rdscal: *mut f64,
        ipiv: *mut integer,
        jpiv: *mut integer,
    );
    pub fn zlatps_(
        uplo: *mut c_char,
        trans: *mut c_char,
        diag: *mut c_char,
        normin: *mut c_char,
        n: *mut integer,
        ap: *mut dcomplex,
        x: *mut dcomplex,
        scale: *mut f64,
        cnorm: *mut f64,
        info: *mut integer,
    );
    pub fn zlatrd_(
        uplo: *mut c_char,
        n: *mut integer,
        nb: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        e: *mut f64,
        tau: *mut dcomplex,
        w: *mut dcomplex,
        ldw: *mut integer,
    );
    pub fn zlatrs_(
        uplo: *mut c_char,
        trans: *mut c_char,
        diag: *mut c_char,
        normin: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        x: *mut dcomplex,
        scale: *mut f64,
        cnorm: *mut f64,
        info: *mut integer,
    );
    pub fn zlatrz_(
        m: *mut integer,
        n: *mut integer,
        l: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        tau: *mut dcomplex,
        work: *mut dcomplex,
    );
    pub fn zlatsqr_(
        m: *mut integer,
        n: *mut integer,
        mb: *mut integer,
        nb: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        t: *mut dcomplex,
        ldt: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zlatzm_(
        side: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        v: *mut dcomplex,
        incv: *mut integer,
        tau: *mut dcomplex,
        c1: *mut dcomplex,
        c2: *mut dcomplex,
        ldc: *mut integer,
        work: *mut dcomplex,
    );
    pub fn zlaunhr_col_getrfnp2_(
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        d: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zlaunhr_col_getrfnp_(
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        d: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zlauu2_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn zlauum_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn zla_wwaddw_(n: *mut integer, x: *mut dcomplex, y: *mut dcomplex, w: *mut dcomplex);
    pub fn zpbcon_(
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        anorm: *mut f64,
        rcond: *mut f64,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zpbequ_(
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        s: *mut f64,
        scond: *mut f64,
        amax: *mut f64,
        info: *mut integer,
    );
    pub fn zpbrfs_(
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        nrhs: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        afb: *mut dcomplex,
        ldafb: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        x: *mut dcomplex,
        ldx: *mut integer,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zpbstf_(
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        info: *mut integer,
    );
    pub fn zpbsv_(
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        nrhs: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn zpbsvx_(
        fact: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        nrhs: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        afb: *mut dcomplex,
        ldafb: *mut integer,
        equed: *mut c_char,
        s: *mut f64,
        b: *mut dcomplex,
        ldb: *mut integer,
        x: *mut dcomplex,
        ldx: *mut integer,
        rcond: *mut f64,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zpbtf2_(
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        info: *mut integer,
    );
    pub fn zpbtrf_(
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        info: *mut integer,
    );
    pub fn zpbtrs_(
        uplo: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        nrhs: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn zpftrf_(
        transr: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zpftri_(
        transr: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zpftrs_(
        transr: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        b: *mut dcomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn zpocon_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        anorm: *mut f64,
        rcond: *mut f64,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zpoequb_(
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        s: *mut f64,
        scond: *mut f64,
        amax: *mut f64,
        info: *mut integer,
    );
    pub fn zpoequ_(
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        s: *mut f64,
        scond: *mut f64,
        amax: *mut f64,
        info: *mut integer,
    );
    pub fn zporfs_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        af: *mut dcomplex,
        ldaf: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        x: *mut dcomplex,
        ldx: *mut integer,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zporfsx_(
        uplo: *mut c_char,
        equed: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        af: *mut dcomplex,
        ldaf: *mut integer,
        s: *mut f64,
        b: *mut dcomplex,
        ldb: *mut integer,
        x: *mut dcomplex,
        ldx: *mut integer,
        rcond: *mut f64,
        berr: *mut f64,
        n_err_bnds: *mut integer,
        err_bnds_norm: *mut f64,
        err_bnds_comp: *mut f64,
        nparams: *mut integer,
        params: *mut f64,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zposv_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn zposvx_(
        fact: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        af: *mut dcomplex,
        ldaf: *mut integer,
        equed: *mut c_char,
        s: *mut f64,
        b: *mut dcomplex,
        ldb: *mut integer,
        x: *mut dcomplex,
        ldx: *mut integer,
        rcond: *mut f64,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zposvxx_(
        fact: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        af: *mut dcomplex,
        ldaf: *mut integer,
        equed: *mut c_char,
        s: *mut f64,
        b: *mut dcomplex,
        ldb: *mut integer,
        x: *mut dcomplex,
        ldx: *mut integer,
        rcond: *mut f64,
        rpvgrw: *mut f64,
        berr: *mut f64,
        n_err_bnds: *mut integer,
        err_bnds_norm: *mut f64,
        err_bnds_comp: *mut f64,
        nparams: *mut integer,
        params: *mut f64,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zpotf2_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn zpotrf2_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn zpotrf_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn zpotri_(
        uplo: *mut c_char,
        n: *mut integer,
        buff_A: *mut dcomplex,
        ldim_A: *mut integer,
        info: *mut integer,
    );
    pub fn zpotrs_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn zppcon_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut dcomplex,
        anorm: *mut f64,
        rcond: *mut f64,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zppequ_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut dcomplex,
        s: *mut f64,
        scond: *mut f64,
        amax: *mut f64,
        info: *mut integer,
    );
    pub fn zpprfs_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut dcomplex,
        afp: *mut dcomplex,
        b: *mut dcomplex,
        ldb: *mut integer,
        x: *mut dcomplex,
        ldx: *mut integer,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zppsv_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut dcomplex,
        b: *mut dcomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn zppsvx_(
        fact: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut dcomplex,
        afp: *mut dcomplex,
        equed: *mut c_char,
        s: *mut f64,
        b: *mut dcomplex,
        ldb: *mut integer,
        x: *mut dcomplex,
        ldx: *mut integer,
        rcond: *mut f64,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zpptrf_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zpptri_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zpptrs_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut dcomplex,
        b: *mut dcomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn zpstf2_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        piv: *mut integer,
        rank: *mut integer,
        tol: *mut f64,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn zpstrf_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        piv: *mut integer,
        rank: *mut integer,
        tol: *mut f64,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn zptcon_(
        n: *mut integer,
        d: *mut f64,
        e: *mut dcomplex,
        anorm: *mut f64,
        rcond: *mut f64,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zpteqr_(
        compz: *mut c_char,
        n: *mut integer,
        d: *mut f64,
        e: *mut f64,
        z: *mut dcomplex,
        ldz: *mut integer,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn zptrfs_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        d: *mut f64,
        e: *mut dcomplex,
        df: *mut f64,
        ef: *mut dcomplex,
        b: *mut dcomplex,
        ldb: *mut integer,
        x: *mut dcomplex,
        ldx: *mut integer,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zptsv_(
        n: *mut integer,
        nrhs: *mut integer,
        d: *mut f64,
        e: *mut dcomplex,
        b: *mut dcomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn zptsvx_(
        fact: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        d: *mut f64,
        e: *mut dcomplex,
        df: *mut f64,
        ef: *mut dcomplex,
        b: *mut dcomplex,
        ldb: *mut integer,
        x: *mut dcomplex,
        ldx: *mut integer,
        rcond: *mut f64,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zpttrf_(n: *mut integer, d: *mut f64, e: *mut dcomplex, info: *mut integer);
    pub fn zpttrs_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        d: *mut f64,
        e: *mut dcomplex,
        b: *mut dcomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn zptts2_(
        iuplo: *mut integer,
        n: *mut integer,
        nrhs: *mut integer,
        d: *mut f64,
        e: *mut dcomplex,
        b: *mut dcomplex,
        ldb: *mut integer,
    );
    pub fn zrot_(
        n: *mut integer,
        cx: *mut dcomplex,
        incx: *mut integer,
        cy: *mut dcomplex,
        incy: *mut integer,
        c: *mut f64,
        s: *mut dcomplex,
    );
    pub fn zspcon_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut dcomplex,
        ipiv: *mut integer,
        anorm: *mut f64,
        rcond: *mut f64,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zspmv_(
        uplo: *mut c_char,
        n: *mut integer,
        alpha: *mut dcomplex,
        ap: *mut dcomplex,
        x: *mut dcomplex,
        incx: *mut integer,
        beta: *mut dcomplex,
        y: *mut dcomplex,
        incy: *mut integer,
    );
    pub fn zspr_(
        uplo: *mut c_char,
        n: *mut integer,
        alpha: *mut dcomplex,
        x: *mut dcomplex,
        incx: *mut integer,
        ap: *mut dcomplex,
    );
    pub fn zsprfs_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut dcomplex,
        afp: *mut dcomplex,
        ipiv: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        x: *mut dcomplex,
        ldx: *mut integer,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zspsv_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut dcomplex,
        ipiv: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn zspsvx_(
        fact: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut dcomplex,
        afp: *mut dcomplex,
        ipiv: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        x: *mut dcomplex,
        ldx: *mut integer,
        rcond: *mut f64,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zsptrf_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut dcomplex,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn zsptri_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut dcomplex,
        ipiv: *mut integer,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zsptrs_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut dcomplex,
        ipiv: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn zstedc_(
        compz: *mut c_char,
        n: *mut integer,
        d: *mut f64,
        e: *mut f64,
        z: *mut dcomplex,
        ldz: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        lrwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn zstegr_(
        jobz: *mut c_char,
        range: *mut c_char,
        n: *mut integer,
        d: *mut f64,
        e: *mut f64,
        vl: *mut f64,
        vu: *mut f64,
        il: *mut integer,
        iu: *mut integer,
        abstol: *mut f64,
        m: *mut integer,
        w: *mut f64,
        z: *mut dcomplex,
        ldz: *mut integer,
        isuppz: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn zstein_(
        n: *mut integer,
        d: *mut f64,
        e: *mut f64,
        m: *mut integer,
        w: *mut f64,
        iblock: *mut integer,
        isplit: *mut integer,
        z: *mut dcomplex,
        ldz: *mut integer,
        work: *mut f64,
        iwork: *mut integer,
        ifail: *mut integer,
        info: *mut integer,
    );
    pub fn zstemr_(
        jobz: *mut c_char,
        range: *mut c_char,
        n: *mut integer,
        d: *mut f64,
        e: *mut f64,
        vl: *mut f64,
        vu: *mut f64,
        il: *mut integer,
        iu: *mut integer,
        m: *mut integer,
        w: *mut f64,
        z: *mut dcomplex,
        ldz: *mut integer,
        nzc: *mut integer,
        isuppz: *mut integer,
        tryrac: *mut logical,
        work: *mut f64,
        lwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn zsteqr_(
        compz: *mut c_char,
        n: *mut integer,
        d: *mut f64,
        e: *mut f64,
        z: *mut dcomplex,
        ldz: *mut integer,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn zsycon_3_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        e: *mut dcomplex,
        ipiv: *mut integer,
        anorm: *mut f64,
        rcond: *mut f64,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zsycon_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        anorm: *mut f64,
        rcond: *mut f64,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zsycon_rook_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        anorm: *mut f64,
        rcond: *mut f64,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zsyconv_(
        uplo: *mut c_char,
        way: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zsyconvf_(
        uplo: *mut c_char,
        way: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        e: *mut dcomplex,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn zsyconvf_rook_(
        uplo: *mut c_char,
        way: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        e: *mut dcomplex,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn zsyequb_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        s: *mut f64,
        scond: *mut f64,
        amax: *mut f64,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zsymv_(
        uplo: *mut c_char,
        n: *mut integer,
        alpha: *mut dcomplex,
        a: *mut dcomplex,
        lda: *mut integer,
        x: *mut dcomplex,
        incx: *mut integer,
        beta: *mut dcomplex,
        y: *mut dcomplex,
        incy: *mut integer,
    );
    pub fn zsyr_(
        uplo: *mut c_char,
        n: *mut integer,
        alpha: *mut dcomplex,
        x: *mut dcomplex,
        incx: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
    );
    pub fn zsyrfs_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        af: *mut dcomplex,
        ldaf: *mut integer,
        ipiv: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        x: *mut dcomplex,
        ldx: *mut integer,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zsyrfsx_(
        uplo: *mut c_char,
        equed: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        af: *mut dcomplex,
        ldaf: *mut integer,
        ipiv: *mut integer,
        s: *mut f64,
        b: *mut dcomplex,
        ldb: *mut integer,
        x: *mut dcomplex,
        ldx: *mut integer,
        rcond: *mut f64,
        berr: *mut f64,
        n_err_bnds: *mut integer,
        err_bnds_norm: *mut f64,
        err_bnds_comp: *mut f64,
        nparams: *mut integer,
        params: *mut f64,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zsysv_aa_2stage_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        tb: *mut dcomplex,
        ltb: *mut integer,
        ipiv: *mut integer,
        ipiv2: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zsysv_aa_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zsysv_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zsysv_rk_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        e: *mut dcomplex,
        ipiv: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zsysv_rook_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zsysvx_(
        fact: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        af: *mut dcomplex,
        ldaf: *mut integer,
        ipiv: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        x: *mut dcomplex,
        ldx: *mut integer,
        rcond: *mut f64,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zsysvxx_(
        fact: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        af: *mut dcomplex,
        ldaf: *mut integer,
        ipiv: *mut integer,
        equed: *mut c_char,
        s: *mut f64,
        b: *mut dcomplex,
        ldb: *mut integer,
        x: *mut dcomplex,
        ldx: *mut integer,
        rcond: *mut f64,
        rpvgrw: *mut f64,
        berr: *mut f64,
        n_err_bnds: *mut integer,
        err_bnds_norm: *mut f64,
        err_bnds_comp: *mut f64,
        nparams: *mut integer,
        params: *mut f64,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn zsyswapr_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        i1: *mut integer,
        i2: *mut integer,
    );
    pub fn zsytf2_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn zsytf2_rk_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        e: *mut dcomplex,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn zsytf2_rook_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        info: *mut integer,
    );
    pub fn zsytrf_aa_2stage_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        tb: *mut dcomplex,
        ltb: *mut integer,
        ipiv: *mut integer,
        ipiv2: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zsytrf_aa_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zsytrf_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zsytrf_rk_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        e: *mut dcomplex,
        ipiv: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zsytrf_rook_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zsytri2_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zsytri2x_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut dcomplex,
        nb: *mut integer,
        info: *mut integer,
    );
    pub fn zsytri_3_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        e: *mut dcomplex,
        ipiv: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zsytri_3x_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        e: *mut dcomplex,
        ipiv: *mut integer,
        work: *mut dcomplex,
        nb: *mut integer,
        info: *mut integer,
    );
    pub fn zsytri_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zsytri_rook_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zsytrs2_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zsytrs_3_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        e: *mut dcomplex,
        ipiv: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn zsytrs_aa_2stage_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        tb: *mut dcomplex,
        ltb: *mut integer,
        ipiv: *mut integer,
        ipiv2: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn zsytrs_aa_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zsytrs_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn zsytrs_rook_(
        uplo: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ipiv: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn ztbcon_(
        norm: *mut c_char,
        uplo: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        rcond: *mut f64,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn ztbrfs_(
        uplo: *mut c_char,
        trans: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        nrhs: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        x: *mut dcomplex,
        ldx: *mut integer,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn ztbtrs_(
        uplo: *mut c_char,
        trans: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        kd: *mut integer,
        nrhs: *mut integer,
        ab: *mut dcomplex,
        ldab: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn ztfsm_(
        transr: *mut c_char,
        side: *mut c_char,
        uplo: *mut c_char,
        trans: *mut c_char,
        diag: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        alpha: *mut dcomplex,
        a: *mut dcomplex,
        b: *mut dcomplex,
        ldb: *mut integer,
    );
    pub fn ztftri_(
        transr: *mut c_char,
        uplo: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        info: *mut integer,
    );
    pub fn ztfttp_(
        transr: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        arf: *mut dcomplex,
        ap: *mut dcomplex,
        info: *mut integer,
    );
    pub fn ztfttr_(
        transr: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        arf: *mut dcomplex,
        a: *mut dcomplex,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn ztgevc_(
        side: *mut c_char,
        howmny: *mut c_char,
        select: *mut logical,
        n: *mut integer,
        s: *mut dcomplex,
        lds: *mut integer,
        p: *mut dcomplex,
        ldp: *mut integer,
        vl: *mut dcomplex,
        ldvl: *mut integer,
        vr: *mut dcomplex,
        ldvr: *mut integer,
        mm: *mut integer,
        m: *mut integer,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn ztgex2_(
        wantq: *mut logical,
        wantz: *mut logical,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        q: *mut dcomplex,
        ldq: *mut integer,
        z: *mut dcomplex,
        ldz: *mut integer,
        j1: *mut integer,
        info: *mut integer,
    );
    pub fn ztgexc_(
        wantq: *mut logical,
        wantz: *mut logical,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        q: *mut dcomplex,
        ldq: *mut integer,
        z: *mut dcomplex,
        ldz: *mut integer,
        ifst: *mut integer,
        ilst: *mut integer,
        info: *mut integer,
    );
    pub fn ztgsen_(
        ijob: *mut integer,
        wantq: *mut logical,
        wantz: *mut logical,
        select: *mut logical,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        alpha: *mut dcomplex,
        beta: *mut dcomplex,
        q: *mut dcomplex,
        ldq: *mut integer,
        z: *mut dcomplex,
        ldz: *mut integer,
        m: *mut integer,
        pl: *mut f64,
        pr: *mut f64,
        dif: *mut f64,
        work: *mut dcomplex,
        lwork: *mut integer,
        iwork: *mut integer,
        liwork: *mut integer,
        info: *mut integer,
    );
    pub fn ztgsja_(
        jobu: *mut c_char,
        jobv: *mut c_char,
        jobq: *mut c_char,
        m: *mut integer,
        p: *mut integer,
        n: *mut integer,
        k: *mut integer,
        l: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        tola: *mut f64,
        tolb: *mut f64,
        alpha: *mut f64,
        beta: *mut f64,
        u: *mut dcomplex,
        ldu: *mut integer,
        v: *mut dcomplex,
        ldv: *mut integer,
        q: *mut dcomplex,
        ldq: *mut integer,
        work: *mut dcomplex,
        ncycle: *mut integer,
        info: *mut integer,
    );
    pub fn ztgsna_(
        job: *mut c_char,
        howmny: *mut c_char,
        select: *mut logical,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        vl: *mut dcomplex,
        ldvl: *mut integer,
        vr: *mut dcomplex,
        ldvr: *mut integer,
        s: *mut f64,
        dif: *mut f64,
        mm: *mut integer,
        m: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn ztgsy2_(
        trans: *mut c_char,
        ijob: *mut integer,
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        c: *mut dcomplex,
        ldc: *mut integer,
        d: *mut dcomplex,
        ldd: *mut integer,
        e: *mut dcomplex,
        lde: *mut integer,
        f: *mut dcomplex,
        ldf: *mut integer,
        scale: *mut f64,
        rdsum: *mut f64,
        rdscal: *mut f64,
        info: *mut integer,
    );
    pub fn ztgsyl_(
        trans: *mut c_char,
        ijob: *mut integer,
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        c: *mut dcomplex,
        ldc: *mut integer,
        d: *mut dcomplex,
        ldd: *mut integer,
        e: *mut dcomplex,
        lde: *mut integer,
        f: *mut dcomplex,
        ldf: *mut integer,
        scale: *mut f64,
        dif: *mut f64,
        work: *mut dcomplex,
        lwork: *mut integer,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn ztpcon_(
        norm: *mut c_char,
        uplo: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        ap: *mut dcomplex,
        rcond: *mut f64,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn ztplqt2_(
        m: *mut integer,
        n: *mut integer,
        l: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        t: *mut dcomplex,
        ldt: *mut integer,
        info: *mut integer,
    );
    pub fn ztplqt_(
        m: *mut integer,
        n: *mut integer,
        l: *mut integer,
        mb: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        t: *mut dcomplex,
        ldt: *mut integer,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn ztpmlqt_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        l: *mut integer,
        mb: *mut integer,
        v: *mut dcomplex,
        ldv: *mut integer,
        t: *mut dcomplex,
        ldt: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn ztpmqrt_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        l: *mut integer,
        nb: *mut integer,
        v: *mut dcomplex,
        ldv: *mut integer,
        t: *mut dcomplex,
        ldt: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn ztpqrt2_(
        m: *mut integer,
        n: *mut integer,
        l: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        t: *mut dcomplex,
        ldt: *mut integer,
        info: *mut integer,
    );
    pub fn ztpqrt_(
        m: *mut integer,
        n: *mut integer,
        l: *mut integer,
        nb: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        t: *mut dcomplex,
        ldt: *mut integer,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn ztprfb_(
        side: *mut c_char,
        trans: *mut c_char,
        direct: *mut c_char,
        storev: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        l: *mut integer,
        v: *mut dcomplex,
        ldv: *mut integer,
        t: *mut dcomplex,
        ldt: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        work: *mut dcomplex,
        ldwork: *mut integer,
    );
    pub fn ztprfs_(
        uplo: *mut c_char,
        trans: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut dcomplex,
        b: *mut dcomplex,
        ldb: *mut integer,
        x: *mut dcomplex,
        ldx: *mut integer,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn ztptri_(
        uplo: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        ap: *mut dcomplex,
        info: *mut integer,
    );
    pub fn ztptrs_(
        uplo: *mut c_char,
        trans: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        ap: *mut dcomplex,
        b: *mut dcomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn ztpttf_(
        transr: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut dcomplex,
        arf: *mut dcomplex,
        info: *mut integer,
    );
    pub fn ztpttr_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut dcomplex,
        a: *mut dcomplex,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn ztrcon_(
        norm: *mut c_char,
        uplo: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        rcond: *mut f64,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn ztrevc3_(
        side: *mut c_char,
        howmny: *mut c_char,
        select: *mut logical,
        n: *mut integer,
        t: *mut dcomplex,
        ldt: *mut integer,
        vl: *mut dcomplex,
        ldvl: *mut integer,
        vr: *mut dcomplex,
        ldvr: *mut integer,
        mm: *mut integer,
        m: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        lrwork: *mut integer,
        info: *mut integer,
    );
    pub fn ztrevc_(
        side: *mut c_char,
        howmny: *mut c_char,
        select: *mut logical,
        n: *mut integer,
        t: *mut dcomplex,
        ldt: *mut integer,
        vl: *mut dcomplex,
        ldvl: *mut integer,
        vr: *mut dcomplex,
        ldvr: *mut integer,
        mm: *mut integer,
        m: *mut integer,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn ztrexc_(
        compq: *mut c_char,
        n: *mut integer,
        t: *mut dcomplex,
        ldt: *mut integer,
        q: *mut dcomplex,
        ldq: *mut integer,
        ifst: *mut integer,
        ilst: *mut integer,
        info: *mut integer,
    );
    pub fn ztrrfs_(
        uplo: *mut c_char,
        trans: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        x: *mut dcomplex,
        ldx: *mut integer,
        ferr: *mut f64,
        berr: *mut f64,
        work: *mut dcomplex,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn ztrsen_(
        job: *mut c_char,
        compq: *mut c_char,
        select: *mut logical,
        n: *mut integer,
        t: *mut dcomplex,
        ldt: *mut integer,
        q: *mut dcomplex,
        ldq: *mut integer,
        w: *mut dcomplex,
        m: *mut integer,
        s: *mut f64,
        sep: *mut f64,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn ztrsna_(
        job: *mut c_char,
        howmny: *mut c_char,
        select: *mut logical,
        n: *mut integer,
        t: *mut dcomplex,
        ldt: *mut integer,
        vl: *mut dcomplex,
        ldvl: *mut integer,
        vr: *mut dcomplex,
        ldvr: *mut integer,
        s: *mut f64,
        sep: *mut f64,
        mm: *mut integer,
        m: *mut integer,
        work: *mut dcomplex,
        ldwork: *mut integer,
        rwork: *mut f64,
        info: *mut integer,
    );
    pub fn ztrsyl_(
        trana: *mut c_char,
        tranb: *mut c_char,
        isgn: *mut integer,
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        c: *mut dcomplex,
        ldc: *mut integer,
        scale: *mut f64,
        info: *mut integer,
    );
    pub fn ztrti2_(
        uplo: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn ztrtri_(
        uplo: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn ztrtrs_(
        uplo: *mut c_char,
        trans: *mut c_char,
        diag: *mut c_char,
        n: *mut integer,
        nrhs: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        b: *mut dcomplex,
        ldb: *mut integer,
        info: *mut integer,
    );
    pub fn ztrttf_(
        transr: *mut c_char,
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        arf: *mut dcomplex,
        info: *mut integer,
    );
    pub fn ztrttp_(
        uplo: *mut c_char,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        ap: *mut dcomplex,
        info: *mut integer,
    );
    pub fn ztzrqf_(
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        tau: *mut dcomplex,
        info: *mut integer,
    );
    pub fn ztzrzf_(
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        tau: *mut dcomplex,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zunbdb1_(
        m: *mut integer,
        p: *mut integer,
        q: *mut integer,
        x11: *mut dcomplex,
        ldx11: *mut integer,
        x21: *mut dcomplex,
        ldx21: *mut integer,
        theta: *mut f64,
        phi: *mut f64,
        taup1: *mut dcomplex,
        taup2: *mut dcomplex,
        tauq1: *mut dcomplex,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zunbdb2_(
        m: *mut integer,
        p: *mut integer,
        q: *mut integer,
        x11: *mut dcomplex,
        ldx11: *mut integer,
        x21: *mut dcomplex,
        ldx21: *mut integer,
        theta: *mut f64,
        phi: *mut f64,
        taup1: *mut dcomplex,
        taup2: *mut dcomplex,
        tauq1: *mut dcomplex,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zunbdb3_(
        m: *mut integer,
        p: *mut integer,
        q: *mut integer,
        x11: *mut dcomplex,
        ldx11: *mut integer,
        x21: *mut dcomplex,
        ldx21: *mut integer,
        theta: *mut f64,
        phi: *mut f64,
        taup1: *mut dcomplex,
        taup2: *mut dcomplex,
        tauq1: *mut dcomplex,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zunbdb4_(
        m: *mut integer,
        p: *mut integer,
        q: *mut integer,
        x11: *mut dcomplex,
        ldx11: *mut integer,
        x21: *mut dcomplex,
        ldx21: *mut integer,
        theta: *mut f64,
        phi: *mut f64,
        taup1: *mut dcomplex,
        taup2: *mut dcomplex,
        tauq1: *mut dcomplex,
        phantom: *mut dcomplex,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zunbdb5_(
        m1: *mut integer,
        m2: *mut integer,
        n: *mut integer,
        x1: *mut dcomplex,
        incx1: *mut integer,
        x2: *mut dcomplex,
        incx2: *mut integer,
        q1: *mut dcomplex,
        ldq1: *mut integer,
        q2: *mut dcomplex,
        ldq2: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zunbdb6_(
        m1: *mut integer,
        m2: *mut integer,
        n: *mut integer,
        x1: *mut dcomplex,
        incx1: *mut integer,
        x2: *mut dcomplex,
        incx2: *mut integer,
        q1: *mut dcomplex,
        ldq1: *mut integer,
        q2: *mut dcomplex,
        ldq2: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zunbdb_(
        trans: *mut c_char,
        signs: *mut c_char,
        m: *mut integer,
        p: *mut integer,
        q: *mut integer,
        x11: *mut dcomplex,
        ldx11: *mut integer,
        x12: *mut dcomplex,
        ldx12: *mut integer,
        x21: *mut dcomplex,
        ldx21: *mut integer,
        x22: *mut dcomplex,
        ldx22: *mut integer,
        theta: *mut f64,
        phi: *mut f64,
        taup1: *mut dcomplex,
        taup2: *mut dcomplex,
        tauq1: *mut dcomplex,
        tauq2: *mut dcomplex,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zuncsd2by1_(
        jobu1: *mut c_char,
        jobu2: *mut c_char,
        jobv1t: *mut c_char,
        m: *mut integer,
        p: *mut integer,
        q: *mut integer,
        x11: *mut dcomplex,
        ldx11: *mut integer,
        x21: *mut dcomplex,
        ldx21: *mut integer,
        theta: *mut f64,
        u1: *mut dcomplex,
        ldu1: *mut integer,
        u2: *mut dcomplex,
        ldu2: *mut integer,
        v1t: *mut dcomplex,
        ldv1t: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        lrwork: *mut integer,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn zuncsd_(
        jobu1: *mut c_char,
        jobu2: *mut c_char,
        jobv1t: *mut c_char,
        jobv2t: *mut c_char,
        trans: *mut c_char,
        signs: *mut c_char,
        m: *mut integer,
        p: *mut integer,
        q: *mut integer,
        x11: *mut dcomplex,
        ldx11: *mut integer,
        x12: *mut dcomplex,
        ldx12: *mut integer,
        x21: *mut dcomplex,
        ldx21: *mut integer,
        x22: *mut dcomplex,
        ldx22: *mut integer,
        theta: *mut f64,
        u1: *mut dcomplex,
        ldu1: *mut integer,
        u2: *mut dcomplex,
        ldu2: *mut integer,
        v1t: *mut dcomplex,
        ldv1t: *mut integer,
        v2t: *mut dcomplex,
        ldv2t: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        rwork: *mut f64,
        lrwork: *mut integer,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn zung2l_(
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        tau: *mut dcomplex,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zung2r_(
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        tau: *mut dcomplex,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zungbr_(
        vect: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        tau: *mut dcomplex,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zunghr_(
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        tau: *mut dcomplex,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zungl2_(
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        tau: *mut dcomplex,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zunglq_(
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        tau: *mut dcomplex,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zungql_(
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        tau: *mut dcomplex,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zungqr_(
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        tau: *mut dcomplex,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zungr2_(
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        tau: *mut dcomplex,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zungrq_(
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        tau: *mut dcomplex,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zungtr_(
        uplo: *mut c_char,
        m: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        tau: *mut dcomplex,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zungtsqr_(
        m: *mut integer,
        n: *mut integer,
        mb: *mut integer,
        nb: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        t: *mut dcomplex,
        ldt: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zunhr_col_(
        m: *mut integer,
        n: *mut integer,
        nb: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        t: *mut dcomplex,
        ldt: *mut integer,
        d: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zunm22_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        n1: *mut integer,
        n2: *mut integer,
        q: *mut dcomplex,
        ldq: *mut integer,
        c: *mut dcomplex,
        ldc: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zunm2l_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        tau: *mut dcomplex,
        c: *mut dcomplex,
        ldc: *mut integer,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zunm2r_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        tau: *mut dcomplex,
        c: *mut dcomplex,
        ldc: *mut integer,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zunmbr_(
        vect: *mut c_char,
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        tau: *mut dcomplex,
        c: *mut dcomplex,
        ldc: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zunmhr_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        tau: *mut dcomplex,
        c: *mut dcomplex,
        ldc: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zunml2_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        tau: *mut dcomplex,
        c: *mut dcomplex,
        ldc: *mut integer,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zunmlq_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        tau: *mut dcomplex,
        c: *mut dcomplex,
        ldc: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zunmql_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        tau: *mut dcomplex,
        c: *mut dcomplex,
        ldc: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zunmqr_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        tau: *mut dcomplex,
        c: *mut dcomplex,
        ldc: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zunmr2_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        tau: *mut dcomplex,
        c: *mut dcomplex,
        ldc: *mut integer,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zunmr3_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        l: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        tau: *mut dcomplex,
        c: *mut dcomplex,
        ldc: *mut integer,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zunmrq_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        tau: *mut dcomplex,
        c: *mut dcomplex,
        ldc: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zunmrz_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        k: *mut integer,
        l: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        tau: *mut dcomplex,
        c: *mut dcomplex,
        ldc: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zunmtr_(
        side: *mut c_char,
        uplo: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        tau: *mut dcomplex,
        c: *mut dcomplex,
        ldc: *mut integer,
        work: *mut dcomplex,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn zupgtr_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut dcomplex,
        tau: *mut dcomplex,
        q: *mut dcomplex,
        ldq: *mut integer,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn zupmtr_(
        side: *mut c_char,
        uplo: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        ap: *mut dcomplex,
        tau: *mut dcomplex,
        c: *mut dcomplex,
        ldc: *mut integer,
        work: *mut dcomplex,
        info: *mut integer,
    );
    pub fn disnan_(din: *mut f64) -> logical;
    pub fn dlaisnan_(din1: *mut f64, din2: *mut f64) -> logical;
    pub fn sisnan_(sin__: *mut f32) -> logical;
    pub fn slaisnan_(sin1: *mut f32, sin2: *mut f32) -> logical;
    pub fn chla_transtype_(ret_val: *mut c_char, trans: *mut integer);
    pub fn cladiv_(ret_val: *mut scomplex, x: *mut scomplex, y: *mut scomplex);
    pub fn zladiv_(ret_val: *mut dcomplex, x: *mut dcomplex, y: *mut dcomplex);
    pub fn sgetrfnp_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn dgetrfnp_(
        m: *mut integer,
        n: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn cgetrfnp_(
        m: *mut integer,
        n: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn zgetrfnp_(
        m: *mut integer,
        n: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn sspffrt2_(
        ap: *mut f32,
        n: *mut integer,
        ncolm: *mut integer,
        work: *mut f32,
        work2: *mut f32,
    );
    pub fn dspffrt2_(
        ap: *mut f64,
        n: *mut integer,
        ncolm: *mut integer,
        work: *mut f64,
        work2: *mut f64,
    );
    pub fn cspffrt2_(
        ap: *mut scomplex,
        n: *mut integer,
        ncolm: *mut integer,
        work: *mut scomplex,
        work2: *mut scomplex,
    );
    pub fn zspffrt2_(
        ap: *mut dcomplex,
        n: *mut integer,
        ncolm: *mut integer,
        work: *mut dcomplex,
        work2: *mut dcomplex,
    );
    pub fn sspffrtx_(
        ap: *mut f32,
        n: *mut integer,
        ncolm: *mut integer,
        work: *mut f32,
        work2: *mut f32,
    );
    pub fn dspffrtx_(
        ap: *mut f64,
        n: *mut integer,
        ncolm: *mut integer,
        work: *mut f64,
        work2: *mut f64,
    );
    pub fn cspffrtx_(
        ap: *mut scomplex,
        n: *mut integer,
        ncolm: *mut integer,
        work: *mut scomplex,
        work2: *mut scomplex,
    );
    pub fn zspffrtx_(
        ap: *mut dcomplex,
        n: *mut integer,
        ncolm: *mut integer,
        work: *mut dcomplex,
        work2: *mut dcomplex,
    );
    pub fn cgetrfnpi_(
        m: *mut integer,
        n: *mut integer,
        nfact: *mut integer,
        a: *mut scomplex,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn dgetrfnpi_(
        m: *mut integer,
        n: *mut integer,
        nfact: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn sgetrfnpi_(
        m: *mut integer,
        n: *mut integer,
        nfact: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn zgetrfnpi_(
        m: *mut integer,
        n: *mut integer,
        nfact: *mut integer,
        a: *mut dcomplex,
        lda: *mut integer,
        info: *mut integer,
    );
    pub fn sopgtr_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut f32,
        tau: *mut f32,
        q: *mut f32,
        ldq: *mut integer,
        work: *mut f32,
        info: *mut integer,
    );
    pub fn dopgtr_(
        uplo: *mut c_char,
        n: *mut integer,
        ap: *mut f64,
        tau: *mut f64,
        q: *mut f64,
        ldq: *mut integer,
        work: *mut f64,
        info: *mut integer,
    );
    pub fn sorcsd_(
        jobu1: *mut c_char,
        jobu2: *mut c_char,
        jobv1t: *mut c_char,
        jobv2t: *mut c_char,
        trans: *mut c_char,
        signs: *mut c_char,
        m: *mut integer,
        p: *mut integer,
        q: *mut integer,
        x11: *mut f32,
        ldx11: *mut integer,
        x12: *mut f32,
        ldx12: *mut integer,
        x21: *mut f32,
        ldx21: *mut integer,
        x22: *mut f32,
        ldx22: *mut integer,
        theta: *mut f32,
        u1: *mut f32,
        ldu1: *mut integer,
        u2: *mut f32,
        ldu2: *mut integer,
        v1t: *mut f32,
        ldv1t: *mut integer,
        v2t: *mut f32,
        ldv2t: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dorcsd_(
        jobu1: *mut c_char,
        jobu2: *mut c_char,
        jobv1t: *mut c_char,
        jobv2t: *mut c_char,
        trans: *mut c_char,
        signs: *mut c_char,
        m: *mut integer,
        p: *mut integer,
        q: *mut integer,
        x11: *mut f64,
        ldx11: *mut integer,
        x12: *mut f64,
        ldx12: *mut integer,
        x21: *mut f64,
        ldx21: *mut integer,
        x22: *mut f64,
        ldx22: *mut integer,
        theta: *mut f64,
        u1: *mut f64,
        ldu1: *mut integer,
        u2: *mut f64,
        ldu2: *mut integer,
        v1t: *mut f64,
        ldv1t: *mut integer,
        v2t: *mut f64,
        ldv2t: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn sorcsd2by1_(
        jobu1: *mut c_char,
        jobu2: *mut c_char,
        jobv1t: *mut c_char,
        m: *mut integer,
        p: *mut integer,
        q: *mut integer,
        x11: *mut f32,
        ldx11: *mut integer,
        x21: *mut f32,
        ldx21: *mut integer,
        theta: *mut f32,
        u1: *mut f32,
        ldu1: *mut integer,
        u2: *mut f32,
        ldu2: *mut integer,
        v1t: *mut f32,
        ldv1t: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn dorcsd2by1_(
        jobu1: *mut c_char,
        jobu2: *mut c_char,
        jobv1t: *mut c_char,
        m: *mut integer,
        p: *mut integer,
        q: *mut integer,
        x11: *mut f64,
        ldx11: *mut integer,
        x21: *mut f64,
        ldx21: *mut integer,
        theta: *mut f64,
        u1: *mut f64,
        ldu1: *mut integer,
        u2: *mut f64,
        ldu2: *mut integer,
        v1t: *mut f64,
        ldv1t: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        iwork: *mut integer,
        info: *mut integer,
    );
    pub fn sorghr_(
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        tau: *mut f32,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dorghr_(
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        tau: *mut f64,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn sormhr_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        a: *mut f32,
        lda: *mut integer,
        tau: *mut f32,
        c__: *mut f32,
        ldc: *mut integer,
        work: *mut f32,
        lwork: *mut integer,
        info: *mut integer,
    );
    pub fn dormhr_(
        side: *mut c_char,
        trans: *mut c_char,
        m: *mut integer,
        n: *mut integer,
        ilo: *mut integer,
        ihi: *mut integer,
        a: *mut f64,
        lda: *mut integer,
        tau: *mut f64,
        c__: *mut f64,
        ldc: *mut integer,
        work: *mut f64,
        lwork: *mut integer,
        info: *mut integer,
    );
}
    