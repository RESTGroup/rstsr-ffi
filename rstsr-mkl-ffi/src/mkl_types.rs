/* The following part is manually handled */

pub(crate) use core::ffi::{c_char, c_int, c_uchar, c_void};
pub(crate) use half::{bf16, f16};
pub(crate) use num::complex::Complex;

#[cfg(feature = "ilp64")]
mod mode_ilp64 {
    pub type MKL_INT = i64;
    pub type MKL_UINT = u64;
    pub type MKL_LONG = i64;
}
#[cfg(feature = "ilp64")]
pub use mode_ilp64::*;

#[cfg(not(feature = "ilp64"))]
mod mode_lp64 {
    use core::ffi::{c_int, c_long, c_uint};

    pub type MKL_INT = c_int;
    pub type MKL_UINT = c_uint;
    pub type MKL_LONG = c_long;
}
#[cfg(not(feature = "ilp64"))]
pub use mode_lp64::*;

pub type MKL_INT8 = i8;
pub type MKL_UINT8 = u8;
pub type MKL_INT16 = i16;
pub type MKL_INT32 = i32;
pub type MKL_INT64 = i64;
pub type MKL_UINT64 = u64;
pub type MKL_F16 = f16;
pub type MKL_BF16 = bf16;
pub type MKL_E5M2 = c_uchar;
pub type MKL_E4M3 = c_uchar;
pub type MKL_Complex8 = Complex<f32>;
pub type MKL_Complex16 = Complex<f64>;

/* automatically generated by rust-bindgen 0.71.1 */

pub const MKL_DOMAIN_ALL: u32 = 0;
pub const MKL_DOMAIN_BLAS: u32 = 1;
pub const MKL_DOMAIN_FFT: u32 = 2;
pub const MKL_DOMAIN_VML: u32 = 3;
pub const MKL_DOMAIN_PARDISO: u32 = 4;
pub const MKL_DOMAIN_LAPACK: u32 = 5;
pub const MKL_CBWR_BRANCH: u32 = 1;
pub const MKL_CBWR_ALL: i32 = -1;
pub const MKL_CBWR_STRICT: u32 = 65536;
pub const MKL_CBWR_OFF: u32 = 0;
pub const MKL_CBWR_BRANCH_OFF: u32 = 1;
pub const MKL_CBWR_AUTO: u32 = 2;
pub const MKL_CBWR_COMPATIBLE: u32 = 3;
pub const MKL_CBWR_SSE2: u32 = 4;
pub const MKL_CBWR_SSSE3: u32 = 6;
pub const MKL_CBWR_SSE4_1: u32 = 7;
pub const MKL_CBWR_SSE4_2: u32 = 8;
pub const MKL_CBWR_AVX: u32 = 9;
pub const MKL_CBWR_AVX2: u32 = 10;
pub const MKL_CBWR_AVX512_MIC: u32 = 11;
pub const MKL_CBWR_AVX512: u32 = 12;
pub const MKL_CBWR_AVX512_MIC_E1: u32 = 13;
pub const MKL_CBWR_AVX512_E1: u32 = 14;
pub const MKL_CBWR_AVX10: u32 = 15;
pub const MKL_CBWR_SUCCESS: u32 = 0;
pub const MKL_CBWR_ERR_INVALID_SETTINGS: i32 = -1;
pub const MKL_CBWR_ERR_INVALID_INPUT: i32 = -2;
pub const MKL_CBWR_ERR_UNSUPPORTED_BRANCH: i32 = -3;
pub const MKL_CBWR_ERR_UNKNOWN_BRANCH: i32 = -4;
pub const MKL_CBWR_ERR_MODE_CHANGE_FAILURE: i32 = -8;
pub const MKL_CBWR_SSE3: u32 = 5;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MKLVersion {
    pub MajorVersion: c_int,
    pub MinorVersion: c_int,
    pub UpdateVersion: c_int,
    pub PatchVersion: c_int,
    pub ProductStatus: *mut c_char,
    pub Build: *mut c_char,
    pub Processor: *mut c_char,
    pub Platform: *mut c_char,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum MKL_LAYOUT {
    MKL_ROW_MAJOR = 101,
    MKL_COL_MAJOR = 102,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum MKL_TRANSPOSE {
    MKL_NOTRANS = 111,
    MKL_TRANS = 112,
    MKL_CONJTRANS = 113,
    MKL_CONJ = 114,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum MKL_UPLO {
    MKL_UPPER = 121,
    MKL_LOWER = 122,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum MKL_DIAG {
    MKL_NONUNIT = 131,
    MKL_UNIT = 132,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum MKL_SIDE {
    MKL_LEFT = 141,
    MKL_RIGHT = 142,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum MKL_COMPACT_PACK {
    MKL_COMPACT_SSE = 181,
    MKL_COMPACT_AVX = 182,
    MKL_COMPACT_AVX512 = 183,
}
pub type sgemm_jit_kernel_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut c_void, arg2: *mut f32, arg3: *mut f32, arg4: *mut f32),
>;
pub type dgemm_jit_kernel_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut c_void, arg2: *mut f64, arg3: *mut f64, arg4: *mut f64),
>;
pub type cgemm_jit_kernel_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut c_void,
        arg2: *mut MKL_Complex8,
        arg3: *mut MKL_Complex8,
        arg4: *mut MKL_Complex8,
    ),
>;
pub type zgemm_jit_kernel_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut c_void,
        arg2: *mut MKL_Complex16,
        arg3: *mut MKL_Complex16,
        arg4: *mut MKL_Complex16,
    ),
>;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum mkl_jit_status_t {
    MKL_JIT_SUCCESS = 0,
    MKL_NO_JIT = 1,
    MKL_JIT_ERROR = 2,
}
